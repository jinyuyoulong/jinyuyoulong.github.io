<!doctype html>
<html lang="zh-CN">
  <head>
    <title>Go 代码规范 // 为吾优</title>
    <meta charset="utf-8" />
    <meta name="generator" content="Hugo 0.55.5" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="author" content="范金龙" />
    <meta name="description" content="" />
    <link rel="stylesheet" href="https://blog.v5u.win/css/main.min.59023e5fd38d6ecb0e1dfbb295077c3c67e00e3b9eb3feaf34b5a5e6b332897a.css" />

    
    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Go 代码规范"/>
<meta name="twitter:description" content="[TOC]
Golang代码规范 参考 https://golang.org/doc/effective_go.html 本文参考blog
项目目录结构规范 PROJECT_NAME ├── README.md 介绍软件及文档入口 ├── bin 编译好的二进制文件,执行./build.sh自动生成，该目录也用于程序打包 ├── build.sh 自动编译的脚本 ├── doc 该项目的文档 ├── pack 打包后的程序放在此处 ├── pack.sh 自动打包的脚本，生成类似xxxx.20170713_14:45:35.tar.gz的文件，放在pack文件下 ├── public 公共文件/静态文件 └── src 该项目的源代码 ├── main 项目主函数 ├── test 测试 ├── app 项目代码 ├── research 在实现该项目中探究的一些程序 └── vendor 存放go的库 ├── github.com/xxx 第三方库 └── xxx.com/abc 公司内部的公共库  项目的目录结构尽量做到简明、层次清楚。
./app ├── bootstrap	//入口引导文件 ├── cache ├── config	//项目配置 项目配置文件简单，配置项少。大部分配置公司要用配置中心统一配置。 ├── controller	//request请求处理中心 ——&gt; controller ——&gt; Response / view ├── library	//项目工具库 ├── log	//日志 ├── middleware	//中间件 ├── model	//data model."/>

    <meta property="og:title" content="Go 代码规范" />
<meta property="og:description" content="[TOC]
Golang代码规范 参考 https://golang.org/doc/effective_go.html 本文参考blog
项目目录结构规范 PROJECT_NAME ├── README.md 介绍软件及文档入口 ├── bin 编译好的二进制文件,执行./build.sh自动生成，该目录也用于程序打包 ├── build.sh 自动编译的脚本 ├── doc 该项目的文档 ├── pack 打包后的程序放在此处 ├── pack.sh 自动打包的脚本，生成类似xxxx.20170713_14:45:35.tar.gz的文件，放在pack文件下 ├── public 公共文件/静态文件 └── src 该项目的源代码 ├── main 项目主函数 ├── test 测试 ├── app 项目代码 ├── research 在实现该项目中探究的一些程序 └── vendor 存放go的库 ├── github.com/xxx 第三方库 └── xxx.com/abc 公司内部的公共库  项目的目录结构尽量做到简明、层次清楚。
./app ├── bootstrap	//入口引导文件 ├── cache ├── config	//项目配置 项目配置文件简单，配置项少。大部分配置公司要用配置中心统一配置。 ├── controller	//request请求处理中心 ——&gt; controller ——&gt; Response / view ├── library	//项目工具库 ├── log	//日志 ├── middleware	//中间件 ├── model	//data model." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://blog.v5u.win/post/go-%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/" />
<meta property="article:published_time" content="2019-04-29T11:37:14&#43;08:00"/>
<meta property="article:modified_time" content="2019-04-29T11:37:14&#43;08:00"/>


  </head>
  <body>
    <header class="app-header">
      <a href="https://blog.v5u.win"><img class="app-header-avatar" src="/avatar.jpg" alt="范金龙" /></a>
      <h1>为吾优</h1>
      <p>愿我走在通往幸福的路上</p>
      <div class="app-header-social">
        
          <a target="_blank" href="https://github.com/jinyuyoulong"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-github">
  <title>github</title>
  <path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path>
</svg></a>
        
          <a target="_blank" href="https://blog.v5u.win/desc/about/"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-link">
  <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path>
  <path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path>
</svg></a>
        
      </div>
    </header>
    <main class="app-container">
      
  <article class="post">
    <header class="post-header">
      <h1 class ="post-title">Go 代码规范</h1>
      <div class="post-meta">
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar">
  <title>calendar</title>
  <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line>
</svg>
          Apr 29, 2019
        </div>
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock">
  <title>clock</title>
  <circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline>
</svg>
          4 min read
        </div></div>
    </header>
    <div class="post-content">
      

<p>[TOC]</p>

<h2 id="golang代码规范">Golang代码规范</h2>

<p>参考 <a href="https://golang.org/doc/effective_go.html">https://golang.org/doc/effective_go.html</a>
<a href="https://sheepbao.github.io/post/golang_code_specification/?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io">本文参考blog</a></p>

<h3 id="项目目录结构规范">项目目录结构规范</h3>

<pre><code class="language-sh">PROJECT_NAME
├── README.md 介绍软件及文档入口
├── bin 编译好的二进制文件,执行./build.sh自动生成，该目录也用于程序打包
├── build.sh 自动编译的脚本
├── doc 该项目的文档
├── pack 打包后的程序放在此处
├── pack.sh 自动打包的脚本，生成类似xxxx.20170713_14:45:35.tar.gz的文件，放在pack文件下
├── public 公共文件/静态文件
└── src 该项目的源代码
    ├── main 项目主函数
    ├── test 测试
    ├── app 项目代码
    ├── research 在实现该项目中探究的一些程序
    └── vendor 存放go的库
        ├── github.com/xxx 第三方库
        └── xxx.com/abc 公司内部的公共库
</code></pre>

<p>项目的目录结构尽量做到简明、层次清楚。</p>

<pre><code class="language-sh">./app
├── bootstrap	//入口引导文件
├── cache
├── config	//项目配置 项目配置文件简单，配置项少。大部分配置公司要用配置中心统一配置。
├── controller	//request请求处理中心 ——&gt; controller ——&gt; Response / view
├── library	//项目工具库
├── log			//日志
├── middleware	//中间件
├── model		//data model.xorm -——&gt; 数据库表映射模型
├── plugin	//插件--自己开发/自己找的 --delete
├── route		//路由管理
├── service	//前端数据获取操作 service
</code></pre>

<hr />

<h4 id="文件名命名规范">文件名命名规范</h4>

<p>用小写，尽量见名思义，看见文件名就可以知道这个文件下的大概内容，对于源代码里的文件，文件名要很好的代表了一个模块实现的功能。</p>

<h3 id="命名规范">命名规范</h3>

<h4 id="包名">包名</h4>

<p>包名用小写,使用短命名,尽量和标准库不要冲突</p>

<h4 id="接口名">接口名</h4>

<p>单个函数的接口名以”er”作为后缀，如Reader,Writer</p>

<p>接口的实现则去掉“er”</p>

<pre><code class="language-go">type Reader interface {
        Read(p []byte) (n int, err error)
}
</code></pre>

<p>两个函数的接口名综合两个函数名</p>

<pre><code class="language-go">type WriteFlusher interface {
    Write([]byte) (int, error)
    Flush() error
}
</code></pre>

<p>三个以上函数的接口名，类似于结构体名</p>

<pre><code class="language-go">type Car interface {
    Start([]byte) 
    Stop() error
    Recover()
}
</code></pre>

<h4 id="变量">变量</h4>

<p>全局变量：采用驼峰命名法，仅限在包内的全局变量，包外引用需要写接口，提供调用 局部变量：驼峰式，小写字母开头</p>

<h4 id="常量">常量</h4>

<p>常量：大写，采用下划线</p>

<h3 id="import-规范">import 规范</h3>

<p>import在多行的情况下，goimports会自动帮你格式化，在一个文件里面引入了一个package，建议采用如下格式：</p>

<pre><code class="language-go">import (
    &quot;fmt&quot;
)
</code></pre>

<p>如果你的包引入了三种类型的包，标准库包，程序内部包，第三方包，建议采用如下方式进行组织你的包：</p>

<pre><code class="language-go">import (
    &quot;encoding/json&quot;
    &quot;strings&quot;

    &quot;myproject/model&quot;
    &quot;myproject/controller&quot;
    &quot;git.obc.im/obc/utils&quot;

    &quot;git.obc.im/dep/beego&quot;
    &quot;git.obc.im/dep/mysql&quot;
    // 空白引入需要添加注释
		// 空白导入应该只在主包或测试包中，或者有一个注释证明它是正确的
		_ &quot;github.com/jinzhu/gorm/dialects/mysql&quot;
)  
</code></pre>

<p>在项目中不要使用相对路径引入包：</p>

<p>// 这是不好的导入</p>

<pre><code class="language-go">import “../net”
</code></pre>

<p>// 这是正确的做法</p>

<pre><code class="language-go">import “xxxx.com/proj/net”
</code></pre>

<h4 id="函数名">函数名</h4>

<p>函数名采用驼峰命名法，尽量不要使用下划线</p>

<h3 id="错误处理">错误处理</h3>

<p>error作为函数的值返回,必须尽快对error进行处理
采用独立的错误流进行处理
不要采用这种方式</p>

<pre><code class="language-go">    if err != nil {
        // error handling
    } else {
        // normal code
    }
</code></pre>

<p>而要采用下面的方式</p>

<pre><code class="language-go">    if err != nil {
        // error handling
        return // or continue, etc.
    }
    // normal code
</code></pre>

<p>如果返回值需要初始化，则采用下面的方式</p>

<pre><code class="language-go">x, err := f()
if err != nil {
    // error handling
    return
}
// use x
</code></pre>

<h4 id="panic">Panic</h4>

<p>在逻辑处理中禁用panic
在main包中只有当实在不可运行的情况采用panic，例如文件无法打开，数据库无法连接导致程序无法 正常运行，但是对于其他的package对外的接口不能有panic，只能在包内采用。 建议在main包中使用log.Fatal来记录错误，这样就可以由log来结束程序。</p>

<h4 id="recover">Recover</h4>

<p>recover用于捕获runtime的异常，禁止滥用recover，在开发测试阶段尽量不要用recover，recover一般放在你认为会有不可预期的异常的地方。</p>

<pre><code class="language-go">func server(workChan &lt;-chan *Work) {
    for work := range workChan {
        go safelyDo(work)
    }
}

func safelyDo(work *Work) {
    defer func() {
        if err := recover(); err != nil {
            log.Println(&quot;work failed:&quot;, err)
        }
    }()
    // do 函数可能会有不可预期的异常
    do(work)
}
</code></pre>

<h4 id="defer">Defer</h4>

<p>defer在函数return之前执行，对于一些资源的回收用defer是好的，但也禁止滥用defer，defer是需要消耗性能的,所以频繁调用的函数尽量不要使用defer。</p>

<pre><code class="language-go">// Contents returns the file's contents as a string.
func Contents(filename string) (string, error) {
    f, err := os.Open(filename)
    if err != nil {
        return &quot;&quot;, err
    }
    defer f.Close()  // f.Close will run when we're finished.

    var result []byte
    buf := make([]byte, 100)
    for {
        n, err := f.Read(buf[0:])
        result = append(result, buf[0:n]...) // append is discussed later.
        if err != nil {
            if err == io.EOF {
                break
            }
            return &quot;&quot;, err  // f will be closed if we return here.
        }
    }
    return string(result), nil // f will be closed if we return here.
}
</code></pre>

<h3 id="控制结构">控制结构</h3>

<h4 id="if">if</h4>

<p>if接受初始化语句，约定如下方式建立局部变量</p>

<pre><code class="language-go">if err := file.Chmod(0664); err != nil {
    return err
}
</code></pre>

<h4 id="for">for</h4>

<p>采用短声明建立局部变量</p>

<pre><code class="language-go">sum := 0
for i := 0; i &lt; 10; i++ {
    sum += i
}
</code></pre>

<h4 id="range">range</h4>

<p>如果只需要第一项（key），就丢弃第二个：</p>

<pre><code class="language-go">for key := range m {
    if key.expired() {
        delete(m, key)
    }
}
</code></pre>

<p>如果只需要第二项，则把第一项置为下划线</p>

<pre><code class="language-go">sum := 0
for _, value := range array {
    sum += value
}
</code></pre>

<h4 id="return">return</h4>

<p>尽早return：一旦有错误发生，马上返回</p>

<pre><code class="language-go">f, err := os.Open(name)
if err != nil {
    return err
}
d, err := f.Stat()
if err != nil {
    f.Close()
    return err
}
codeUsing(f, d)
</code></pre>

<h3 id="方法的接收器">方法的接收器</h3>

<p>名称 一般采用strcut的第一个字母且为小写，而不是this，me或者self</p>

<pre><code class="language-go">    type T struct{} 
    func (p *T)Get(){}
</code></pre>

<p>如果接收者是map,slice或者chan，不要用指针传递</p>

<pre><code class="language-go">//Map
package main

import (
    &quot;fmt&quot;
)

type mp map[string]string

func (m mp) Set(k, v string) {
    m[k] = v
}

func main() {
    m := make(mp)
    m.Set(&quot;k&quot;, &quot;v&quot;)
    fmt.Println(m)
}
//Channel
package main

import (
    &quot;fmt&quot;
)

type ch chan interface{}

func (c ch) Push(i interface{}) {
    c &lt;- i
}

func (c ch) Pop() interface{} {
    return &lt;-c
}

func main() {
    c := make(ch, 1)
    c.Push(&quot;i&quot;)
    fmt.Println(c.Pop())
}
</code></pre>

<p>如果需要对slice进行修改，通过返回值的方式重新赋值</p>

<pre><code class="language-go">//Slice
package main

import (
    &quot;fmt&quot;
)

type slice []byte

func main() {
    s := make(slice, 0)
    s = s.addOne(42)
    fmt.Println(s)
}

func (s slice) addOne(b byte) []byte {
    return append(s, b)
}
</code></pre>

<p>如果接收者是含有sync.Mutex或者类似同步字段的结构体，必须使用指针传递避免复制</p>

<pre><code class="language-go">package main

import (
    &quot;sync&quot;
)

type T struct {
    m sync.Mutex
}

func (t *T) lock() {
    t.m.Lock()
}

/*
Wrong !!!
func (t T) lock() {
    t.m.Lock()
}
*/

func main() {
    t := new(T)
    t.lock()
}
</code></pre>

<p>如果接收者是大的结构体或者数组，使用指针传递会更有效率。</p>

<pre><code class="language-go">package main

import (
    &quot;fmt&quot;
)

type T struct {
    data [1024]byte
}

func (t *T) Get() byte {
    return t.data[0]
}

func main() {
    t := new(T)
    fmt.Println(t.Get())
}
</code></pre>

<h3 id="注释">注释</h3>

<ol>
<li>所有的 public 方法和变量都要添加注释</li>
<li>注释格式为：name describeContent
<code>go
// TubeName1 channel 1
	TubeName1 = &quot;通道一&quot;
</code></li>
</ol>

    </div>
    <div class="post-footer">
      
    </div>
  </article>

    </main>
  </body>
</html>
