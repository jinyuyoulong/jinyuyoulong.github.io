{
    "title": "Go异常处理",
    "date": "2019-02-18 15:48:37 +0000 UTC",
    "type": "post",
    "permalink" : "http://blog.v5u.win/post/go-error/index.json",
    "summary" : "type error interface { Error() string }  error的声明
创建一个error
if path == &quot;&quot; { return nil, errors.New(&quot;The parameter is invalid!&quot;) }  error的使用
func readFile(path string) ([]byte, error) { file, err := os.Open(path) if err != nil { return nil, err } defer file.Close() return ioutil.ReadAll(file) }  异常处理——panic 译为运行时恐慌
内建函数panic和recover是天生的一对。前者用于产生运行时恐慌，而后者用于“恢复”它。
不过要注意，recover函数必须要在defer语句中调用才有效。因为一旦有运行时恐慌发生，当前函数以及在调用栈上的所有代码都是失去对流程的控制权。只有defer语句携带的函数中的代码才可能在运行时恐慌迅速向调用栈上层蔓延时“拦截到”它。
defer func() { if p := recover(); p != nil { fmt.Printf(&quot;Fatal error: %s\n&quot;, p) } }()  panic函数。该函数可接受一个interface{}类型的值作为其参数。也就是说，我们可以在调用panic函数的时候可以传入任何类型的值。不过，我建议大家在这里只传入error类型的值。这样它表达的语义才是精确的。更重要的是，当我们调用recover函数来“恢复”由于调用panic函数而引发的运行时恐慌的时候，得到的值正是调用后者时传给它的那个参数。因此，有这样一个约定是很有必要的。"
}