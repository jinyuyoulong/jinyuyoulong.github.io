<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>system on 为吾优</title>
    <link>https://blog.v5u.win/categories/system/</link>
    <description>Recent content in system on 为吾优</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Mon, 12 Aug 2019 10:46:26 +0800</lastBuildDate>
    
	<atom:link href="https://blog.v5u.win/categories/system/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>System 进程间通讯方式</title>
      <link>https://blog.v5u.win/post/system-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E8%AE%AF%E6%96%B9%E5%BC%8F/</link>
      <pubDate>Mon, 12 Aug 2019 10:46:26 +0800</pubDate>
      
      <guid>https://blog.v5u.win/post/system-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E8%AE%AF%E6%96%B9%E5%BC%8F/</guid>
      <description>进程通信： 每个进程各自有不同的用户地址空间,任何一个进程的全局变量在另一个进程中都看不到，所以进程之间要交换数据必须通过内核,在内核中开辟一块缓冲区,进程A把数据从用户空间拷到内核缓冲区,进程B再从内核缓冲区把数据读走,内核提供的这种机制称为进程间通信。
[TOC]
进程间8种通讯方式 匿名管道通信 匿名管道( pipe )：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。
// 需要的头文件 #include &amp;lt;unistd.h&amp;gt; // 通过pipe()函数来创建匿名管道 // 返回值：成功返回0，失败返回-1 // fd参数返回两个文件描述符 // fd[0]指向管道的读端，fd[1]指向管道的写端 // fd[1]的输出是fd[0]的输入。 int pipe (int fd[2]);  通过匿名管道实现进程间通信的步骤如下：
父进程创建管道，得到两个⽂件描述符指向管道的两端 父进程fork出子进程，⼦进程也有两个⽂件描述符指向同⼀管道。 父进程关闭fd[0],子进程关闭fd[1]，即⽗进程关闭管道读端,⼦进程关闭管道写端（因为管道只支持单向通信）。⽗进程可以往管道⾥写,⼦进程可以从管道⾥读,管道是⽤环形队列实现的,数据从写端流⼊从读端流出,这样就实现了进程间通信。 详细可参考文章：进程间的通信方式——pipe（管道）
高级管道通信 高级管道(popen)：将另一个程序当做一个新的进程在当前程序进程中启动，则它算是当前程序的子进程，这种方式我们成为高级管道方式。
有名管道通信 有名管道 (named pipe) ： 有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。
消息队列通信 消息队列( message queue ) ： 消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。
信号量通信 信号量( semophore ) ： 信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。
信号 信号 ( sinal ) ： 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。
共享内存通信 共享内存( shared memory ) ：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。
套接字通信 套接字( socket ) ： 套接口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同机器间的进程通信。</description>
    </item>
    
    <item>
      <title>flutter安装</title>
      <link>https://blog.v5u.win/post/system-flutter%E5%AE%89%E8%A3%85/</link>
      <pubDate>Fri, 26 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/system-flutter%E5%AE%89%E8%A3%85/</guid>
      <description>flutter安装
 git 下载 flutter：git clone -b stable https://github.com/flutter/flutter.git 配置.zshrc  export PATH=/Users/fanjinlong/dev/flutter/flutter/bin:$PATH export ANDROID_HOME=/Users/fanjinlong/Library/Android/sdk export PATH=${PATH}:${ANDROID_HOME}/tools export PATH=${PATH}:${ANDROID_HOME}/platform-tools export PUB_HOSTED_URL=https://pub.flutter-io.cn export FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn	# 记得配置完了，执行下 source ~/.zshrc 更新环境变量   命令行执行 flutter doctor 检查环境配置情况。 在 Android studio 中添加插件 flutter + dart 根据flutter doctor 解决所有必要的问题 运行 flutter run 如果不能运行，查看报错，比如 flutter emulators——&amp;gt;flutter emulators --launch Pixel_2_API_29——&amp;gt; flutter run  Running &amp;quot;flutter pub get&amp;quot; in flutter_app... 3.4s Using hardware rendering with device Android SDK built for x86.</description>
    </item>
    
    <item>
      <title>Nginx 动态生成缩略图</title>
      <link>https://blog.v5u.win/post/system-nginx/</link>
      <pubDate>Mon, 01 Jul 2019 15:05:09 +0800</pubDate>
      
      <guid>https://blog.v5u.win/post/system-nginx/</guid>
      <description>[TOC]
有的时候要生成大量尺寸的缩图，事先不知道有哪些尺寸，所以可以用php动态生成；
1.在nginx中配置
location ~ ..(gif|jpg|jpeg|png|bmp)$ { if ( !-f $request_filename) { rewrite ^(.)/(.*)(\d+)(\d+).(gif|jpg|jpeg|png|bmp) /ImageTransferController.php?s=1/2_3_4.5; } expires 30d; }   完善 ImageTransferController.php 文件  </description>
    </item>
    
    <item>
      <title>开源贡献者盟约</title>
      <link>https://blog.v5u.win/post/system-%E8%B4%A1%E7%8C%AE%E8%80%85%E7%9B%9F%E7%BA%A6/</link>
      <pubDate>Tue, 25 Jun 2019 15:38:20 +0800</pubDate>
      
      <guid>https://blog.v5u.win/post/system-%E8%B4%A1%E7%8C%AE%E8%80%85%E7%9B%9F%E7%BA%A6/</guid>
      <description>[TOC]
参与者公约 我们的保证 为了促进一个开放透明且友好的环境，我们作为贡献者和维护者保证：无论年龄、种族、民族、性别认同和表达（方式）、体型、身体健全与否、经验水平、国籍、个人表现、宗教或性别取向，参与者在我们项目和社区中都免于骚扰。
我们的标准 有助于创造正面环境的行为包括但不限于：
 使用友好和包容性语言 尊重不同的观点和经历 耐心地接受建设性批评 关注对社区最有利的事情 友善对待其他社区成员  身为参与者不能接受的行为包括但不限于：
 使用与性有关的言语或是图像，以及不受欢迎的性骚扰 捣乱/煽动/造谣的行为或进行侮辱/贬损的评论，人身攻击及政治攻击 公开或私下的骚扰 未经许可地发布他人的个人资料，例如住址或是电子地址 其他可以被合理地认定为不恰当或者违反职业操守的行为  我们的责任 项目维护者有责任为「可接受的行为」标准做出诠释，以及对已发生的不被接受的行为采取恰当且公平的纠正措施。
项目维护者有权利及责任去删除、编辑、拒绝与本行为标准有所违背的评论 (comments)、提交 (commits)、代码、wiki 编辑、问题 (issues) 和其他贡献，以及项目维护者可暂时或永久性的禁止任何他们认为有不适当、威胁、冒犯、有害行为的贡献者。
使用范围 当一个人代表该项目或是其社区时，本行为标准适用于其项目平台和公共平台。
代表项目或是社区的情况，举例来说包括使用官方项目的电子邮件地址、通过官方的社区媒体账号发布或线上或线下事件中担任指定代表。
该项目的呈现方式可由其项目维护者进行进一步的定义及解释。
强制执行 可以通过[在此放入EMAIL]，来联系项目团队来举报滥用、骚扰或其他不被接受的行为。
任何维护团队认为有必要且适合的所有投诉都将进行审查及调查，并做出相对应的回应。项目小组有对事件回报者有保密的义务。具体执行的方针近一步细节可能会单独公布。
没有切实地遵守或是执行本行为标准的项目维护人员，可能会因项目领导人或是其他成员的决定，暂时或是永久地取消其参与资格。
来源 本行为标准改编自贡献者公约，版本 1.4 可在此观看https://www.contributor-covenant.org/zh-cn/version/1/4/code-of-conduct.html</description>
    </item>
    
    <item>
      <title>markdown 常用语法整理</title>
      <link>https://blog.v5u.win/post/system-markdown%E5%8E%9F%E7%90%86/</link>
      <pubDate>Fri, 10 May 2019 00:00:00 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/system-markdown%E5%8E%9F%E7%90%86/</guid>
      <description>Text  1级标题 Text  2级标题 Text  3级标题 Text  4级标题 Text  5级标题 Text  6级标题 有序列表 ul&amp;gt;li  有 序
无序列表 ol&amp;gt;li 无
 序
任务列表 ul&amp;gt;li&amp;gt;input [ ] 任务
 [x] 列表
代码修饰 短代码 &amp;lt;code&amp;gt;
  var name = 代码块 div&amp;gt;pre&amp;gt;span &amp;lt;div&amp;gt; &amp;lt;pre&amp;gt; &amp;lt;span&amp;gt;var&amp;lt;/span&amp;gt; name = 代码块 &amp;lt;/pre&amp;gt; &amp;lt;/div&amp;gt;   &amp;lt;blockquote&amp;gt;&amp;lt;p&amp;gt;块级引用&amp;lt;/p&amp;gt;&amp;lt;/blockquote&amp;gt;
 段落 中间没有空行的连续不断的几行文字被视为一个段落。空一行 作为段落间的分割符
行内格式 删除线 del 标签 加粗 strong 标签 斜体 em 标签</description>
    </item>
    
    <item>
      <title>语言特性汇总</title>
      <link>https://blog.v5u.win/post/system-%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7%E6%B1%87%E6%80%BB/</link>
      <pubDate>Tue, 03 Jul 2018 00:00:00 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/system-%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7%E6%B1%87%E6%80%BB/</guid>
      <description>语言特性汇总：
 类型推导， 类型检查， 惰性求值 currying 闭包 OO lambda  </description>
    </item>
    
    <item>
      <title>函数式编程</title>
      <link>https://blog.v5u.win/post/system-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/</link>
      <pubDate>Fri, 05 Aug 2016 10:46:42 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/system-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/</guid>
      <description> 函数式编程的三大特性： •immutable data 不可变数据：
像Clojure一样，默认上变量是不可变的，如果你要改变变量，你需要把变量copy出去修改。这样一来，可以让你的程序少很多Bug。因为，程序中的状态不好维护，在并发的时候更不好维护。（你可以试想一下如果你的程序有个复杂的状态，当以后别人改你代码的时候，是很容易出bug的，在并行中这样的问题就更多了）
•first class functions：
这个技术可以让你的函数就像变量一样来使用。也就是说，你的函数可以像变量一样被创建，修改，并当成变量一样传递，返回或是在函数中嵌套函数。这个有点像Javascript的Prototype（参看Javascript的面向对象编程）
•尾递归优化：
我们知道递归的害处，那就是如果递归很深的话，stack受不了，并会导致性能大幅度下降。所以，我们使用尾递归优化技术——每次递归时都会重用stack，这样一来能够提升性能，当然，这需要语言或编译器的支持。Python就不支持。
函数式编程的准则：不依赖于外部的数据，而且也不改变外部数据的值，而是返回一个新的值给你。
函数式编程的理念：把函数当成变量来用，关注于描述问题而不是怎么实现，这样可以让代码更易读。
把代码逻辑封装成了函数后，我们就相当于给每个相对独立的程序逻辑取了个名字，于是代码成了自解释的。
但是这些函数间必需知道其它函数是怎么修改它们之间的共享变量的，所以，这些函数是有状态的。解决办法就是Functional Programming 的编程范式
函数式编程有如下好处：
1.代码更简单了。
2.数据集，操作，返回值都放到了一起。
3.你在读代码的时候，没有了循环体，于是就可以少了些临时变量，以及变量倒来倒去逻辑。
4.你的代码变成了在描述你要干什么，而不是怎么去干。
避免使用程序状态和可变对象,是降低程序复杂度的有效方式之一,而这也正是函数式编程的精髓。 函数式编程强调执行的结果,而非执行的过程。
 我们先构建一系列简单却具有一定功能的小函数,然后再将这些函数进行组装以实现完整的逻辑和复杂的运算,这是函数式编程的基本思想。
 </description>
    </item>
    
    <item>
      <title>vim</title>
      <link>https://blog.v5u.win/post/system-vim/</link>
      <pubDate>Mon, 18 Apr 2016 17:26:21 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/system-vim/</guid>
      <description>Vim
自带教程 终端输入 vimtutor
两种模式状态 1. 命令模式 2. 编辑模式
命令模式下的操作  dd 删除一行;三行：3dd y复制 d()剪切 p(paste)粘贴 :wq 或 ZZ 或 保存退出 :q! 强制退出 / 搜索 命令模式下 /user 搜索 user 关键字 i 所有非hjkl的字符 进入编辑模式  编辑模式 文字编辑器</description>
    </item>
    
    <item>
      <title>Git 仓库</title>
      <link>https://blog.v5u.win/post/system-git%E4%BB%93%E5%BA%93/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/system-git%E4%BB%93%E5%BA%93/</guid>
      <description>git 仓库的创建流程：
命令行模式创建 参考  创建裸仓库 git init --bare gitserver.git，表明允许其副本push操作。   使用 git init --bare &amp;lt;repo&amp;gt; 可以创建一个裸仓库，当创建一个裸存储库时，Git假定裸存储库将作为几个远程用户的源存储库，因此它不会创建默认远程源。这意味着基本的git pull和git push操作将无法工作，因为Git假设没有工作空间，你不打算提交对裸存储库的任何更改。
从裸仓库 clone 下来的本地仓库可以进行正常的 push 操作， 但是从一般仓库 clone 下来的本地仓库却不行。 这也正是裸仓库存在的意义。 裸仓库一般情况下是作为远端的中心仓库而存在的。
 git 创建裸仓库并修改该仓库目录的组权限为可写。
$ ssh user@git.example.com $ cd /opt/git/my_project.git $ git init --bare --shared  gitea 工具创建 Gitea 是一个Go开发的开源Git管理工具。从Gogs项目中分裂出来，竟然是中国人无闻的项目（惊叹一下）。特点是：目标是打造一个最简单、最快速和最轻松的方式搭建自助 Git 服务。</description>
    </item>
    
  </channel>
</rss>