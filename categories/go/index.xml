<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Go on 为吾优</title>
    <link>https://blog.v5u.win/categories/go/</link>
    <description>Recent content in Go on 为吾优</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Mon, 28 Oct 2019 10:08:59 +0800</lastBuildDate>
    
	<atom:link href="https://blog.v5u.win/categories/go/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Go谚语</title>
      <link>https://blog.v5u.win/post/go%E8%B0%9A%E8%AF%AD/</link>
      <pubDate>Mon, 28 Oct 2019 10:08:59 +0800</pubDate>
      
      <guid>https://blog.v5u.win/post/go%E8%B0%9A%E8%AF%AD/</guid>
      <description>[TOC]
本文摘自 https://www.kancloud.cn/cserli/golang/524388
本文译自go-proverbs, 脱胎于 Rob Pike 振奋人心的演讲视频 talk at Gopherfest SV 2015 (bilibili).
不要通过共享内存进行通信, 通过通信共享内存 (Don&amp;rsquo;t communicate by sharing memory, share memory by communicating)
传统的线程模型（通常在编写 Java, C++ 和 Python 程序时使用）要求程序员使用共享内存在线程之间进行通信. 通常, 共享数据结构受锁保护, 线程将争夺这些锁访问数据, 在某些情况下, 通过使用 Python 的 Queue 等线程安全的数据结构可以使这变得更容易.
Go 的并发原语 (goroutines 和 channels) 为构造并发软件提供了一种优雅而独特的手段. (这些概念有一个有趣的历史, 要从 C.A.R.Hoare 的通信顺序进程说起.) Go 鼓励使用 channels 在 goroutines 之间传递对数据的引用, 而不是显式地使用锁来调解对共享数据的访问. 这种方法确保只有一个 goroutine 可以在给定的时间访问数据. 这个概念总结在 Effective Go 文档中 (任何 Go 程序员都必须阅读).
Go 官方博客中有一篇文章对该谚语解读, 可以参见原文.</description>
    </item>
    
    <item>
      <title>Go CGO</title>
      <link>https://blog.v5u.win/post/go-cgo/</link>
      <pubDate>Tue, 20 Aug 2019 18:06:35 +0800</pubDate>
      
      <guid>https://blog.v5u.win/post/go-cgo/</guid>
      <description>[TOC]
golang 中调用 c/c++ 代码有三种方式  直接嵌套在go文件中使用，最简单直观的 导入动态库 .so 或 dll 的形式，最安全但是很不爽也比较慢的 直接引用 c/c++ 文件的形式，层次分明，容易随时修改看结果的  需要的环境支持  Linux 具备 gcc 与 g++ 即可 Mac 参考 Linux Windows 需要安装 mingw，否则编译时会有这类错：cannot find -lmingwex  嵌套 package main // 嵌入式 调用 // #include &amp;lt;stdio.h&amp;gt; // #include &amp;lt;stdlib.h&amp;gt; /* void print(char *str) { printf(&amp;quot;%s\n&amp;quot;, str); } */ import &amp;quot;C&amp;quot;//这里可看作封装的伪包C, 这条语句要紧挨着上面的注释块，不可在它俩之间间隔空行！ import &amp;quot;unsafe&amp;quot; func main() { s := &amp;quot;Hello Cgo&amp;quot; cs := C.CString(s) C.</description>
    </item>
    
    <item>
      <title>Go Gofmt</title>
      <link>https://blog.v5u.win/post/go-gofmt/</link>
      <pubDate>Fri, 16 Aug 2019 17:57:28 +0800</pubDate>
      
      <guid>https://blog.v5u.win/post/go-gofmt/</guid>
      <description> [TOC]
为什么要用 gofmt 大多数人认为我们格式化Go代码gofmt 以使代码看起来更好或结束团队成员之间关于程序布局的争论。但是， 1是，如果一个算法定义围棋源代码是如何被格式化，然后编程，如goimports 或 gorename 或者 go fix，可以更容易地编辑源代码，而无需编写代码回来时引入伪格式更改。这有助于您长期维护代码。
 我认为源代码格式化工具非常简洁 提供。解析器/ ast /漂亮也是一件好事 打印机可用作mod。
但是，我不确定是否尝试强制执行格式化样式 拒绝配置格式化程序的能力（如FAQ提及） 是个好主意。至少go /打印机包可能是好的 即使命令行gofmt工具，也允许更灵活的配置 没有。 对于gofmt的输出，没有人或将永远不会满意， 但它实际上相当不错，更重要的是，人们适应 令人惊讶的是，这种风格起初看起来很陌生。特别 在格式化方面，风格实际上只是“你习惯的”。 由于Go是一种全新的语言，所以不应该这样 很难习惯不同的格式。
 我们希望人们能够准确地接受gofmt的输出 因为它结束了这种风格的辩论。怎么样 C有很多不同的支撑款式吗？太多。
就个人而言，我发现让gofmt格式化为我是一种解放， 因为这意味着我有更多可用的神经元 攻击有趣的编程问题。有 我不喜欢gofmt输出的东西，但我不喜欢 不再担心他们了。
但所有这些都错过了我认为最激动人心的事情 关于gofmt：事实上我们有一个可以拿起每个人的工具 Go树中的源文件，将其解析为内部表示， 然后将完全相同的字节放回原位。 （很大一部分 这是由于进入gofmt的工作量，以及 其余的是因为我们同意对gofmt进行标准化 一旦你拥有了这样一个工具，它变得非常容易 在中间插入机械处理，解析之间 和印刷。所以我们拥有一个程序的所有难点 操纵工具只是坐着等待使用。我已经开始了 以前为C编写类似的工具，从来没有得到过输出 完全匹配输入。同意接受“gofmt风格” 是在有限数量的代码中使它可行的部分。
我希望人们会按照自己的代码使用gofmt。 正如我所说，它不需要超过几个星期 习惯于新的编码风格，特别是如果你是一个品牌 新语言，每个人都有巨大的利益 相同的风格。
我们当然打算继续格式化所有代码 使用gofmt去树。像Go一样，这是一个实验。
Russ
 下面有邮件组的讨论过程 [return]   </description>
    </item>
    
    <item>
      <title>Go Bazel构建工具</title>
      <link>https://blog.v5u.win/post/go-bazel%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/</link>
      <pubDate>Fri, 16 Aug 2019 16:02:29 +0800</pubDate>
      
      <guid>https://blog.v5u.win/post/go-bazel%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/</guid>
      <description>[TOC]
为什么要了解Bazel 这段时间搞到了bilibili的一部分源码，那个事件你知道的，就不说了。怀着对大牛的向往，打算研究一下，之前听说主程做的这个架构很牛逼，就算是代码泄露也不会对服务器造成影响，而且模块化做的非常好，小弟们码好代码，主程一键做个合并打包发布就行。自动化做的很好。就想知道到底是怎么做的，于是我了解到了他——Bazel。
原文链接 https://filipnikolovski.com/managing-go-monorepo-with-bazel/
使用Bazel管理Go monorepo 在InPlayer中，我们有一个使用*微服务*架构风格构建的平台，它基本上将应用程序构建为许多不同服务的集合。在这篇文章中，我将讨论如何建构(structure)，构建(build)和部署(deploy)Go应用程序。
我们编写的每一段Go代码都驻留在一个Git存储库中 - 一个monorepo。由于每个库和服务都在一个项目中，因此它允许我们进行交叉更改，而无需使用某些外部包管理工具。基本上，代码不可能不同步，我们所做的每个更改都可以视为一个单元。
虽然好处很明显，但使用Go monorepo的挑战是如何有效地构建和测试每个包。答案 - Bazel。
Bazel是什么？ Bazel是一款速度极快的构建工具。它只重建必要的东西，它利用高级缓存机制和并行执行，使您的构建非常，非常快。除了这些功能外，它还可以管理您的代码依赖项，调用外部工具和插件，还可以从二进制可执行文件构建Docker镜像。它使用go build引擎盖，但它也可以支持许多不同的语言，而不仅仅是Go。您可以将它用于Java，C ++，Android，iOS和各种其他语言平台。您可以在三个主要操作系统上运行Bazel - Windows，macOS和Linux。
项目结构 在我们深入了解Bazel之前，首先让我们讨论一下我们的项目结构：
 platform |-- src | |-- foo | | |--cmd | | | `--bar | | | |--BUILD | | | `--main.go | | `--pkg | |-- utils | |-- vendor | |-- Gopkg.lock | |-- Gopkg.toml | |-- BUILD | `-- WORKSPACE |-- README.md `-- gitlab-ci.</description>
    </item>
    
    <item>
      <title>Go2</title>
      <link>https://blog.v5u.win/post/go-go2/</link>
      <pubDate>Tue, 13 Aug 2019 14:02:52 +0800</pubDate>
      
      <guid>https://blog.v5u.win/post/go-go2/</guid>
      <description>[TOC]
 中文版 English version  介绍 [这是我上周在Gophercon 2019上发表的博客文章。我们将在演讲结束后添加视频链接。]
我们都正在一起走向Go 2的路上，但是，我们都不知道这条路确切位置在哪里，有时甚至不知道这条路的方向。这篇文章讨论了我们如何实际找到并遵循Go2的道路。下面是这个过程的样子。
我们现在尝试使用Go，以便更好地理解它，学习哪些有效，哪些无效。然后我们尝试可能的变化，更好地理解它们，再次学习哪些有效，哪些无效。根据我们从这些实验中学到的东西，我们简化了。然后我们再次进行实验。然后我们再次简化。如此反复。
简化的四个R 在这个过程中，我们可以通过四种主要方式简化编写Go程序的整体体验：重塑（reshaping），重定义（redefining），删除（removing）和限制（restricting）。
通过重塑进行简化 我们简化的第一种方法是将存在的内容重新整形为一种新形式，最终让整体更简单。
我们编写的每个Go程序都是一个测试Go本身的实验。在Go的早期，我们很快就知道编写像这样的addToList函数这样的代码是很常见的：
func addToList(list []int, x int) []int { n := len(list) if n+1 &amp;lt; cap(list) { big := make([]int, n, (n+5)*2) copy(big, list) list = big } list = list[:n+1] list[n] = x return list }  我们为字节切片和字符串切片编写相同的代码，依此类推。因为Go太简单了以至于我们的程序写的太复杂了。
所以我们在程序中使用了许多addToList函数，并将它们重新整型为Go本身提供的一个函数。添加append使得Go语言变得更复杂，但总的来说，即使考虑到学习append成本，它也使得编写Go程序的整体体验变得更加简单。
这是另一个例子。对于Go 1，我们查看了Go发行版中的许多开发工具，并将它们重新编写为一个新命令。
5a 8g 5g 8l 5l cgo 6a gobuild 6cov gofix → go 6g goinstall 6l gomake 6nm gopack 8a govet  这个go命令现在如此重要，以至于很容易忘记我们没有它这么长时间以及这个go命令涉及多少额外的工作。</description>
    </item>
    
    <item>
      <title>Go Liteide IDE</title>
      <link>https://blog.v5u.win/post/go-liteide/</link>
      <pubDate>Fri, 02 Aug 2019 16:33:56 +0800</pubDate>
      
      <guid>https://blog.v5u.win/post/go-liteide/</guid>
      <description>[TOC]
liteide是专门为go编写的一个基于qt5的IDE，免费开源跨平台。 LiteIDE 是一个轻量级的开源跨平台 Go语言 IDE. 作者: 七叶 (visualfc)
支持 Windows，Linux，Mac。
下载地址：https://github.com/visualfc/liteide.git
或命令行安装：brew search liteide
配置环境变量  切换当前环境 &amp;gt; system—&amp;gt; darwin64-home, 点击旁边的小灰框(编辑当前环境) 在打开的文件中设置 go 环境： GOROOT, GOPATH,GOBIN, GOPROXY 注意查看下方的&amp;rdquo;事件记录&amp;rdquo; 输出日志，确认不在有报错  编译运行 BR : go build &amp;amp; run
R : 直接运行可执行文件
FR : go run file.go
B : go build
调试 用 LiteIDE 可以方便调试 Go 程序，它是用的 GDB 调试的，如果没有安装 GDB 的话，运行 “调试” 就会提示：
Mac没有内置gdb，所以需要使用brew安装，但是Mac又不信任 gdb ，所以还要生成信任证书给gdb用。
参考：shttps://windmt.com/2016/01/07/installing-gdb-on-macos/
2.4 设置编译选项及编译
编译-&amp;gt;编译配置，设置编译参数。在BUILDARGS添加-gcflags &amp;ldquo;-N -l&amp;rdquo;，目的是去掉编译优化，方便调试。</description>
    </item>
    
    <item>
      <title>Go Crontab</title>
      <link>https://blog.v5u.win/post/go-crontab/</link>
      <pubDate>Fri, 19 Jul 2019 16:51:27 +0800</pubDate>
      
      <guid>https://blog.v5u.win/post/go-crontab/</guid>
      <description>[TOC]
计划任务 from Godoc
包cron实现了cron规范解析器和作业运行器。
安装 要下载特定的标记版本，请运行:
go get github.com/robfig/cron/v3@v3.0.0 将其导入您的程序中:
import “github.com/robfig/cron/v3” 由于Go Modules的使用，它需要Go 1.11或更高版本。
用法 呼叫者可以在给定的时间表上注册要调用的Func。Cron将在他们自己的goroutines中运行它们。
c := cron.New() c.AddFunc(&amp;quot;30 * * * *&amp;quot;, func() { fmt.Println(&amp;quot;Every hour on the half hour&amp;quot;) }) c.AddFunc(&amp;quot;30 3-6,20-23 * * *&amp;quot;, func() { fmt.Println(&amp;quot;.. in the range 3-6am, 8-11pm&amp;quot;) }) c.AddFunc(&amp;quot;CRON_TZ=Asia/Tokyo 30 04 * * * *&amp;quot;, func() { fmt.Println(&amp;quot;Runs at 04:30 Tokyo time every day&amp;quot;) }) c.AddFunc(&amp;quot;@hourly&amp;quot;, func() { fmt.</description>
    </item>
    
    <item>
      <title>Go Crontab v3</title>
      <link>https://blog.v5u.win/post/go-crontab-v3/</link>
      <pubDate>Fri, 19 Jul 2019 16:51:27 +0800</pubDate>
      
      <guid>https://blog.v5u.win/post/go-crontab-v3/</guid>
      <description>[TOC]
关于cron更新 Cron V3已经发布！ 要下载特定的标记版本，请运行:
go get github.com/robfig/cron/v3@v3.0.0 将其导入您的程序中:
import &amp;quot;github.com/robfig/cron/v3&amp;quot; 由于Go Modules的使用，它需要Go 1.11或更高版本。
请参阅此处的文档：http://godoc.org/github.com/robfig/cron
本文档的其余部分介绍了v3的进展以及希望从早期版本升级的用户的重大更改列表。
升级到v3(2019年6月) cron v3是对库的重大升级，可以解决所有未解决的错误，功能请求和粗糙边缘。它基于master的合并，其中包含对多年来发现的问题的各种修复，以及v2分支，其中包含一些向后兼容的功能，例如删除cron作业的功能。此外，v3增加了对Go Modules的支持，清除了时区支持等粗糙边缘，并修复了许多错误。
新功能: 支持Go模块。调用者现在必须导入此库 github.com/robfig/cron/v3，而不是gopkg.in/&amp;hellip;
修正了错误:
0f01e6b 解析器: 修复Dow和Dom的组合(＃70) dbf3220 在向前滚动时钟时调整时间以处理不存在的午夜(＃157) eeecf15 spec_test.go：确保在0增量处返回错误(＃144) 70971dc cron.Entries(): 更新快照请求以包含回复通道(＃97) 1cba5e6 cron：修复: 删除作业导致下一个预定作业运行得太晚(＃206) 标准cron规范默认解析(第一个字段是“分钟”)，可以轻松选择进入秒字段(石英兼容)。虽然，请注意不支持年份字段(Quartz中的可选)。
通过符合https://github.com/go-logr/logr项目的接口进行可扩展的键/值记录。
新的Chain＆JobWrapper类型允许您安装“拦截器”以添加如下所示的横切行为:
从工作中恢复任何恐慌 如果先前的运行尚未完成，则延迟作业的执行 如果先前的运行尚未完成，则跳过作业的执行 记录每个作业的调用 作业完成时的通知 它向后与v1和v2不兼容。这些更新是必需的:
v1分支在cron规范的开头接受了一个可选的秒字段。这是非标准的，并导致了很多混乱。新的默认解析器符合Cron维基百科页面所描述的标准。
更新: 要保留旧行为，请使用自定义解析器构建您的Cron：
// Seconds field, required cron.New(cron.WithSeconds()) // Seconds field, optional cron.New( cron.WithParser( cron.SecondOptional | cron.Minute | cron.Hour | cron.Dom | cron.Month | cron.</description>
    </item>
    
    <item>
      <title>go社区拒绝了try提案</title>
      <link>https://blog.v5u.win/post/go-%E6%8B%92%E7%BB%9D%E4%BA%86try%E6%8F%90%E6%A1%88/</link>
      <pubDate>Wed, 17 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/go-%E6%8B%92%E7%BB%9D%E4%BA%86try%E6%8F%90%E6%A1%88/</guid>
      <description>提案：内置的Go错误检查功能， try 该提案已经结束。谢谢大家，感谢您的投入。
在评论之前，请阅读详细的设计文档，并查看截至6月6日的摘要，截至6月10日的摘要，*最重要的是关于保持专注的建议*。您的问题或建议可能已经得到解答或提出。谢谢。
我们提出了一个新的内置函数try，专门用于消除if通常与Go中的错误处理相关的样板语句。建议不要更改其他语言。我们提倡使用现有defer语句和标准库函数来帮助扩充或包装错误。这种最小化的方法可以解决大多数常见情况，同时为语言增加很少的复 该try内置很容易解释，直接实现的，垂直的其它语言结构，并完全向后兼容。如果我们希望将来这样做，它还为扩展机制留下了开辟的道路。
[以下文字已经过编辑，可以更准确地反映设计文档。]
的try内置函数采用一个单一表达式作为参数。表达式必须求值为n + 1个值（其中n可能为零），其中最后一个值必须是type error。如果（final）error参数为nil，则返回前n个值（如果有），否则返回带有该错误的封闭函数。例如，代码如
f，错误 ：= os。打开（文件名） if err！= nil { return ...，err //其他结果的零值，如果有的话 }  可以简化为
f ：= try（os。打开（文件名））  try只能在自身返回error结果的函数中使用，并且该结果必须是封闭函数的最后一个结果参数。
该提案将去年GopherCon中提出的原始设计草案简化为其本质。如果需要错误扩充或包装，有两种方法：坚持使用久经考验的if语句，或者，使用语句“声明”错误处理程序defer：
defer func（）{ if err！= nil {	//可能没有发生错误 - 检查 错误= ...	// wrap / augment error } }（）  这里 err是封闭函数的错误结果的名称。在实践中，合适的辅助函数将减少错误处理程序对单行程序的声明。例如
延迟 fmt。HandleErrorf（＆err，“ copy ％s ％s ”，src，dst）  （fmt.HandleErrorf装饰*err）读得很好，可以在不需要新语言功能的情况下实现。
这种方法的主要缺点是需要命名错误结果参数，可能导致不太漂亮的API。最终这是一个风格问题，我们相信我们会适应期待新风格，就像我们适应没有分号一样。
总而言之，一开始try可能看起来很不寻常，但它只是针对一个特定任务量身定制的语法糖，错误处理用较少的样板，并且足够好地处理该任务。因此，它非常符合Go的哲学。try不是为解决*所有*错误处理情况而设计的; 它旨在很好地处理*最常见的*情况，以保持设计简单明了。
积分 该提议受到我们迄今收到的反馈的强烈影响。具体来说，它借鉴了以下方面的想法
 错误处理的关键部分， 问题＃31442 和，相关的，问题＃32219。  VojtechVitek** 评论道 我觉得try()已经表达了反对该提案的所有重要反馈意见。但让我试着总结一下：</description>
    </item>
    
    <item>
      <title>Goland 使用</title>
      <link>https://blog.v5u.win/post/go-goland/</link>
      <pubDate>Fri, 12 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/go-goland/</guid>
      <description>做 Go 开发，一般使用的IDE是 Goland
安装略，自己解决。下面说安装后的事情。
 配置文件，配置开发环境  goland 会自动读取 GOROOT 和 GOPATH，所以不用自己填写。我们要做的就是配置配置文件
创建go build配置文件：Templates&amp;ndash;&amp;gt; Go Build Run kind 选Directory Directory 选你的main包所在文件夹 Output directory设置与go build -o 不相容，所以不用设置，我们使用-o参数来控制可执行文件的路径以及名字 Working directory保持默认就好 Go tool arguments 就是go build 的参数
 debug  goland 的 debug 功能可以看到 整个函数链条，和当下参数的值，以及 ·s 文件(汇编文件)的内部调用
单文件调试：直接点击run旁边的debug按钮，左下方有细分子项：跳过执行（步过），单步调试（步入），步出
整项目调试：</description>
    </item>
    
    <item>
      <title>Go orm 对比选择</title>
      <link>https://blog.v5u.win/post/go-orm/</link>
      <pubDate>Wed, 10 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/go-orm/</guid>
      <description>golang 中 orm最主流的两个包，xorm和gorm。所以主要在他们之间做抉择。
   name xorm gorm     github-stars 5,053 14,262   github-fork 650 1,606         不管是从stars数还是fork gorm都是大比例拉开。gorm是老牌的项目，xorm是这两年崛起来的。
最后我选择了xormplus 因为路径依赖，学习golang的时候的示例用的是xorm。:sweat_smile:
xorm 自动生成代码
xorm help reverse
格式：xorm reverse dirver dbname 导出模板
xorm reverse mysql &amp;quot;username:pwd@tcp(127.0.0.1:3306)/dbname?charset=utf8&amp;quot; $GOPATH/src/github.com/go-xorm/cmd/xorm/templates/goxorm  </description>
    </item>
    
    <item>
      <title>Go Toml</title>
      <link>https://blog.v5u.win/post/go-toml/</link>
      <pubDate>Wed, 26 Jun 2019 15:33:44 +0800</pubDate>
      
      <guid>https://blog.v5u.win/post/go-toml/</guid>
      <description>[TOC]
常用的配置文件有：ini, ymal, json, toml
说一下为什么要选择 toml。toml 格式是最新公布的配置文件格式，由GitHub创始人 Tom Preston-Werner 发明。TOML 的目标是成为一个极简的配置文件格式。TOML 被设计成可以无歧义地被映射为哈希表，从而被多种语言解析。
TOML的优势  可以添加注释 没有缩进要求 表达简洁，丰富。 大小写敏感  写法 config.toml [app] #app名称 name = &amp;quot;project-web&amp;quot; url = &amp;quot;http://localhost&amp;quot; port = &amp;quot;:8080&amp;quot; debug = false [database] dirver = &amp;quot;mysql&amp;quot; [mysql] dbname = &amp;quot;@tcp(127.0.0.1:3306)/superstar?charset=utf8&amp;quot; username = &amp;quot;root&amp;quot; password = &amp;quot;333&amp;quot; [website] static_uri = &amp;quot;/static&amp;quot; site_title = &amp;quot;后台管理&amp;quot; copy_right = &amp;quot;&amp;lt;small&amp;gt;&amp;amp;copy;2019&amp;lt;/small&amp;gt;&amp;quot; [image] image_lib = &amp;quot;Imagick&amp;quot; # GD || Imagick image_path = &amp;quot;.</description>
    </item>
    
    <item>
      <title>Go Iris Redis</title>
      <link>https://blog.v5u.win/post/go-iris-redis/</link>
      <pubDate>Tue, 11 Jun 2019 10:15:20 +0800</pubDate>
      
      <guid>https://blog.v5u.win/post/go-iris-redis/</guid>
      <description>[TOC]
iris 中使用 Redis iris 内置对 Redis 的支持，但是她和 session 结合的比较紧密，比如每一个方法传参都大部分都有 sid，在当前文件 database.go 找了半天没找到在哪里定义了 sid，func (db *Database) Get(sid string, key string) (value interface{})
只能推断是 sessionId，果然在 Session struct 中发现了 sid。
Session struct { sid string isNew bool flashes map[string]*flashMessage mu sync.RWMutex // for flashes. Lifetime LifeTime provider *provider }  所以可以下结论，iris中必须使用内置的 Redis 是只对 session 的配合支持，如果需要单独操作 Redis 数据库，则需要使用其他的第三方库来操作，比如：redigo 和 go-redis/redis</description>
    </item>
    
    <item>
      <title>Go BeeGoVSgin</title>
      <link>https://blog.v5u.win/post/go-beegovsgin/</link>
      <pubDate>Mon, 03 Jun 2019 13:38:52 +0800</pubDate>
      
      <guid>https://blog.v5u.win/post/go-beegovsgin/</guid>
      <description>[TOC]
beego和gin是现在用的最多的两个go框架，所以这里选择比较这两个。
框架选择原则：永远站在大多数人这边。招人，公司，成本，问题解决时间成本都要考虑。
   特性 BeeGo Bin     MVC 不支持 不完全支持   路由 RESTful Controller 正则支持的非常完整 RESTful router.Get() 组路由   Session 支持,也支持session持久化 不支持，使用三方包 github.com/astaxie/session    性能 从问正确的问题开始。。。
 *高性能*本身是不是我们的目标？
 我们的目标是什么？
 创造价值，获得竞争优势
  机器成本 vs 开发人员成本
影响访问速度的因素有很多 例如系统中间层和数据层的耦合情况，数据层本身的能力，服务器所在机房的网络拓扑结构，负载均衡的配置情况，等等。
数据层速度，表设计不合理，网络io,图片的加载速度很慢
正确做性能优化的姿势  确定性能目标，并保证这个目标是出于实际需要 建立性能环境，staging环境，并与线上环境隔离 性能环境和staging环境应该与线上环境类似架构 压测，并获得性能瓶颈的真正证据 最后，持续改进，永远只对瓶颈改进。  只有改的是瓶颈的点才有用
适用场景 Beego在业务方面比gin支持的更多  在业务更复杂的项目中，使用beego 在需要快速开发的项目中，适用beego 在1.0项目中，适用beego。  Gin在性能方面比Beego更好  当某个接口性能遭到较大的挑战的时候，考虑使用Gin重写接口 如果项目的规模不大，业务相对简单，使用Gin。  你会发现大部分时候这两个框架差不多。</description>
    </item>
    
    <item>
      <title>Go 单例</title>
      <link>https://blog.v5u.win/post/go-%E5%8D%95%E4%BE%8B/</link>
      <pubDate>Mon, 27 May 2019 00:00:00 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/go-%E5%8D%95%E4%BE%8B/</guid>
      <description>为什么使用单例？
由于Go的多协程机制，当只是单核的时候，变量还不会出现问题，但是当设置成多核之后，就会涉及到变量的作用域问题，只用普通方式常见的变量在其他线程上会得到错误的方法
一、 sync.Once用法
在Go中有一个简洁的方法就是使用sync.Once，它可以在多协程中起到控制作用。实现起来也非常简单。
var ( once sync.Once instance *SingleTon ) func GetInstance(str string) *SingleTon { once.Do(func() { instance = &amp;amp;SingleTon{Attr: str} }) return instance }  二、使用加锁机制 在Go语言中有个基础对象sync.Mutex，可以实现协程之间的同步逻辑。
var mu sync.Mutex func GetInstance() *SingleTon { mu.Lock() defer mu.Unock() if Instance == nil { instance = &amp;amp;SingleTon{} } return instance }  三、简单粗暴模式. 这种方式实现起来特别简单，直接判断一个实力是不是为nil， 如果是，则新生成；否则返回已有的。但它和多数语言一样，只适合用在单线程。
type SingleTon struct { } var instance *SingleTon func GetInstance() *SingleTon { if Instance == nil { instance = &amp;amp;SingleTon{} } return instance }  测试代码如下，从运行结果来看，都是一致的。</description>
    </item>
    
    <item>
      <title>Go DI LoC研究</title>
      <link>https://blog.v5u.win/post/go-di-loc/</link>
      <pubDate>Fri, 24 May 2019 00:00:00 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/go-di-loc/</guid>
      <description>依赖注入，控制反转
目的：实现模块与项目的解耦
实现流程
首先模块有指针，其次DI拿到指针，再次DI将指针赋给调用者
共调研了三个框架：iris内置的di&amp;amp;mvc，uber-dig，google/wire
最终决定使用 wire
google DI 框架 wire 它通过使用代码生成构建容器来避免运行时反射。
用法：
// file main.go package main import &amp;quot;bytes&amp;quot; type Logger struct{} func (logger *Logger) Log(message string) { println(message) } type HttpClient struct { logger *Logger } func (client *HttpClient) Get(url string) string { client.logger.Log(&amp;quot;Getting &amp;quot; + url) return &amp;quot;my response from &amp;quot; + url } func NewHttpClient(logger *Logger) *HttpClient { return &amp;amp;HttpClient{logger} } type ConcatService struct { logger *Logger client *HttpClient } func NewConcatService(logger *Logger, client *HttpClient) *ConcatService { return &amp;amp;ConcatService{logger, client} } func (service *ConcatService) GetAll(urls .</description>
    </item>
    
    <item>
      <title>imagick</title>
      <link>https://blog.v5u.win/post/go-imagick/</link>
      <pubDate>Fri, 17 May 2019 00:00:00 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/go-imagick/</guid>
      <description>Go语言imagick 使用总结 imagick 是一个开源的 c语言图片处理库，所以需要本地安装，并且配置 CGO
Mac 安装imagic
brew install imagemagick
有的可能需要安装 brew install pkg-config
CGO配置
export CGO_CFLAGS_ALLOW=&#39;-Xpreprocessor&#39; #cgo	 Initialize() 和 Terminate 根据ImageMagick C API，Initialize()应该只调用一次来设置使用ImageMagick的资源。这通常在您main()或init()整个应用程序或库中完成。应用程序可以推迟调用以Terminate()拆除ImageMagick资源。
多次调用特殊方法，导致常见的问题，这是一个错误对于Initialize，和Terminate来说，如死机或丢失代理。除了在程序中对ImageMagick的绝对需求外，不要使用Terminate。
内存管理 由于这是一个CGO绑定，并且Go GC不管理由C API分配的内存，因此必须使用Terminate（）和Destroy（）方法。
通过New*构造函数（MagickWand，DrawingWand，PixelIterator，PixelWand，&amp;hellip;）创建的类型由Go GC通过使用终结器进行管理。
如果使用struct literals，则应手动释放资源：
package main import &amp;quot;github.com/gographics/imagick/imagick&amp;quot; func main() { imagick.Initialize() // Schedule cleanup defer imagick.Terminate() var err error mw := imagick.NewMagickWand() defer mw.Destroy() err = mw.ReadImage(&amp;quot;header.png&amp;quot;) if err != nil { panic(err) } // Get original logo size width := mw.</description>
    </item>
    
    <item>
      <title>Go 自定义包模板引用 moudle</title>
      <link>https://blog.v5u.win/post/go-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8C%85%E6%A8%A1%E6%9D%BF%E5%BC%95%E7%94%A8/</link>
      <pubDate>Mon, 13 May 2019 13:17:53 +0800</pubDate>
      
      <guid>https://blog.v5u.win/post/go-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8C%85%E6%A8%A1%E6%9D%BF%E5%BC%95%E7%94%A8/</guid>
      <description>源起：最近在调研Go，需要使用Go搭建一套通用式的模板框架，用以当新开其他项目的时候直接基于模板框架开发。
固定化引入自定义包的路径，解决——开启新的分支需要更改引入路径
方案一：go mod 支持 go build -mod=vendor ，问题是 vendor 里的文件都是 gopath/pkg/mod 的拷贝，是不能基于自己公司的需求做修改的。
方案二：使用 相对路径，相对路径 相对的是 gopath 的路径，使用此方案就需要 将项目必须放在 gopath 目录下，不能使用 go mod。
目前生产环境用 go mod 还不太现实，因为多人写作不能下载就用，还需要安装第三方包， 我还是先推荐定义 GOPATH 和 vendor 用法。</description>
    </item>
    
    <item>
      <title>Go Nginx反向代理</title>
      <link>https://blog.v5u.win/post/go-nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/</link>
      <pubDate>Fri, 10 May 2019 16:08:55 +0800</pubDate>
      
      <guid>https://blog.v5u.win/post/go-nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/</guid>
      <description>当我们启动一个go 程序的时候，通常监听的是本地端口如 IP:port 。但是实际的线上环境，解析路径是：通过 DNS 解析 ——&amp;gt; nginx vhost ——&amp;gt; IP:port 这个。单纯的使用 go 是不能处理 域名解析工作的。 所以通常是NGINX 和 Go 搭配着使用。
nginx 可以帮我做很多工作，例如访问日志，cc 攻击，静态服务等，nginx 已经做的很成熟了。 Go 只要专注于业务逻辑和功能就好。 NGINX作为反向代理的配置如下：
#列出所有服务器地址，nginx 自动均衡分发请求到各个服务器。 upstream frontends { ip_hash; server 192.168.199.1:8088; server 192.168.199.2:8089; } server { listen 80; server_name nav.v5u.win ; #静态资源交由nginx管理 location /static { root /var/www/mydomain/web; expires 1d; add_header Cache-Control public; access_log off; } # 反向代理设置 location ~ / { proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header Host $http_host; proxy_redirect off; proxy_pass http://localhost:7070; } }  </description>
    </item>
    
    <item>
      <title>Go Quick Start</title>
      <link>https://blog.v5u.win/post/go-quick-start/</link>
      <pubDate>Wed, 08 May 2019 15:39:15 +0800</pubDate>
      
      <guid>https://blog.v5u.win/post/go-quick-start/</guid>
      <description>有经验开发者，快速入门 Go 语言 发明Go语言是出于更好地完成工作的需要。Go不是计算机科学的最新发展潮流，但它却提供了解决现实问题的最新最快的方法。 Go拥有命令式语言的静态类型，编译很快，执行也很快，同时加入了对于目前多核CPU的并发计算支持，也有相应的特性来实现大规模编程。 Go语言有非常棒的标准库，还有一个充满热情的社区。
有编程经验的小伙伴，朗诵以下代码块，完成Go语言快速入门。
// 单行注释 /* 多行 注释 */ // 导入包的子句在每个源文件的开头。 // Main比较特殊，它用来声明可执行文件，而不是一个库。 package main // Import语句声明了当前文件引用的包。 import ( &amp;quot;fmt&amp;quot; // Go语言标准库中的包 &amp;quot;io/ioutil&amp;quot; // 包含一些输入输出函数 m &amp;quot;math&amp;quot; // 数学标准库，在此文件中别名为m &amp;quot;net/http&amp;quot; // 一个web服务器包 &amp;quot;os&amp;quot; // 系统底层函数，如文件读写 &amp;quot;strconv&amp;quot; // 字符串转换 ) // 函数声明：Main是程序执行的入口。 // 不管你喜欢还是不喜欢，反正Go就用了花括号来包住函数体。 func main() { // 往标准输出打印一行。 // 用包名fmt限制打印函数。 fmt.Println(&amp;quot;天坑欢迎你!&amp;quot;) // 调用当前包的另一个函数。 beyondHello() } // 函数可以在括号里加参数。 // 如果没有参数的话，也需要一个空括号。 func beyondHello() { var x int // 变量声明，变量必须在使用之前声明。 x = 3 // 变量赋值。 // 可以用:=来偷懒，它自动把变量类型、声明和赋值都搞定了。 y := 4 sum, prod := learnMultiple(x, y) // 返回多个变量的函数 fmt.</description>
    </item>
    
    <item>
      <title>Go web技术栈</title>
      <link>https://blog.v5u.win/post/go-web%E6%8A%80%E6%9C%AF%E6%A0%88/</link>
      <pubDate>Thu, 25 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/go-web%E6%8A%80%E6%9C%AF%E6%A0%88/</guid>
      <description> iris 框架
 go-beanstalkd 消息队列 gRPC
 go module 包管理
 gin+gorm / singo
  </description>
    </item>
    
    <item>
      <title>Go 交叉编译</title>
      <link>https://blog.v5u.win/post/go-%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91/</link>
      <pubDate>Thu, 18 Apr 2019 17:22:29 +0800</pubDate>
      
      <guid>https://blog.v5u.win/post/go-%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91/</guid>
      <description>查看操作系统平台和内核版本：uname -a
Mac 下编译 Linux 和 Windows 64位可执行程序
CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build main.go CGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build main.go  Linux 下编译 Mac 和 Windows 64位可执行程序
CGO_ENABLED=0 GOOS=darwin GOARCH=amd64 go build main.go CGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build main.go  Windows 下编译 Mac 和 Linux 64位可执行程序
SET CGO_ENABLED=0 SET GOOS=darwin SET GOARCH=amd64 go build main.go SET CGO_ENABLED=0 SET GOOS=linux SET GOARCH=amd64 go build main.go  GOOS：目标平台的操作系统（darwin、freebsd、linux、windows） GOARCH：目标平台的体系架构（386、amd64、arm） 交叉编译不支持 CGO 所以要禁用它,不要使用c代码库</description>
    </item>
    
    <item>
      <title>Go-Authorization</title>
      <link>https://blog.v5u.win/post/go-authorization/</link>
      <pubDate>Mon, 15 Apr 2019 14:52:48 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/go-authorization/</guid>
      <description>接口认证 一般接口开发中有以下常用的几种安全机制：
 用户认证 数字签名 接口加密  用户认证 一般的接口测试工具都会提供一个User Auth/Authorization的选项
 基本认证（Basic Auth） 摘要认证（Digest Auth） OAuth 2.0（最常见，现在的网站接口多数提供此用户认证方式）授权认证方式  接口需要认证：auth=(&amp;ldquo;username&amp;rdquo;,&amp;ldquo;password&amp;rdquo;)
数字签名 在使用 HTTP/SOAP 协议传输数据的时候，签名作为其中一个参数，可以起到关键作用：通过客户的密钥，服务端的密钥匹配；当服务器接收到请求后，同样需要对“signpassword”进行 MD5 加密，然后，比对与调用者传来的 sign 加密串是否一致，从而来鉴别调用者是否有权限使用该接口。
http://127.0.0.1:8000/sign/?a=1&amp;amp;b=2&amp;amp;sign=6648e929329e53e7a91c50ae685a88b5
接口加密 通常接口会使用更复杂一点的方式来进行加密的操作，常见的是AES的使用
AES加密里面有两个关键，一个是key（必须为16,24,32位），一个是VI（必须为16位） 解密：解密者必须要同时知道key和VI才可以解密
参考</description>
    </item>
    
    <item>
      <title>Go gRPC研究总结</title>
      <link>https://blog.v5u.win/post/go-grpc%E7%A0%94%E7%A9%B6%E6%80%BB%E7%BB%93/</link>
      <pubDate>Thu, 11 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/go-grpc%E7%A0%94%E7%A9%B6%E6%80%BB%E7%BB%93/</guid>
      <description>什么是RPC RPC（Remote Procedure Call）—远程过程调用，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。RPC协议假定某些传输协议的存在，如TCP或UDP，为通信程序之间携带信息数据。在OSI网络通信模型中，RPC跨越了传输层和应用层。RPC使得开发包括网络分布式多程序在内的应用程序更加容易。——百度百科
支持环境配置(Mac)
安装protobuf 这是 Google 开源的一套成熟的结构数据序列化机制Protocol Buffers 3 简明教程
brew info protobuf brew install protobuf  检验protobuf安装结果
protoc --version libprotoc 3.5.1  安装第三方包
go mod download github.com/golang/protobuf/proto go mod download github.com/golang/protobuf/protoc-gen-go go mod download google.golang.org/grpc go install github.com/golang/protobuf/protoc-gen-go //编译 protoc-gen-go 可执行文件  创建 protobuf 文件
vi add.proto add some date  生成 gRPC 代码
protoc -I ./protos ./protos/helloworld.proto --go_out=plugins=grpc:helloworld 或 protoc -I . add.proto --go_out=plugins=grpc:.  这生成了 helloworld.</description>
    </item>
    
    <item>
      <title>Go modules</title>
      <link>https://blog.v5u.win/post/go-modules/</link>
      <pubDate>Wed, 03 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/go-modules/</guid>
      <description>go modules [TOC]
go 1.13 的环境配置 删除.zshrc 中的大部分配置，只配置goroot其余配置用下列命令：
go env -w GOSUMDB=&amp;quot;sum.golang.google.cn&amp;quot; # 更换为国内的校验源，默认sum.golang.org go env -w GOPROXY=&amp;quot;https://goproxy.io,direct&amp;quot; # 解决代理 go env -w GO111MODULE=&amp;quot;on&amp;quot; go env -w GOPRIVATE=*.gitlab.com,*.gitee.com # 代理跳过私有库设置  环境配置  正确配置 GOROOT
 export GOPROXY=&amp;quot;https://goproxy.cn,direct&amp;quot; # 七牛提供的公共代理，解决golang/x/tools 下载失败
  初始化 同时 确定了项目的绝对目录路径 go mod init v5u.win/projectapi 生成 go.mod 导入包：import &amp;quot;v5u.win/projectapi/src/app/service&amp;quot;
添加依赖 go mod tidy
生成 go.sum 自动添加依赖关系到 go.mod go run main.go
下载依赖包 go mod download github.</description>
    </item>
    
    <item>
      <title>Go-API 项目模板文档</title>
      <link>https://blog.v5u.win/post/go-api-%E9%A1%B9%E7%9B%AE%E6%A8%A1%E6%9D%BF%E6%96%87%E6%A1%A3/</link>
      <pubDate>Wed, 03 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/go-api-%E9%A1%B9%E7%9B%AE%E6%A8%A1%E6%9D%BF%E6%96%87%E6%A1%A3/</guid>
      <description>项目目录结构规范 PROJECT_NAME ├── README.md //介绍软件及文档入口 ├── bin //编译好的二进制文件,执行./build.sh自动生成，该目录也用于程序打包 ├── build.sh //自动编译的脚本 ├── doc //该项目的文档 ├── pack //打包后的程序放在此处 ├── pack.sh //自动打包的脚本，生成类似xxxx.20170713_14:45:35.tar.gz的文件，放在pack文件下 └── src //该项目的源代码 ├── main //项目主函数 ├── test //测试 ├── app //项目代码 ├── public //公共文件/静态文件 └── vendor //存放go的库 ├── github.com/xxx //第三方库 └── xxx.com/abc //公司内部的公共库  项目的目录结构尽量做到简明、层次清楚。
./app ├── bootstrap	//入口引导文件 ├── cache ├── config	//项目配置 ├── controller	//request请求处理中心 ——&amp;gt; controller ——&amp;gt; Response / view ├── library	//项目工具库 ├── log	//日志 —— 考虑发布目录 ├── middleware	//中间件 ├── model	//data model.</description>
    </item>
    
    <item>
      <title>Go-iris-template</title>
      <link>https://blog.v5u.win/post/go-iris-template/</link>
      <pubDate>Fri, 08 Mar 2019 17:25:10 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/go-iris-template/</guid>
      <description>Iris 支持五个开箱即用的模板引擎，所有这五个模板引擎都具有通用API的共同特征，如布局，模板功能，特定于派对的布局，部分渲染等。
 标准的html,它的模板解析器就是 golang.org/pkg/html/template/
Django,它的模板解析器就是 github.com/flosch/pongo2
Pug(Jade),它的模板解析器就是 github.com/Joker/jade
Handlebars, 它的模板解析器 github.com/aymerick/raymond
Amber, 它的模板解析器 github.com/eknkc/amber
 </description>
    </item>
    
    <item>
      <title>Go Iris 路由</title>
      <link>https://blog.v5u.win/post/go-iris-%E8%B7%AF%E7%94%B1/</link>
      <pubDate>Fri, 08 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/go-iris-%E8%B7%AF%E7%94%B1/</guid>
      <description> 路由配置规则 直接通过 function 绑定 controller，function name 映射到 路由的地址
function named rule：
func(*Controller) GetLoginBy(id int64) 绑定的controller HTTP-method+routePath map to - GET:/user/login/{param:long}  通过控制器方法的输入参数访问动态路径参数，不需要绑定。当您使用Iris的默认语法来解析来自控制器的处理程序时，您需要使用By字来为方法添加后缀，大写是一个新的子路径。例： 如这种形式 mvc.New(app.Party(&amp;ldquo;/user&amp;rdquo;)).Handle(new(user.Controller)) 则:
 func(*Controller) Get() - GET:/user func(*Controller) Post() - POST:/user func(*Controller) GetLogin() - GET:/user/login func(*Controller) PostLogin() - POST:/user/login func(*Controller) GetProfileFollowers() - GET:/user/profile/followers func(*Controller) PostProfileFollowers() - POST:/user/profile/followers func(*Controller) GetBy(id int64) - GET:/user/{param:long} func(*Controller) PostBy(id int64) - POST:/user/{param:long}  </description>
    </item>
    
    <item>
      <title>Go Error 错误处理</title>
      <link>https://blog.v5u.win/post/go-error-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/</link>
      <pubDate>Wed, 06 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/go-error-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/</guid>
      <description>常用的有五种方式
第一种策略 首先，也是最常用的方式是传播错误。这意味着函数中某个子程序的失败，会变成该函数的失败。我们使用该函数前缀添加额外的上下文信息到原始错误信息。当错误最终由main函数处理时，错误信息应提供清晰的从原因到后果的因果链，就像美国宇航局事故调查时做的那样：
 genesis: crashed: no parachute: G-switch failed: bad relay orientation
 编写错误信息时，我们要确保错误信息对问题细节的描述是详尽的。尤其是要注意错误信息表达的一致性，即相同的函数或同包内的同一组函数返回的错误在构成和处理方式上是相似的。
第二种策略 第二种策略。如果错误的发生是偶然性的，或由不可预知的问题导致的。一个明智的选择是重新尝试失败的操作。在重试时，我们需要限制重试的时间间隔或重试的次数，防止无限制的重试。
第三种策略 如果错误发生后，程序无法继续运行，我们就可以采用第三种策略：输出错误信息并结束程序。需要注意的是，这种策略只应在main中执行。对库函数而言，应仅向上传播错误，除非该错误意味着程序内部包含不一致性，即遇到了bug，才能在库函数中结束程序。
调用log.Fatalf可以更简洁的代码达到与上文相同的效果。log中的所有函数，都默认会在错误信息之前输出时间信息。
if err := WaitForServer(url); err != nil { log.Fatalf(&amp;quot;Site is down: %v\n&amp;quot;, err) } // 我们可以设置log的前缀信息屏蔽时间信息，一般而言，前缀信息会被设置成命令名。 log.SetPrefix(&amp;quot;wait: &amp;quot;) log.SetFlags(0)  第四种策略 第四种策略：有时，我们只需要输出错误信息就足够了，不需要中断程序的运行。
我们可以通过log包提供函数
if err := Ping(); err != nil { log.Printf(&amp;quot;ping failed: %v; networking disabled&amp;quot;,err) } //log包中的所有函数会为没有换行符的字符串增加换行符。  或者标准错误流输出错误信息。
if err := Ping(); err != nil { fmt.Fprintf(os.Stderr, &amp;quot;ping failed: %v; networking disabled\n&amp;quot;, err) }  第五种策略 第五种，也是最后一种策略：我们可以直接忽略掉错误。</description>
    </item>
    
    <item>
      <title>Go HTML template</title>
      <link>https://blog.v5u.win/post/go-html-template/</link>
      <pubDate>Tue, 05 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/go-html-template/</guid>
      <description>文档 go doc text/template $ go doc html/template  应用 func main() { // 定义模板显示格式 const templ = `&amp;lt;p&amp;gt;A: {{.A}}&amp;lt;/p&amp;gt;&amp;lt;p&amp;gt;B: {{.B}}&amp;lt;/p&amp;gt;` // 模板配置函数 t := template.Must(template.New(&amp;quot;escape&amp;quot;).Parse(templ)) var data struct { A string // untrusted plain text B template.HTML // trusted HTML } // A是一个普通字符串，B是一个信任的template.HTML字符串类型。 data.A = &amp;quot;&amp;lt;b&amp;gt;Hello!&amp;lt;/b&amp;gt;&amp;quot; data.B = &amp;quot;&amp;lt;b&amp;gt;Hello!&amp;lt;/b&amp;gt;&amp;quot; // 使用定义好的 模板 输出到 控制台 if err := t.Execute(os.Stdout, data); err != nil { log.Fatal(err) } } /* autoescape.html 结果 A:&amp;lt;b&amp;gt;Hello!</description>
    </item>
    
    <item>
      <title>Go-语言要点</title>
      <link>https://blog.v5u.win/post/go-%E8%AF%AD%E8%A8%80%E8%A6%81%E7%82%B9/</link>
      <pubDate>Wed, 27 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/go-%E8%AF%AD%E8%A8%80%E8%A6%81%E7%82%B9/</guid>
      <description>[TOC]
要点 本章对Go语言做了一些介绍，Go语言很多方面在有限的篇幅中无法覆盖到。本节会把没有讲到的内容也做一些简单的介绍，这样读者在读到完整的内容之前，可以有个简单的印象。
控制流 在本章我们只介绍了if控制和for，但是没有提到switch多路选择。这里是一个简单的switch的例子：
switch coinflip() { case &amp;quot;heads&amp;quot;: heads++ case &amp;quot;tails&amp;quot;: tails++ default: fmt.Println(&amp;quot;landed on edge!&amp;quot;) }  在翻转硬币的时候，例子里的coinflip函数返回几种不同的结果，每一个case都会对应一个返回结果，这里需要注意，Go语言并不需要显式地在每一个case后写break，语言默认执行完case后的逻辑语句会自动退出。当然了，如果你想要相邻的几个case都执行同一逻辑的话，需要自己显式地写上一个fallthrough语句来覆盖这种默认行为。不过fallthrough语句在一般的程序中很少用到。
Go语言里的switch还可以不带操作对象（译注：switch不带操作对象时默认用true值代替，然后将每个case的表达式和true值进行比较）；可以直接罗列多种条件，像其它语言里面的多个if else一样，下面是一个例子：
func Signum(x int) int { switch { case x &amp;gt; 0: return +1 default: return 0 case x &amp;lt; 0: return -1 } }  这种形式叫做无tag switch(tagless switch)；这和switch true是等价的。
像for和if控制语句一样，switch也可以紧跟一个简短的变量声明，一个自增表达式、赋值语句，或者一个函数调用(译注：比其它语言丰富)。
break和continue语句会改变控制流。和其它语言中的break和continue一样，break会中断当前的循环，并开始执行循环之后的内容，而continue会跳过当前循环，并开始执行下一次循环。这两个语句除了可以控制for循环，还可以用来控制switch和select语句(之后会讲到)，在1.3节中我们看到，continue会跳过内层的循环，如果我们想跳过的是更外层的循环的话，我们可以在相应的位置加上label，这样break和continue就可以根据我们的想法来continue和break任意循环。这看起来甚至有点像goto语句的作用了。当然，一般程序员也不会用到这种操作。这两种行为更多地被用到机器生成的代码中。
命名类型 类型声明使得我们可以很方便地给一个特殊类型一个名字。因为struct类型声明通常非常地长，所以我们总要给这种struct取一个名字。本章中就有这样一个例子，二维点类型：
type Point struct { X, Y int } var p Point  类型声明和命名类型会在第二章中介绍。</description>
    </item>
    
    <item>
      <title>Go 语言简介</title>
      <link>https://blog.v5u.win/post/go-%E8%AF%AD%E8%A8%80%E7%AE%80%E4%BB%8B/</link>
      <pubDate>Thu, 21 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/go-%E8%AF%AD%E8%A8%80%E7%AE%80%E4%BB%8B/</guid>
      <description>[TOC]
C/C++ 与 Go语言的“价值观”对照 之前看过 白明老师 在GopherChina2017的一篇演讲文章《Go coding in go way》，里面提到C/C++/Go三门语言价值观，感觉很有意思，分享给大家感受一下：
C的价值观摘录
 相信程序员：提供指针和指针运算，让C程序员天马行空的发挥 自己动手，丰衣足食：提供一个很小的标准库，其余的让程序员自造 保持语言的短小和简单 性能优先  C++价值观摘录
 支持多范式，不强迫程序员使用某个特定的范式 不求完美，但求实用（并且立即可用）  Go价值观
 Overall Simplicity 全面的简单 Orthogonal Composition 正交组合 Preference in Concurrency 偏好并发  用一句话概括Go的价值观： Go is about orthogonal composition of simple concepts with preference in concurrency(Go是在偏好并发的环境下的简单概念/事物的正交组合).
Go 的底层语言是什么 借用大神的话来说
 编译器就是输入源代码输出其他语言源代码的程序
 所以这个程序用什么语言实现无所谓
然而，一开始没有go，所以用c实现了一版go编译器，后来go语言存在了，那就可以用go再重写一遍编译器，用c写的编译器来编译这个新的编译器的源代码 然后就成了现在这个样子 你可以找找老版本看看c实现
 2015年8月19日，Go语言Go 1.5版发布，本次更新中移除了”最后残余的C代码”
 从此 Go 实现了自举
Go 的市场定位 Go语言尤其适合编写网络服务相关基础设施，同时也适合开发一些工具软件和系统软件。</description>
    </item>
    
    <item>
      <title>Go异常处理</title>
      <link>https://blog.v5u.win/post/go-error/</link>
      <pubDate>Mon, 18 Feb 2019 15:48:37 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/go-error/</guid>
      <description>type error interface { Error() string }  error的声明
创建一个error
if path == &amp;quot;&amp;quot; { return nil, errors.New(&amp;quot;The parameter is invalid!&amp;quot;) }  error的使用
func readFile(path string) ([]byte, error) { file, err := os.Open(path) if err != nil { return nil, err } defer file.Close() return ioutil.ReadAll(file) }  异常处理——panic 译为运行时恐慌
内建函数panic和recover是天生的一对。前者用于产生运行时恐慌，而后者用于“恢复”它。
不过要注意，recover函数必须要在defer语句中调用才有效。因为一旦有运行时恐慌发生，当前函数以及在调用栈上的所有代码都是失去对流程的控制权。只有defer语句携带的函数中的代码才可能在运行时恐慌迅速向调用栈上层蔓延时“拦截到”它。
defer func() { if p := recover(); p != nil { fmt.Printf(&amp;quot;Fatal error: %s\n&amp;quot;, p) } }()  panic函数。该函数可接受一个interface{}类型的值作为其参数。也就是说，我们可以在调用panic函数的时候可以传入任何类型的值。不过，我建议大家在这里只传入error类型的值。这样它表达的语义才是精确的。更重要的是，当我们调用recover函数来“恢复”由于调用panic函数而引发的运行时恐慌的时候，得到的值正是调用后者时传给它的那个参数。因此，有这样一个约定是很有必要的。</description>
    </item>
    
    <item>
      <title>Go-流程控制</title>
      <link>https://blog.v5u.win/post/go-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/</link>
      <pubDate>Mon, 18 Feb 2019 11:38:16 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/go-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/</guid>
      <description>[TOC]
if 判断语句 if 100 &amp;gt; number { number += 3 } else if 100 &amp;lt; number { number -= 2 } else { fmt.Println(&amp;quot;OK!&amp;quot;) }  //变量赋值 if number := 4; 100 &amp;gt; number { number += 3 }  // 标识符的重声明和标识符的遮蔽 var number int if number := 4; 100 &amp;gt; number { number += 3 }  // 或条件 if (width == 0) ||(height == 0) || (offsetX == 0 )|| (offsetY == 0) { return nil }  标识符的重声明和标识符的遮蔽 上述代码被执行完毕之后，第二次声明的number变量的值会是7，而第一次声明的number变量的值仍会是0。</description>
    </item>
    
    <item>
      <title>Go的函数 结构体</title>
      <link>https://blog.v5u.win/post/go-function/</link>
      <pubDate>Sun, 17 Feb 2019 21:15:19 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/go-function/</guid>
      <description>func(input1 string ,input2 string) string type MyFunc func(input1 string ,input2 string) string// 函数声明  函数实现
func myFunc(part1 string, part2 string) (result string) { result = part1 + part2 return } //如果结果声明是带名称的，那么它就相当于一个已被声明但未被显式赋值的变量。 //我们可以为它赋值且在return语句中省略掉需要返回的结果值。  或
func myFunc(part1 string, part2 string) string { return part1 + part2 }  var splice func(string, string) string // 等价于 var splice MyFunc //只要一个函数的参数声明列表和结果声明列表中的数据类型的顺序和名称与某一个函数类型完全一致，前者就是后者的一个实现。  var result = func(part1 string, part2 string) string { return part1 + part2 }(&amp;quot;1&amp;quot;, &amp;quot;2&amp;quot;)  结构体</description>
    </item>
    
    <item>
      <title>Go的数据结构</title>
      <link>https://blog.v5u.win/post/go-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</link>
      <pubDate>Sun, 17 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/go-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</guid>
      <description>[TOC]
先来看看Golang关于类型设计的一些原则
 变量包括（type, value）两部分，理解这一点就知道为什么nil != nil了 type 包括 static type和concrete type. 简单来说 static type是你在编码是看见的类型(如int、string)，concrete type是runtime系统看见的类型 类型断言能否成功，取决于变量的concrete type，而不是static type. 因此，一个 reader变量如果它的concrete type也实现了write方法的话，它也可以被类型断言为writer.  变量声明 var num int = 1 //变量 const channle = &amp;quot;go&amp;quot;	//常量  注意变量作用域：在Go语言中，我们对程序实体的访问权限控制只能通过它们的名字来实现。名字首字母为大写的程序实体可以被任何代码包中的代码访问到。而名字首字母为小写的程序实体则只能被同一个代码包中的代码所访问。
数据类型 基本数据类型 整型 int8 int16 int32 int64, uint8 uint16 uint32 uint64
byte 是 uint8 的别名
rune 是 int32 的别名，用来表示Unicode。&amp;rsquo;A&amp;rsquo;: U+0041
浮点型 float32,float64
复数 complex64(3.7E+1+5.98E-2i),由两个浮点型组成分别表示实部和虚部
字符型 byte 没有专门的字符型，使用byte 来保存单个字母字符
布尔型 bool 字符串 string ​ 从表象上来说是字符序列，但是在底层，一个字符串值却是由若干个字节来表现和存储的。一个字符串（也可以说字符序列）会被Go语言用Unicode编码规范中的UTF-8编码格式编码为字节数组。</description>
    </item>
    
    <item>
      <title>go 常用命令</title>
      <link>https://blog.v5u.win/post/go-%E5%91%BD%E4%BB%A4/</link>
      <pubDate>Fri, 15 Feb 2019 15:50:32 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/go-%E5%91%BD%E4%BB%A4/</guid>
      <description>[TOC]
go run 编译并运行Go源码文件，编译的可执行文件在tmp目录下，这会影响相对路径
go build 编译源码文件，代码包，依赖包
go get / go mod download xxx 动态获取远程代码包
go get 简介（1) 用于从远程代码仓库（如著名Github )上下载并安装代码包
受支持的代码版本控制系统有：Git、Mercurial ( hg )、SVN、Bazaar
指定的代码包会被下载到$G〇PATH中包含的第一个工作区的src目录中
常用命令参数 -d 只下载 不安装 -x 查看执行过程 -u 更新已下载的代码包 -fix 将旧版本的代码包转换成新版规则  mac@name:~/go/golib/src/pkgtool$ go install -v -work 在源码目录下，执行 go install，会编译 a 文件到 $HOME/golang/goc2p: bin/ pkg/ linux_386/ pkgtool.a src/  例：go get github.com/hyper-carrot/go_lib/logging
go install go install简介( 1 )
​ 用于编译并安装代码包或源码文件
​ 安装代码包会在当前工作区的pkg/&amp;lt;平台相关目录&amp;gt;下生成归档文件
​ 安装命令源码文件会在当前工作区的bin目录或$GOBIN目录下生成可执行文件
go install 简介(2 )</description>
    </item>
    
    <item>
      <title>vscode安装golang.org的golint</title>
      <link>https://blog.v5u.win/post/go-vscode%E5%AE%89%E8%A3%85golang.org%E7%9A%84golint/</link>
      <pubDate>Fri, 15 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/go-vscode%E5%AE%89%E8%A3%85golang.org%E7%9A%84golint/</guid>
      <description>vscode 安装了 go 插件后，一些 Extensions 无法通过 vscode 自动安装，此时可以手动从控制台安装。下面是一些基础标准库
go get -u -v github.com/nsf/gocode go get -u -v github.com/rogpeppe/godef go get -u -v github.com/zmb3/gogetdoc go get -u -v github.com/golang/lint/golint go get -u -v github.com/lukehoban/go-outline go get -u -v sourcegraph.com/sqs/goreturns go get -u -v golang.org/x/tools/cmd/gorename go get -u -v github.com/tpng/gopkgs go get -u -v github.com/newhook/go-symbols go get -u -v golang.org/x/tools/cmd/guru go get -u -v github.com/cweill/gotests/...  其中 golint guru gorename 需要手动编译。</description>
    </item>
    
    <item>
      <title>go-代码组织方式</title>
      <link>https://blog.v5u.win/post/go-%E4%BB%A3%E7%A0%81%E7%BB%84%E7%BB%87%E6%96%B9%E5%BC%8F/</link>
      <pubDate>Thu, 14 Feb 2019 15:48:05 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/go-%E4%BB%A3%E7%A0%81%E7%BB%84%E7%BB%87%E6%96%B9%E5%BC%8F/</guid>
      <description>[TOC]
创建规则 引用Go常见问题解答： 供公众使用的软件包应尽量保持向后兼容性。 如果需要不同的功能，请添加新名称，而不是更改旧名称。 如果需要完全中断，请使用新的导入路径创建一个新包。 该约定通过限制作者可以做的事情简化了使用包的整体体验： 避免破坏对API的更改; 为新功能赋予新名称; 并为全新的包装设计提供新的进口途径。  导入兼容性规则： “如果旧软件包和新软件包具有相同的导入路径，则新软件包必须向后兼容旧软件包。”
取代GOPATH 使用Go模块将GOPATH作为全局名称空间结束。 从远离GOPATH开始，将现有的Go用法和工具转换为模块的几乎所有艰苦工作都是由于这种变化造成的。
GOPATH的基本思想是GOPATH目录树是正在使用的版本的全局真实来源，并且当您在目录之间移动时，所使用的版本不会改变。 但是，全局GOPATH模式与每个项目可重现构建的生产要求直接冲突，这本身就以许多重要方式简化了Go开发和部署体验。
每个项目可重现的构建意味着当您在项目A的检出工作时，您将获得与项目A的其他开发人员在该提交中获得的相同的依赖项版本集，如go.mod文件所定义。 当您切换到项目B的结帐时，现在您可以获得该项目选择的依赖版本，与项目B的其他开发人员获得的版本相同。 但是那些可能与项目A不同。当你从项目A转移到项目B时，依赖版本的变化是必要的，以使你的开发与A和B上的其他开发人员的开发保持同步。不可能有 单一的全局GOPATH了。
采用模块的大多数复杂性直接源于一个全局GOPATH的丢失。 包的源代码在哪里？ 之前，答案仅取决于您的GOPATH环境变量，大多数人很少更改。 现在，答案取决于您正在进行的项目，这可能经常发生变化。 一切都需要更新这个新的约定。
大多数开发工具使用该 go/build包来查找和加载Go源代码。我们保持该程序包正常运行，但API没有预期模块，我们为避免API更改而添加的变通方法比我们想要的慢。我们已经发布了一个替代品golang.org/x/tools/go/packages。开发人员工具现在应该使用它。它支持GOPATH和Go Module，使用起来更快更容易。在一两个版本中，我们可以将其移动到标准库中，但是现在golang.org/x/tools/go/packages 是稳定的并且可以使用。
Go源码文件以 .go 为后缀。
Go语言的代码通过包（package）组织，包类似于其它语言里的库（libraries）或者模块（modules）。一个包由位于单个目录下的一个或多个.go源代码文件组成, 目录定义包的作用。每个源文件都以一条package声明语句开始，这个例子里就是package main, 表示该文件属于哪个包，紧跟着一系列导入（import）的包，之后是存储在这个文件里的程序语句。
main包比较特殊。它定义了一个独立可执行的程序，而不是一个库。在main里的main 函数 也很特殊，它是整个程序执行时的入口
多个源码文件需要用源码包组织起来。
同一 package 下多文件代码管理 实现：在同一目录下，创建多个 go 文件， 文件的 package 都设置为同一个 package 名。但是同一个目录下只能声明一个package name。
例：package main
无需导入文件，直接调用其他文件里的方法。
举例：
在 mutifiles-package/ 目录下创建两个文件：main.go util.go
package main func main(){ foo() } // main.</description>
    </item>
    
    <item>
      <title>工作区和GOPATH</title>
      <link>https://blog.v5u.win/post/go-workspace-gopath/</link>
      <pubDate>Thu, 14 Feb 2019 15:34:03 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/go-workspace-gopath/</guid>
      <description> 工作区和GOPATH 工作区是放置Go源码文件的目录，一般情况下，Go源码文件都需要放在工作区，但是对于命令源码文件来说，这不是必须的。
工作区目录结构：
/ src/ pkg/ bin/  src/ #放源码的 pkg/ #存放归档文件(.a文件)所有归档文件都会存放到该目录下的平台相关目录中，同样以代码包为组织形式 bin/ #存放当前工作区中的Go程序的可执行文件
平台相关目录 用两个隐含的Go语言环境变量：GOOS和GOARCH
以$GOOS_$GOARCH为命名方式，例：linux_amd64和darwin_amd64
bin目录  当环境变量GOBIN已有效设置时，该目录会变得无意义 当GOPATH的值中包含多个工作区的路径时，必须设置GOBIN，否则无法成功安装Go程序的可执行文件  </description>
    </item>
    
    <item>
      <title>Go JSON</title>
      <link>https://blog.v5u.win/post/go-json/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/go-json/</guid>
      <description>标准库
encoding/json、encoding/xml、encoding/asn1  Model
type Movie struct { Title string Year int `json:&amp;quot;released&amp;quot;` Color bool `json:&amp;quot;color,omitempty&amp;quot;` Actors []string } // 赋值 var movies = []Movie{ {Title: &amp;quot;Casablanca&amp;quot;, Year: 1942, Color: false, Actors: []string{&amp;quot;Humphrey Bogart&amp;quot;, &amp;quot;Ingrid Bergman&amp;quot;}}, {Title: &amp;quot;Cool Hand Luke&amp;quot;, Year: 1967, Color: true, Actors: []string{&amp;quot;Paul Newman&amp;quot;}}, {Title: &amp;quot;Bullitt&amp;quot;, Year: 1968, Color: true, Actors: []string{&amp;quot;Steve McQueen&amp;quot;, &amp;quot;Jacqueline Bisset&amp;quot;}}, }  在编码时，默认使用Go语言结构体的成员名字作为JSON的对象（通过reflect反射技术，我们将在12.6节讨论）。只有导出的结构体成员才会被编码，这也就是我们为什么选择用大写字母开头的成员名称。
即使对应的JSON对象名是小写字母，每个结构体的成员名也是声明为大写字母开头的。因为有些JSON成员名字和Go结构体成员名字并不相同，因此需要Go语言结构体成员Tag来指定对应的JSON名字。同样，在解码的时候也需要做同样的处理，</description>
    </item>
    
    <item>
      <title>go Mac环境配置</title>
      <link>https://blog.v5u.win/post/go-mac%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/go-mac%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</guid>
      <description>在官网下载pkg安装包,点击安装，安装完成后，资源被写入/usr/local/go 目录下
 设置profile文件，我用的zsh，修改~/.zshrc。用bash的同理，修改~/.bash_profile
# go export GOROOT=/usr/local/go export GOPATH=~/dev/go/golib:~/dev/go/project #工作区，存放go源码文件的目录 export GOBIN=~/dev/go/gobin #存放编译后可执行文件的目录 export PATH=$PATH:$GOROOT/bin/:$GOBIN   3.验证，命令行执行go version返回go version go1.11.5 darwin/amd64。go语言环境配置完毕。</description>
    </item>
    
  </channel>
</rss>