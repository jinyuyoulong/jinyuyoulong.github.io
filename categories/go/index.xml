<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Go on 为吾优</title>
    <link>https://blog.v5u.win/categories/go/</link>
    <description>Recent content in Go on 为吾优</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Wed, 17 Jul 2019 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://blog.v5u.win/categories/go/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>go社区拒绝了try提案</title>
      <link>https://blog.v5u.win/post/go-%E6%8B%92%E7%BB%9D%E4%BA%86try%E6%8F%90%E6%A1%88/</link>
      <pubDate>Wed, 17 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/go-%E6%8B%92%E7%BB%9D%E4%BA%86try%E6%8F%90%E6%A1%88/</guid>
      <description>提案：内置的Go错误检查功能， try 该提案已经结束。谢谢大家，感谢您的投入。
在评论之前，请阅读详细的设计文档，并查看截至6月6日的摘要，截至6月10日的摘要，*最重要的是关于保持专注的建议*。您的问题或建议可能已经得到解答或提出。谢谢。
我们提出了一个新的内置函数try，专门用于消除if通常与Go中的错误处理相关的样板语句。建议不要更改其他语言。我们提倡使用现有defer语句和标准库函数来帮助扩充或包装错误。这种最小化的方法可以解决大多数常见情况，同时为语言增加很少的复 该try内置很容易解释，直接实现的，垂直的其它语言结构，并完全向后兼容。如果我们希望将来这样做，它还为扩展机制留下了开辟的道路。
[以下文字已经过编辑，可以更准确地反映设计文档。]
的try内置函数采用一个单一表达式作为参数。表达式必须求值为n + 1个值（其中n可能为零），其中最后一个值必须是type error。如果（final）error参数为nil，则返回前n个值（如果有），否则返回带有该错误的封闭函数。例如，代码如
f，错误 ：= os。打开（文件名） if err！= nil { return ...，err //其他结果的零值，如果有的话 }  可以简化为
f ：= try（os。打开（文件名））  try只能在自身返回error结果的函数中使用，并且该结果必须是封闭函数的最后一个结果参数。
该提案将去年GopherCon中提出的原始设计草案简化为其本质。如果需要错误扩充或包装，有两种方法：坚持使用久经考验的if语句，或者，使用语句“声明”错误处理程序defer：
defer func（）{ if err！= nil {	//可能没有发生错误 - 检查 错误= ...	// wrap / augment error } }（）  这里 err是封闭函数的错误结果的名称。在实践中，合适的辅助函数将减少错误处理程序对单行程序的声明。例如
延迟 fmt。HandleErrorf（＆err，“ copy ％s ％s ”，src，dst）  （fmt.HandleErrorf装饰*err）读得很好，可以在不需要新语言功能的情况下实现。
这种方法的主要缺点是需要命名错误结果参数，可能导致不太漂亮的API。最终这是一个风格问题，我们相信我们会适应期待新风格，就像我们适应没有分号一样。
总而言之，一开始try可能看起来很不寻常，但它只是针对一个特定任务量身定制的语法糖，错误处理用较少的样板，并且足够好地处理该任务。因此，它非常符合Go的哲学。try不是为解决*所有*错误处理情况而设计的; 它旨在很好地处理*最常见的*情况，以保持设计简单明了。
积分 该提议受到我们迄今收到的反馈的强烈影响。具体来说，它借鉴了以下方面的想法
 错误处理的关键部分， 问题＃31442 和，相关的，问题＃32219。  VojtechVitek** 评论道 我觉得try()已经表达了反对该提案的所有重要反馈意见。但让我试着总结一下：</description>
    </item>
    
    <item>
      <title>Goland 使用</title>
      <link>https://blog.v5u.win/post/go-goland/</link>
      <pubDate>Fri, 12 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/go-goland/</guid>
      <description>做 Go 开发，一般使用的IDE是 Goland
安装略，自己解决。下面说安装后的事情。
 配置文件，配置开发环境  goland 会自动读取 GOROOT 和 GOPATH，所以不用自己填写。我们要做的就是配置配置文件
创建go build配置文件：Templates&amp;ndash;&amp;gt; Go Build Run kind 选Directory Directory 选你的main包所在文件夹 Output directory设置与go build -o 不相容，所以不用设置，我们使用-o参数来控制可执行文件的路径以及名字 Working directory保持默认就好 Go tool arguments 就是go build 的参数
 debug  goland 的 debug 功能可以看到 整个函数链条，和当下参数的值，以及 ·s 文件(汇编文件)的内部调用
单文件调试：直接点击run旁边的debug按钮，左下方有细分子项：跳过执行（步过），单步调试（步入），步出
整项目调试：</description>
    </item>
    
    <item>
      <title>Go orm 对比选择</title>
      <link>https://blog.v5u.win/post/go-orm/</link>
      <pubDate>Wed, 10 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/go-orm/</guid>
      <description>golang 中 orm最主流的两个包，xorm和gorm。所以主要在他们之间做抉择。
   name xorm gorm     github-stars 5,053 14,262   github-fork 650 1,606         不管是从stars数还是fork gorm都是大比例拉开。gorm是老牌的项目，xorm是这两年崛起来的。
最后我选择了xormplus 因为路径依赖，学习golang的时候的示例用的是xorm。:sweat_smile:
xorm 自动生成代码
xorm help reverse
格式：xorm reverse dirver dbname 导出模板
xorm reverse mysql &amp;quot;username:pwd@tcp(127.0.0.1:3306)/dbname?charset=utf8&amp;quot; $GOPATH/src/github.com/go-xorm/cmd/xorm/templates/goxorm  </description>
    </item>
    
    <item>
      <title>Go Iris Redis</title>
      <link>https://blog.v5u.win/post/go-iris-redis/</link>
      <pubDate>Tue, 11 Jun 2019 10:15:20 +0800</pubDate>
      
      <guid>https://blog.v5u.win/post/go-iris-redis/</guid>
      <description>[TOC]
iris 中使用 Redis iris 内置对 Redis 的支持，但是她和 session 结合的比较紧密，比如每一个方法传参都大部分都有 sid，在当前文件 database.go 找了半天没找到在哪里定义了 sid，func (db *Database) Get(sid string, key string) (value interface{})
只能推断是 sessionId，果然在 Session struct 中发现了 sid。
Session struct { sid string isNew bool flashes map[string]*flashMessage mu sync.RWMutex // for flashes. Lifetime LifeTime provider *provider }  所以可以下结论，iris中必须使用内置的 Redis 是只对 session 的配合支持，如果需要单独操作 Redis 数据库，则需要使用其他的第三方库来操作，比如：redigo 和 go-redis/redis</description>
    </item>
    
    <item>
      <title>Go 单例</title>
      <link>https://blog.v5u.win/post/go-%E5%8D%95%E4%BE%8B/</link>
      <pubDate>Mon, 27 May 2019 00:00:00 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/go-%E5%8D%95%E4%BE%8B/</guid>
      <description>为什么使用单例？
由于Go的多协程机制，当只是单核的时候，变量还不会出现问题，但是当设置成多核之后，就会涉及到变量的作用域问题，只用普通方式常见的变量在其他线程上会得到错误的方法
一、 sync.Once用法
在Go中有一个简洁的方法就是使用sync.Once，它可以在多协程中起到控制作用。实现起来也非常简单。
var ( once sync.Once instance *SingleTon ) func GetInstance(str string) *SingleTon { once.Do(func() { instance = &amp;amp;SingleTon{Attr: str} }) return instance }  二、使用加锁机制 在Go语言中有个基础对象sync.Mutex，可以实现协程之间的同步逻辑。
var mu sync.Mutex func GetInstance() *SingleTon { mu.Lock() defer mu.Unock() if Instance == nil { instance = &amp;amp;SingleTon{} } return instance }  三、简单粗暴模式. 这种方式实现起来特别简单，直接判断一个实力是不是为nil， 如果是，则新生成；否则返回已有的。但它和多数语言一样，只适合用在单线程。
type SingleTon struct { } var instance *SingleTon func GetInstance() *SingleTon { if Instance == nil { instance = &amp;amp;SingleTon{} } return instance }  测试代码如下，从运行结果来看，都是一致的。</description>
    </item>
    
    <item>
      <title>Go DI LoC研究</title>
      <link>https://blog.v5u.win/post/go-di-loc/</link>
      <pubDate>Fri, 24 May 2019 00:00:00 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/go-di-loc/</guid>
      <description>依赖注入，控制反转
目的：实现模块与项目的解耦
实现流程
首先模块有指针，其次DI拿到指针，再次DI将指针赋给调用者
共调研了三个框架：iris内置的di&amp;amp;mvc，uber-dig，google/wire
最终决定使用 wire
google DI 框架 wire 它通过使用代码生成构建容器来避免运行时反射。
用法：
// file main.go package main import &amp;quot;bytes&amp;quot; type Logger struct{} func (logger *Logger) Log(message string) { println(message) } type HttpClient struct { logger *Logger } func (client *HttpClient) Get(url string) string { client.logger.Log(&amp;quot;Getting &amp;quot; + url) return &amp;quot;my response from &amp;quot; + url } func NewHttpClient(logger *Logger) *HttpClient { return &amp;amp;HttpClient{logger} } type ConcatService struct { logger *Logger client *HttpClient } func NewConcatService(logger *Logger, client *HttpClient) *ConcatService { return &amp;amp;ConcatService{logger, client} } func (service *ConcatService) GetAll(urls .</description>
    </item>
    
    <item>
      <title>imagick</title>
      <link>https://blog.v5u.win/post/go-imagick/</link>
      <pubDate>Fri, 17 May 2019 00:00:00 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/go-imagick/</guid>
      <description>Go语言imagick 使用总结 imagick 是一个开源的 c语言图片处理库，所以需要本地安装，并且配置 CGO
Mac 安装imagic
brew install imagemagick
CGO配置
export CGO_CFLAGS_ALLOW=&#39;-Xpreprocessor&#39; #cgo	 Initialize() 和 Terminate 根据ImageMagick C API，Initialize()应该只调用一次来设置使用ImageMagick的资源。这通常在您main()或init()整个应用程序或库中完成。应用程序可以推迟调用以Terminate()拆除ImageMagick资源。
多次调用特殊方法，导致常见的问题，这是一个错误对于Initialize，和Terminate来说，如死机或丢失代理。除了在程序中对ImageMagick的绝对需求外，不要使用Terminate。
内存管理 由于这是一个CGO绑定，并且Go GC不管理由C API分配的内存，因此必须使用Terminate（）和Destroy（）方法。
通过New*构造函数（MagickWand，DrawingWand，PixelIterator，PixelWand，&amp;hellip;）创建的类型由Go GC通过使用终结器进行管理。
如果使用struct literals，则应手动释放资源：
package main import &amp;quot;github.com/gographics/imagick/imagick&amp;quot; func main() { imagick.Initialize() // Schedule cleanup defer imagick.Terminate() var err error mw := imagick.NewMagickWand() defer mw.Destroy() err = mw.ReadImage(&amp;quot;header.png&amp;quot;) if err != nil { panic(err) } // Get original logo size width := mw.</description>
    </item>
    
    <item>
      <title>Go-Authorization</title>
      <link>https://blog.v5u.win/post/go-authorization/</link>
      <pubDate>Mon, 15 Apr 2019 14:52:48 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/go-authorization/</guid>
      <description>接口认证 一般接口开发中有以下常用的几种安全机制：
 用户认证 数字签名 接口加密  用户认证 一般的接口测试工具都会提供一个User Auth/Authorization的选项
 基本认证（Basic Auth） 摘要认证（Digest Auth） OAuth 2.0（最常见，现在的网站接口多数提供此用户认证方式）授权认证方式  接口需要认证：auth=(&amp;ldquo;username&amp;rdquo;,&amp;ldquo;password&amp;rdquo;)
数字签名 在使用 HTTP/SOAP 协议传输数据的时候，签名作为其中一个参数，可以起到关键作用：通过客户的密钥，服务端的密钥匹配；当服务器接收到请求后，同样需要对“signpassword”进行 MD5 加密，然后，比对与调用者传来的 sign 加密串是否一致，从而来鉴别调用者是否有权限使用该接口。
http://127.0.0.1:8000/sign/?a=1&amp;amp;b=2&amp;amp;sign=6648e929329e53e7a91c50ae685a88b5
接口加密 通常接口会使用更复杂一点的方式来进行加密的操作，常见的是AES的使用
AES加密里面有两个关键，一个是key（必须为16,24,32位），一个是VI（必须为16位） 解密：解密者必须要同时知道key和VI才可以解密
参考</description>
    </item>
    
    <item>
      <title>Go gRPC研究总结</title>
      <link>https://blog.v5u.win/post/go-grpc%E7%A0%94%E7%A9%B6%E6%80%BB%E7%BB%93/</link>
      <pubDate>Thu, 11 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/go-grpc%E7%A0%94%E7%A9%B6%E6%80%BB%E7%BB%93/</guid>
      <description>什么是RPC RPC（Remote Procedure Call）—远程过程调用，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。RPC协议假定某些传输协议的存在，如TCP或UDP，为通信程序之间携带信息数据。在OSI网络通信模型中，RPC跨越了传输层和应用层。RPC使得开发包括网络分布式多程序在内的应用程序更加容易。——百度百科
支持环境配置(Mac)
安装protobuf 这是 Google 开源的一套成熟的结构数据序列化机制Protocol Buffers 3 简明教程
brew info protobuf brew install protobuf  检验protobuf安装结果
protoc --version libprotoc 3.5.1  安装第三方包
go mod download github.com/golang/protobuf/proto go mod download github.com/golang/protobuf/protoc-gen-go go mod download google.golang.org/grpc go install github.com/golang/protobuf/protoc-gen-go //编译 protoc-gen-go 可执行文件  创建 protobuf 文件
vi add.proto add some date  生成 gRPC 代码
protoc -I ./protos ./protos/helloworld.proto --go_out=plugins=grpc:helloworld 或 protoc -I . add.proto --go_out=plugins=grpc:.  这生成了 helloworld.</description>
    </item>
    
    <item>
      <title>Go modules</title>
      <link>https://blog.v5u.win/post/go-modules/</link>
      <pubDate>Wed, 03 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/go-modules/</guid>
      <description> go modules [TOC]
环境配置  正确配置 GOROOT
 export GOPROXY=&amp;quot;https://athens.azurefd.net&amp;quot; # 微软提供的公共代理，解决golang/x/tools 下载失败
  初始化 同时 确定了项目的绝对目录路径 go mod init v5u.win/projectapi 生成 go.mod 导入包：import &amp;quot;v5u.win/projectapi/src/app/service&amp;quot;
添加依赖 go mod tidy
生成 go.sum 自动添加依赖关系到 go.mod go run main.go
下载依赖包 go mod download github.com/pelletier/go-toml
Tips:  不能在 golib/src 下创建项目 在 Go1.11 版本下，GOPATH 目录中的项目默认是禁用 Go Module 的，需要手动开启 export GOPROXY=&amp;ldquo;https://athens.azurefd.net&amp;quot; // 微软提供的公共代理,也可以以此技术建立自己的公共库 export export GO111MODULE=on // 必须使用module依赖，在src/ 目录下可以使用module  常用命令 go mod tidy //拉取缺少的模块，移除不用的模块。 go mod download //下载依赖包 go mod graph //打印模块依赖图 go mod vendor //将依赖复制到 vendor 下 go mod verify //校验依赖 go mod why //解释为什么需要依赖 go list -m -json all //依赖详情  </description>
    </item>
    
    <item>
      <title>Go-API 项目模板文档</title>
      <link>https://blog.v5u.win/post/go-api-%E9%A1%B9%E7%9B%AE%E6%A8%A1%E6%9D%BF%E6%96%87%E6%A1%A3/</link>
      <pubDate>Wed, 03 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/go-api-%E9%A1%B9%E7%9B%AE%E6%A8%A1%E6%9D%BF%E6%96%87%E6%A1%A3/</guid>
      <description>项目目录结构规范 PROJECT_NAME ├── README.md //介绍软件及文档入口 ├── bin //编译好的二进制文件,执行./build.sh自动生成，该目录也用于程序打包 ├── build.sh //自动编译的脚本 ├── doc //该项目的文档 ├── pack //打包后的程序放在此处 ├── pack.sh //自动打包的脚本，生成类似xxxx.20170713_14:45:35.tar.gz的文件，放在pack文件下 └── src //该项目的源代码 ├── main //项目主函数 ├── test //测试 ├── app //项目代码 ├── public //公共文件/静态文件 └── vendor //存放go的库 ├── github.com/xxx //第三方库 └── xxx.com/abc //公司内部的公共库  项目的目录结构尽量做到简明、层次清楚。
./app ├── bootstrap	//入口引导文件 ├── cache ├── config	//项目配置 ├── controller	//request请求处理中心 ——&amp;gt; controller ——&amp;gt; Response / view ├── library	//项目工具库 ├── log	//日志 —— 考虑发布目录 ├── middleware	//中间件 ├── model	//data model.</description>
    </item>
    
    <item>
      <title>Go-iris-template</title>
      <link>https://blog.v5u.win/post/go-iris-template/</link>
      <pubDate>Fri, 08 Mar 2019 17:25:10 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/go-iris-template/</guid>
      <description>Iris 支持五个开箱即用的模板引擎，所有这五个模板引擎都具有通用API的共同特征，如布局，模板功能，特定于派对的布局，部分渲染等。
 标准的html,它的模板解析器就是 golang.org/pkg/html/template/
Django,它的模板解析器就是 github.com/flosch/pongo2
Pug(Jade),它的模板解析器就是 github.com/Joker/jade
Handlebars, 它的模板解析器 github.com/aymerick/raymond
Amber, 它的模板解析器 github.com/eknkc/amber
 </description>
    </item>
    
    <item>
      <title>Go Iris 路由</title>
      <link>https://blog.v5u.win/post/go-iris-%E8%B7%AF%E7%94%B1/</link>
      <pubDate>Fri, 08 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/go-iris-%E8%B7%AF%E7%94%B1/</guid>
      <description> 路由配置规则 直接通过 function 绑定 controller，function name 映射到 路由的地址
function named rule：
func(*Controller) GetLoginBy(id int64) 绑定的controller HTTP-method+routePath map to - GET:/user/login/{param:long}  通过控制器方法的输入参数访问动态路径参数，不需要绑定。当您使用Iris的默认语法来解析来自控制器的处理程序时，您需要使用By字来为方法添加后缀，大写是一个新的子路径。例： 如这种形式 mvc.New(app.Party(&amp;ldquo;/user&amp;rdquo;)).Handle(new(user.Controller)) 则:
 func(*Controller) Get() - GET:/user func(*Controller) Post() - POST:/user func(*Controller) GetLogin() - GET:/user/login func(*Controller) PostLogin() - POST:/user/login func(*Controller) GetProfileFollowers() - GET:/user/profile/followers func(*Controller) PostProfileFollowers() - POST:/user/profile/followers func(*Controller) GetBy(id int64) - GET:/user/{param:long} func(*Controller) PostBy(id int64) - POST:/user/{param:long}  </description>
    </item>
    
    <item>
      <title>Go Error 错误处理</title>
      <link>https://blog.v5u.win/post/go-error-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/</link>
      <pubDate>Wed, 06 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/go-error-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/</guid>
      <description>常用的有五种方式
第一种策略 首先，也是最常用的方式是传播错误。这意味着函数中某个子程序的失败，会变成该函数的失败。我们使用该函数前缀添加额外的上下文信息到原始错误信息。当错误最终由main函数处理时，错误信息应提供清晰的从原因到后果的因果链，就像美国宇航局事故调查时做的那样：
 genesis: crashed: no parachute: G-switch failed: bad relay orientation
 编写错误信息时，我们要确保错误信息对问题细节的描述是详尽的。尤其是要注意错误信息表达的一致性，即相同的函数或同包内的同一组函数返回的错误在构成和处理方式上是相似的。
第二种策略 第二种策略。如果错误的发生是偶然性的，或由不可预知的问题导致的。一个明智的选择是重新尝试失败的操作。在重试时，我们需要限制重试的时间间隔或重试的次数，防止无限制的重试。
第三种策略 如果错误发生后，程序无法继续运行，我们就可以采用第三种策略：输出错误信息并结束程序。需要注意的是，这种策略只应在main中执行。对库函数而言，应仅向上传播错误，除非该错误意味着程序内部包含不一致性，即遇到了bug，才能在库函数中结束程序。
调用log.Fatalf可以更简洁的代码达到与上文相同的效果。log中的所有函数，都默认会在错误信息之前输出时间信息。
if err := WaitForServer(url); err != nil { log.Fatalf(&amp;quot;Site is down: %v\n&amp;quot;, err) } // 我们可以设置log的前缀信息屏蔽时间信息，一般而言，前缀信息会被设置成命令名。 log.SetPrefix(&amp;quot;wait: &amp;quot;) log.SetFlags(0)  第四种策略 第四种策略：有时，我们只需要输出错误信息就足够了，不需要中断程序的运行。
我们可以通过log包提供函数
if err := Ping(); err != nil { log.Printf(&amp;quot;ping failed: %v; networking disabled&amp;quot;,err) } //log包中的所有函数会为没有换行符的字符串增加换行符。  或者标准错误流输出错误信息。
if err := Ping(); err != nil { fmt.Fprintf(os.Stderr, &amp;quot;ping failed: %v; networking disabled\n&amp;quot;, err) }  第五种策略 第五种，也是最后一种策略：我们可以直接忽略掉错误。</description>
    </item>
    
    <item>
      <title>Go HTML template</title>
      <link>https://blog.v5u.win/post/go-html-template/</link>
      <pubDate>Tue, 05 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/go-html-template/</guid>
      <description>文档 go doc text/template $ go doc html/template  应用 func main() { // 定义模板显示格式 const templ = `&amp;lt;p&amp;gt;A: {{.A}}&amp;lt;/p&amp;gt;&amp;lt;p&amp;gt;B: {{.B}}&amp;lt;/p&amp;gt;` // 模板配置函数 t := template.Must(template.New(&amp;quot;escape&amp;quot;).Parse(templ)) var data struct { A string // untrusted plain text B template.HTML // trusted HTML } // A是一个普通字符串，B是一个信任的template.HTML字符串类型。 data.A = &amp;quot;&amp;lt;b&amp;gt;Hello!&amp;lt;/b&amp;gt;&amp;quot; data.B = &amp;quot;&amp;lt;b&amp;gt;Hello!&amp;lt;/b&amp;gt;&amp;quot; // 使用定义好的 模板 输出到 控制台 if err := t.Execute(os.Stdout, data); err != nil { log.Fatal(err) } } /* autoescape.html 结果 A:&amp;lt;b&amp;gt;Hello!</description>
    </item>
    
    <item>
      <title>Go-语言要点</title>
      <link>https://blog.v5u.win/post/go-%E8%AF%AD%E8%A8%80%E8%A6%81%E7%82%B9/</link>
      <pubDate>Wed, 27 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/go-%E8%AF%AD%E8%A8%80%E8%A6%81%E7%82%B9/</guid>
      <description>[TOC]
要点 本章对Go语言做了一些介绍，Go语言很多方面在有限的篇幅中无法覆盖到。本节会把没有讲到的内容也做一些简单的介绍，这样读者在读到完整的内容之前，可以有个简单的印象。
控制流 在本章我们只介绍了if控制和for，但是没有提到switch多路选择。这里是一个简单的switch的例子：
switch coinflip() { case &amp;quot;heads&amp;quot;: heads++ case &amp;quot;tails&amp;quot;: tails++ default: fmt.Println(&amp;quot;landed on edge!&amp;quot;) }  在翻转硬币的时候，例子里的coinflip函数返回几种不同的结果，每一个case都会对应一个返回结果，这里需要注意，Go语言并不需要显式地在每一个case后写break，语言默认执行完case后的逻辑语句会自动退出。当然了，如果你想要相邻的几个case都执行同一逻辑的话，需要自己显式地写上一个fallthrough语句来覆盖这种默认行为。不过fallthrough语句在一般的程序中很少用到。
Go语言里的switch还可以不带操作对象（译注：switch不带操作对象时默认用true值代替，然后将每个case的表达式和true值进行比较）；可以直接罗列多种条件，像其它语言里面的多个if else一样，下面是一个例子：
func Signum(x int) int { switch { case x &amp;gt; 0: return +1 default: return 0 case x &amp;lt; 0: return -1 } }  这种形式叫做无tag switch(tagless switch)；这和switch true是等价的。
像for和if控制语句一样，switch也可以紧跟一个简短的变量声明，一个自增表达式、赋值语句，或者一个函数调用(译注：比其它语言丰富)。
break和continue语句会改变控制流。和其它语言中的break和continue一样，break会中断当前的循环，并开始执行循环之后的内容，而continue会跳过当前循环，并开始执行下一次循环。这两个语句除了可以控制for循环，还可以用来控制switch和select语句(之后会讲到)，在1.3节中我们看到，continue会跳过内层的循环，如果我们想跳过的是更外层的循环的话，我们可以在相应的位置加上label，这样break和continue就可以根据我们的想法来continue和break任意循环。这看起来甚至有点像goto语句的作用了。当然，一般程序员也不会用到这种操作。这两种行为更多地被用到机器生成的代码中。
命名类型 类型声明使得我们可以很方便地给一个特殊类型一个名字。因为struct类型声明通常非常地长，所以我们总要给这种struct取一个名字。本章中就有这样一个例子，二维点类型：
type Point struct { X, Y int } var p Point  类型声明和命名类型会在第二章中介绍。</description>
    </item>
    
    <item>
      <title>Go 语言简介</title>
      <link>https://blog.v5u.win/post/go-%E8%AF%AD%E8%A8%80%E7%AE%80%E4%BB%8B/</link>
      <pubDate>Thu, 21 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/go-%E8%AF%AD%E8%A8%80%E7%AE%80%E4%BB%8B/</guid>
      <description>Go 的底层语言是什么 借用大神的话来说
 编译器就是输入源代码输出其他语言源代码的程序
 所以这个程序用什么语言实现无所谓
然而，一开始没有go，所以用c实现了一版go编译器，后来go语言存在了，那就可以用go再重写一遍编译器，用c写的编译器来编译这个新的编译器的源代码 然后就成了现在这个样子 你可以找找老版本看看c实现
 2015年8月19日，Go语言Go 1.5版发布，本次更新中移除了”最后残余的C代码”
 从此 Go 实现了自举
Go 的市场定位 Go语言尤其适合编写网络服务相关基础设施，同时也适合开发一些工具软件和系统软件。
​ ——《The Go Programming Language》
Go 语言能吞食的一定是 PaaS 上的项目，比如一些消息缓存中间件、服务发现、服务代理、控制系统、Agent、日志收集等等，没有复杂的业务场景，也到不了特别底层（如操作系统）的中间平台层的软件项目或工具。而 C 和 C++ 会被打到更底层，Java 会被打到更上层的业务层。这是左耳朵耗子的一个判断。
用上面的标尺来量一下 Go 语言的杀手级应用 Docker，你会发现基本是一样的。
学习文档</description>
    </item>
    
    <item>
      <title>Go异常处理</title>
      <link>https://blog.v5u.win/post/go-error/</link>
      <pubDate>Mon, 18 Feb 2019 15:48:37 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/go-error/</guid>
      <description>type error interface { Error() string }  error的声明
创建一个error
if path == &amp;quot;&amp;quot; { return nil, errors.New(&amp;quot;The parameter is invalid!&amp;quot;) }  error的使用
func readFile(path string) ([]byte, error) { file, err := os.Open(path) if err != nil { return nil, err } defer file.Close() return ioutil.ReadAll(file) }  异常处理——panic 译为运行时恐慌
内建函数panic和recover是天生的一对。前者用于产生运行时恐慌，而后者用于“恢复”它。
不过要注意，recover函数必须要在defer语句中调用才有效。因为一旦有运行时恐慌发生，当前函数以及在调用栈上的所有代码都是失去对流程的控制权。只有defer语句携带的函数中的代码才可能在运行时恐慌迅速向调用栈上层蔓延时“拦截到”它。
defer func() { if p := recover(); p != nil { fmt.Printf(&amp;quot;Fatal error: %s\n&amp;quot;, p) } }()  panic函数。该函数可接受一个interface{}类型的值作为其参数。也就是说，我们可以在调用panic函数的时候可以传入任何类型的值。不过，我建议大家在这里只传入error类型的值。这样它表达的语义才是精确的。更重要的是，当我们调用recover函数来“恢复”由于调用panic函数而引发的运行时恐慌的时候，得到的值正是调用后者时传给它的那个参数。因此，有这样一个约定是很有必要的。</description>
    </item>
    
    <item>
      <title>Go-流程控制</title>
      <link>https://blog.v5u.win/post/go-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/</link>
      <pubDate>Mon, 18 Feb 2019 11:38:16 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/go-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/</guid>
      <description>[TOC]
if 判断语句 if 100 &amp;gt; number { number += 3 } else if 100 &amp;lt; number { number -= 2 } else { fmt.Println(&amp;quot;OK!&amp;quot;) }  //变量赋值 if number := 4; 100 &amp;gt; number { number += 3 }  // 标识符的重声明和标识符的遮蔽 var number int if number := 4; 100 &amp;gt; number { number += 3 }  // 或条件 if (width == 0) ||(height == 0) || (offsetX == 0 )|| (offsetY == 0) { return nil }  标识符的重声明和标识符的遮蔽 上述代码被执行完毕之后，第二次声明的number变量的值会是7，而第一次声明的number变量的值仍会是0。</description>
    </item>
    
    <item>
      <title>Go的函数 结构体</title>
      <link>https://blog.v5u.win/post/go-function/</link>
      <pubDate>Sun, 17 Feb 2019 21:15:19 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/go-function/</guid>
      <description>func(input1 string ,input2 string) string type MyFunc func(input1 string ,input2 string) string// 函数声明  函数实现
func myFunc(part1 string, part2 string) (result string) { result = part1 + part2 return } //如果结果声明是带名称的，那么它就相当于一个已被声明但未被显式赋值的变量。 //我们可以为它赋值且在return语句中省略掉需要返回的结果值。  或
func myFunc(part1 string, part2 string) string { return part1 + part2 }  var splice func(string, string) string // 等价于 var splice MyFunc //只要一个函数的参数声明列表和结果声明列表中的数据类型的顺序和名称与某一个函数类型完全一致，前者就是后者的一个实现。  var result = func(part1 string, part2 string) string { return part1 + part2 }(&amp;quot;1&amp;quot;, &amp;quot;2&amp;quot;)  结构体</description>
    </item>
    
    <item>
      <title>Go的数据结构</title>
      <link>https://blog.v5u.win/post/go-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</link>
      <pubDate>Sun, 17 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/go-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</guid>
      <description>[TOC]
先来看看Golang关于类型设计的一些原则
 变量包括（type, value）两部分，理解这一点就知道为什么nil != nil了 type 包括 static type和concrete type. 简单来说 static type是你在编码是看见的类型(如int、string)，concrete type是runtime系统看见的类型 类型断言能否成功，取决于变量的concrete type，而不是static type. 因此，一个 reader变量如果它的concrete type也实现了write方法的话，它也可以被类型断言为writer.  变量声明 var num int = 1 //变量 const channle = &amp;quot;go&amp;quot;	//常量  注意变量作用域：在Go语言中，我们对程序实体的访问权限控制只能通过它们的名字来实现。名字首字母为大写的程序实体可以被任何代码包中的代码访问到。而名字首字母为小写的程序实体则只能被同一个代码包中的代码所访问。
数据类型 基本数据类型 整型 int8 int16 int32 int64, uint8 uint16 uint32 uint64
byte 是 uint8 的别名
rune 是 int32 的别名，用来表示Unicode。&amp;rsquo;A&amp;rsquo;: U+0041
浮点型 float32,float64
复数 complex64(3.7E+1+5.98E-2i),由两个浮点型组成分别表示实部和虚部
字符型 byte 没有专门的字符型，使用byte 来保存单个字母字符
布尔型 bool 字符串 string ​ 从表象上来说是字符序列，但是在底层，一个字符串值却是由若干个字节来表现和存储的。一个字符串（也可以说字符序列）会被Go语言用Unicode编码规范中的UTF-8编码格式编码为字节数组。</description>
    </item>
    
    <item>
      <title>go 常用命令</title>
      <link>https://blog.v5u.win/post/go-%E5%91%BD%E4%BB%A4/</link>
      <pubDate>Fri, 15 Feb 2019 15:50:32 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/go-%E5%91%BD%E4%BB%A4/</guid>
      <description>[TOC]
go run 编译并运行Go源码文件，编译的可执行文件在tmp目录下，这会影响相对路径
go build 编译源码文件，代码包，依赖包
go get / go mod download xxx 动态获取远程代码包
go get 简介（1) 用于从远程代码仓库（如著名Github )上下载并安装代码包
受支持的代码版本控制系统有：Git、Mercurial ( hg )、SVN、Bazaar
指定的代码包会被下载到$G〇PATH中包含的第一个工作区的src目录中
常用命令参数 -d 只下载 不安装 -x 查看执行过程 -u 更新已下载的代码包 -fix 将旧版本的代码包转换成新版规则  mac@name:~/go/golib/src/pkgtool$ go install -v -work 在源码目录下，执行 go install，会编译 a 文件到 $HOME/golang/goc2p: bin/ pkg/ linux_386/ pkgtool.a src/  例：go get github.com/hyper-carrot/go_lib/logging
go install go install简介( 1 )
​ 用于编译并安装代码包或源码文件
​ 安装代码包会在当前工作区的pkg/&amp;lt;平台相关目录&amp;gt;下生成归档文件
​ 安装命令源码文件会在当前工作区的bin目录或$GOBIN目录下生成可执行文件
go install 简介(2 )</description>
    </item>
    
    <item>
      <title>vscode安装golang.org的golint</title>
      <link>https://blog.v5u.win/post/go-vscode%E5%AE%89%E8%A3%85golang.org%E7%9A%84golint/</link>
      <pubDate>Fri, 15 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/go-vscode%E5%AE%89%E8%A3%85golang.org%E7%9A%84golint/</guid>
      <description>vscode 安装了 go 插件后，一些 Extensions 无法通过 vscode 自动安装，此时可以手动从控制台安装。下面是一些基础标准库
go get -u -v github.com/nsf/gocode go get -u -v github.com/rogpeppe/godef go get -u -v github.com/zmb3/gogetdoc go get -u -v github.com/golang/lint/golint go get -u -v github.com/lukehoban/go-outline go get -u -v sourcegraph.com/sqs/goreturns go get -u -v golang.org/x/tools/cmd/gorename go get -u -v github.com/tpng/gopkgs go get -u -v github.com/newhook/go-symbols go get -u -v golang.org/x/tools/cmd/guru go get -u -v github.com/cweill/gotests/...  其中 golint guru gorename 需要手动编译。</description>
    </item>
    
    <item>
      <title>go-代码组织方式</title>
      <link>https://blog.v5u.win/post/go-%E4%BB%A3%E7%A0%81%E7%BB%84%E7%BB%87%E6%96%B9%E5%BC%8F/</link>
      <pubDate>Thu, 14 Feb 2019 15:48:05 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/go-%E4%BB%A3%E7%A0%81%E7%BB%84%E7%BB%87%E6%96%B9%E5%BC%8F/</guid>
      <description>[TOC]
Go源码文件以 .go 为后缀。
Go语言的代码通过包（package）组织，包类似于其它语言里的库（libraries）或者模块（modules）。一个包由位于单个目录下的一个或多个.go源代码文件组成, 目录定义包的作用。每个源文件都以一条package声明语句开始，这个例子里就是package main, 表示该文件属于哪个包，紧跟着一系列导入（import）的包，之后是存储在这个文件里的程序语句。
main包比较特殊。它定义了一个独立可执行的程序，而不是一个库。在main里的main 函数 也很特殊，它是整个程序执行时的入口
多个源码文件需要用源码包组织起来。
同一 package 下多文件代码管理 实现：在同一目录下，创建多个 go 文件， 文件的 package 都设置为同一个 package 名。但是同一个目录下只能声明一个package name。
例：package main
无需导入文件，直接调用其他文件里的方法。
举例：
在 mutifiles-package/ 目录下创建两个文件：main.go util.go
package main func main(){ foo() } // main.go  package main import &amp;quot;fmt&amp;quot; func foo(){ fmt.Println(&amp;quot;foo()&amp;quot;) } // util.go	 命令行执行 go build,生成一个 mutifiles-package 可执行文件。
./mutifiles-package 打印 foo() 。
注意：直接运行 go run main.go util.go 也可以打印 foo()，必须将两个文件都引入。
代码包的导入 import用法 import( &amp;quot;fmt&amp;quot; )  上面这个fmt是Go语言的标准库，他其实是去GOROOT下去加载该模块（先找GOROOT，如果GOROOT找不到在去GOPATH找），当然Go的import还支持如下两种方式来加载自己写的模块：</description>
    </item>
    
    <item>
      <title>工作区和GOPATH</title>
      <link>https://blog.v5u.win/post/go-workspace-gopath/</link>
      <pubDate>Thu, 14 Feb 2019 15:34:03 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/go-workspace-gopath/</guid>
      <description> 工作区和GOPATH 工作区是放置Go源码文件的目录，一般情况下，Go源码文件都需要放在工作区，但是对于命令源码文件来说，这不是必须的。
工作区目录结构：
/ src/ pkg/ bin/  src/ #放源码的 pkg/ #存放归档文件(.a文件)所有归档文件都会存放到该目录下的平台相关目录中，同样以代码包为组织形式 bin/ #存放当前工作区中的Go程序的可执行文件
平台相关目录 用两个隐含的Go语言环境变量：GOOS和GOARCH
以$GOOS_$GOARCH为命名方式，例：linux_amd64和darwin_amd64
bin目录  当环境变量GOBIN已有效设置时，该目录会变得无意义 当GOPATH的值中包含多个工作区的路径时，必须设置GOBIN，否则无法成功安装Go程序的可执行文件  </description>
    </item>
    
    <item>
      <title>Go JSON</title>
      <link>https://blog.v5u.win/post/go-json/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/go-json/</guid>
      <description>标准库
encoding/json、encoding/xml、encoding/asn1  Model
type Movie struct { Title string Year int `json:&amp;quot;released&amp;quot;` Color bool `json:&amp;quot;color,omitempty&amp;quot;` Actors []string } // 赋值 var movies = []Movie{ {Title: &amp;quot;Casablanca&amp;quot;, Year: 1942, Color: false, Actors: []string{&amp;quot;Humphrey Bogart&amp;quot;, &amp;quot;Ingrid Bergman&amp;quot;}}, {Title: &amp;quot;Cool Hand Luke&amp;quot;, Year: 1967, Color: true, Actors: []string{&amp;quot;Paul Newman&amp;quot;}}, {Title: &amp;quot;Bullitt&amp;quot;, Year: 1968, Color: true, Actors: []string{&amp;quot;Steve McQueen&amp;quot;, &amp;quot;Jacqueline Bisset&amp;quot;}}, }  在编码时，默认使用Go语言结构体的成员名字作为JSON的对象（通过reflect反射技术，我们将在12.6节讨论）。只有导出的结构体成员才会被编码，这也就是我们为什么选择用大写字母开头的成员名称。
即使对应的JSON对象名是小写字母，每个结构体的成员名也是声明为大写字母开头的。因为有些JSON成员名字和Go结构体成员名字并不相同，因此需要Go语言结构体成员Tag来指定对应的JSON名字。同样，在解码的时候也需要做同样的处理，</description>
    </item>
    
    <item>
      <title>go Mac环境配置</title>
      <link>https://blog.v5u.win/post/go-mac%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/go-mac%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</guid>
      <description>在官网下载pkg安装包,点击安装，安装完成后，资源被写入/usr/local/go 目录下
 设置profile文件，我用的zsh，修改~/.zshrc。用bash的同理，修改~/.bash_profile
# go export GOROOT=/usr/local/go export GOPATH=~/dev/go/golib:~/dev/go/project #工作区，存放go源码文件的目录 export GOBIN=~/dev/go/gobin #存放编译后可执行文件的目录 export PATH=$PATH:$GOROOT/bin/:$GOBIN   3.验证，命令行执行go version返回go version go1.11.5 darwin/amd64。go语言环境配置完毕。</description>
    </item>
    
  </channel>
</rss>