<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>KVO on 为吾优</title>
    <link>https://jinyuyoulong.github.io/tags/kvo/</link>
    <description>Recent content in KVO on 为吾优</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Tue, 15 Mar 2016 11:02:37 +0000</lastBuildDate>
    
	<atom:link href="https://jinyuyoulong.github.io/tags/kvo/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>正确的使用KVO</title>
      <link>https://jinyuyoulong.github.io/post/ios-kvo/</link>
      <pubDate>Tue, 15 Mar 2016 11:02:37 +0000</pubDate>
      
      <guid>https://jinyuyoulong.github.io/post/ios-kvo/</guid>
      <description>KVO，全称为Key-Value Observing，是iOS中的一种设计模式，用于检测对象的某些属性的实时变化情况并作出响应。网上广为流传普及的一个例子是利用KVO检测股票价格的变动，例如这里。这个例子作为扫盲入门还是可以的，但是当应用场景比较复杂时，里面的一些细节还是需要改进的，里面有多个地方存在crash的危险。本文旨在逐步递进深入地探讨出一种目前比较健壮稳定的KVO实现方案，弥补网上大部分教程的不足！
首先，假设我们的目标是在一个UITableViewController内对tableview的contentOffset进行实时监测，很容易地使用KVO来实现为。 在初始化方法中加入：
[_tableView addObserver:self forKeyPath:@&amp;quot;contentOffset&amp;quot; options:NSKeyValueObservingOptionNew context:nil]; `&amp;lt;/pre&amp;gt; 在dealloc中移除KVO监听： &amp;lt;pre&amp;gt;`[_tableView removeObserver:self forKeyPath:@&amp;quot;contentOffset&amp;quot; context:nil]; `&amp;lt;/pre&amp;gt; 添加默认的响应回调方法： &amp;lt;pre&amp;gt;`- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context { [self doSomethingWhenContentOffsetChanges]; } `&amp;lt;/pre&amp;gt; 好了，KVO实现就到此完美结束了，拜拜。。。开个玩笑，肯定没这么简单的，这样的代码太粗糙了，当你在controller中添加多个KVO时，所有的回调都是走同上述函数，那就必须对触发回调函数的来源进行判断。判断如下： &amp;lt;pre&amp;gt;`- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context { if (object == _tableView &amp;amp;amp;&amp;amp;amp; [keyPath isEqualToString:@&amp;quot;contentOffset&amp;quot;]) { [self doSomethingWhenContentOffsetChanges]; } } `&amp;lt;/pre&amp;gt; 你以为这样就结束了吗？答案是否定的！我们假设当前类(在例子中为UITableViewController)还有父类，并且父类也有自己绑定了一些其他KVO呢？我们看到，上述回调函数体中只有一个判断，如果这个if不成立，这次KVO事件的触发就会到此中断了。但事实上，若当前类无法捕捉到这个KVO，那很有可能是在他的superClass，或者super-superClass...中，上述处理砍断了这个链。合理的处理方式应该是这样的： &amp;lt;pre&amp;gt;`- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context { if (object == _tableView &amp;amp;amp;&amp;amp;amp; [keyPath isEqualToString:@&amp;quot;contentOffset&amp;quot;]) { [self doSomethingWhenContentOffsetChanges]; } else { [super observeValueForKeyPath:keyPath ofObject:object change:change context:context]; } }  这样就结束了吗？答案仍旧是否定的。潜在的问题有可能出现在dealloc中对KVO的注销上。KVO的一种缺陷(其实不能称为缺陷，应该称为特性)是，当对同一个keypath进行两次removeObserver时会导致程序crash，这种情况常常出现在父类有一个kvo，父类在dealloc中remove了一次，子类又remove了一次的情况下。不要以为这种情况很少出现！当你封装framework开源给别人用或者多人协作开发时是有可能出现的，而且这种crash很难发现。不知道你发现没，目前的代码中context字段都是nil，那能否利用该字段来标识出到底kvo是superClass注册的，还是self注册的？</description>
    </item>
    
  </channel>
</rss>