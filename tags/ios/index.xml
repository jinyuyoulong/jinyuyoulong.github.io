<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>iOS on 为吾优</title>
    <link>https://blog.v5u.win/tags/ios/</link>
    <description>Recent content in iOS on 为吾优</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Wed, 05 Jun 2019 10:37:16 +0800</lastBuildDate>
    
	<atom:link href="https://blog.v5u.win/tags/ios/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>iOS SwiftUI</title>
      <link>https://blog.v5u.win/post/ios-swiftui/</link>
      <pubDate>Wed, 05 Jun 2019 10:37:16 +0800</pubDate>
      
      <guid>https://blog.v5u.win/post/ios-swiftui/</guid>
      <description>[TOC]
什么是swiftUI？ Apple的解释：
 更好的应用。更少的代码。
 SwiftUI是一种创新的，非常简单的方法，可以通过Swift的强大功能在所有Apple平台上构建用户界面。仅使用一组工具和API为任何Apple设备构建用户界面。SwiftUI具有易于阅读和自然编写的声明式Swift语法，可与新的Xcode设计工具无缝协作，使您的代码和设计完美同步。自动支持动态类型，暗模式，本地化和可访问性意味着您的第一行SwiftUI代码已经是您编写过的最强大的UI代码。
声明性语法 SwiftUI使用声明性语法，因此您可以简单地说明您的用户界面应该做什么。例如，您可以编写需要包含文本字段的项目列表，然后描述每个字段的对齐方式，字体和颜色。您的代码比以前更简单，更易于阅读，从而节省您的时间和维护。
import SwiftUI struct Content : View { @State var model = Themes.ListModel var body: some View { List(model.items,action: model.selectItem){ item in Image(item.image) VStack(alignment: .leading){ Text(item.title) Text(item.subtitle) .color(.gray) } } } }  这种声明式风格甚至适用于复杂的概念，如动画。轻松地将动画添加到几乎任何控件中，并选择只有几行代码的即用型效果集合。在运行时，系统会处理创建平滑移动所需的所有步骤，甚至可以处理中断以保持应用稳定。通过动画这么简单，您将寻找新的方法来让您的应用程序活跃起来。
设计工具 Xcode 11包含直观的新设计工具，使得使用SwiftUI构建界面就像拖放一样简单。当您在设计画布中工作时，您编辑的所有内容都与相邻编辑器中的代码完全同步。在您键入时，代码会立即显示为预览，您对该预览所做的任何更改都会立即显示在您的代码中。Xcode会立即重新编译您的更改，并将其插入到应用程序的运行版本中，始终可见且可编辑。
拖放。只需拖动画布上的控件即可在用户界面中排列组件。单击以打开检查器以选择字体，颜色，对齐方式和其他设计选项，并使用光标轻松重新排列控件。许多这些可视化编辑器也可以在代码编辑器中使用，因此您可以使用检查器为每个控件发现新的修改器，即使您更喜欢手动编码界面部分。您还可以从库中拖动控件并将其拖放到设计画布上或直接放在代码上。
动态更换。Swift编译器和运行时完全嵌入到Xcode中，因此您的应用程序将不断构建和运行。您看到的设计画布不仅仅是您的用户界面的近似 - 它是您的实时应用程序。Xcode可以直接在您的实时应用程序中使用“动态替换”交换已编辑的代码，这是Swift中的一项新功能。
预览。您现在可以创建任何SwiftUI视图的一个或多个预览以获取示例数据，并配置用户可能看到的几乎任何内容，例如大字体，本地化或暗模式。预览还可以在任何设备和任何方向上显示您的UI。
所有Apple平台都是原生的 SwiftUI建立在数十年创建世界上最具创新性和直观的用户界面的经验之上。用户喜欢Apple生态系统的所有内容，例如控件和特定于平台的体验，都会在您的代码中呈现出来。SwiftUI是真正的原生，因此您的应用程序可以通过少量代码和交互式设计画布直接访问每个平台的成熟技术。
对开发者和公司的影响 通过swiftUI的发布可以看到，Apple 在逐步拜托对 Objective-C &amp;amp; Cocoa 的依赖，将精力和资源倾斜到swift语言上，这一次是对UIKit的摆脱。以 Apple 一贯的强势政策，很有可能后期会逐步放弃对 Objective-C 的持续优化(事实上有证据表明已经开始了)和App Store 上的政策制裁。以到达逐步引导开发者加入到新的平台上，这是在之前有过先例的：比如Mac OS从 power-pc 架构转到 x86架构.这将会是一个逐步渐进的过程，但是不会太长最多一两年，并且改变不可逆。</description>
    </item>
    
    <item>
      <title>iOS8.3发布了Swift 1.2带来哪些新变化</title>
      <link>https://blog.v5u.win/post/ios-ios8.3-swift-changed/</link>
      <pubDate>Tue, 14 Apr 2015 14:59:50 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/ios-ios8.3-swift-changed/</guid>
      <description>原文&amp;nbsp;&amp;nbsp;http://www.cnblogs.com/yuyongjian/p/4371400.html
苹果前几日在面向开发者推送iOS 8.3 Beta的同时，还发布了版本号为6D520o的Xcode 6.3 Beta，其中便包含了iOS 8.3 Beta和OS X v10.10 SDK，并进一步提升了Swift与Objective-C代码的交互性，而Swift业已更新至1.2版本。@未来眼之老码团队第一时间翻译了完整的Release Note。共计50多处改动，同时修改了Objective-c的语法，足见苹果对Swift语言的重视。
从&amp;nbsp;Xcode 6.3 Beta Release Notes&amp;nbsp;看出，Xcode 6.3 Beta包含了很多颇为值得开发者期待的改变，共计50多处改动，同时修改了Objective-C的语法，足见苹果对Swift语言的重视。而其代码迁移工具可以帮助开发者将其代码从Swift 1.1（Xcode 6.1）升级至Swift 1.2（Xcode 6.3），具体执行编辑菜单（Edit）-&amp;gt;转换（Convert）-至（To）Swift1.2即可。 具体更新如下：
Swift语言的增强
 Swift现在支持目标增量编译，例如当一个文件改变时不会重新编译Target中的每一个文件。这个基于固有依赖分析。所以你依然会看到有很多文件在必要情况下被重编。如果你发现需要重编但没有重编的情况，请报一个Bug出来。清理Target后再编，会按照往常的流程进行。
 增加了一个新的Set数据类型，它提供了元素唯一化，且有完整语义的通用数据类型集合。它和NSSet类型桥接，提供和Array和Dictionary相类似的功能。
 if let语句现在被扩展为可以支持多条条件判断：if&amp;nbsp;let&amp;nbsp;a&amp;nbsp;=&amp;nbsp;foo(),&amp;nbsp;b&amp;nbsp;=&amp;nbsp;bar()&amp;nbsp;where&amp;nbsp;a&amp;nbsp;&amp;lt;&amp;nbsp;b,&amp;nbsp;&amp;nbsp; let&amp;nbsp;c&amp;nbsp;=&amp;nbsp;baz()&amp;nbsp;{&amp;nbsp;&amp;nbsp; &amp;nbsp;}
  它允许你测试多种选择，并且包含一个bool判断。当然这种情况不包含嵌套判断。
let常量现在生成时不需要立即初始化，新的规则是let常量必须在被首次使用前初始化即可（和var一样）。或者说它只能被初始化，也就是说在初始化后它不能再被改变或者重新赋值，可用的模式如下： let&amp;nbsp;x:&amp;nbsp;SomeThing&amp;nbsp;&amp;nbsp; &amp;nbsp;if&amp;nbsp;condition&amp;nbsp;{&amp;nbsp;&amp;nbsp; &amp;nbsp;x&amp;nbsp;=&amp;nbsp;foo()&amp;nbsp;&amp;nbsp; &amp;nbsp;}&amp;nbsp;else&amp;nbsp;{&amp;nbsp;&amp;nbsp; &amp;nbsp;x&amp;nbsp;=&amp;nbsp;bar()&amp;nbsp;&amp;nbsp; &amp;nbsp;}&amp;nbsp;&amp;nbsp; &amp;nbsp;use(x)
这个正常的来说需要var变量用法，尽管这里没有任何修改的操作。
 “Static”静态方法和属性现在允许在class中使用(作为“class final”的别名)。你现在可以在类中声明一个静态存储属性，它享有全局存储空间和首次使用再初始化的惰性构造功能。协议Protocal现在会声明一个static的类型要求而不是声明一个class的要求。
 对于表达式闭包的类型引用有了几点改进：
   含有单返回语句的闭包现在类型检查时以单表达式闭包处理。
 匿名的且含有非空返回类型的单表达式现在可以用在Void上下文中。
 多表达式的闭包类型的情况可能无法被类型推断出来，这归功于缺乏返回类型的情况能被正确的推断出来。
   Swift中的枚举类型现在可以通过@objc关键字导出到Objective-C中。@objc的枚举类型必须定义一个整型的原始类型，并且该枚举不能泛型化或者不能使用关联值。由于Objective-C中的枚举类型没有命名空间，所以导出到Objective-C中的枚举类型以枚举名字和case项目名字的组合的方式使用。 比如在Swift中的声明：@objc&amp;nbsp;&amp;nbsp; &amp;nbsp;enum&amp;nbsp;Bear:&amp;nbsp;Int&amp;nbsp;{&amp;nbsp;&amp;nbsp; &amp;nbsp;case&amp;nbsp;Black,&amp;nbsp;Grizzly,&amp;nbsp;Polar&amp;nbsp;&amp;nbsp; &amp;nbsp;}  导出到Objective-C： typedef&amp;nbsp;NS_ENUM(NSInteger,&amp;nbsp;Bear)&amp;nbsp;{&amp;nbsp;&amp;nbsp; BearBlack,&amp;nbsp;BearGrizzly,&amp;nbsp;BearPolar&amp;nbsp;&amp;nbsp; };</description>
    </item>
    
    <item>
      <title>App Store 上架流程</title>
      <link>https://blog.v5u.win/post/ios-app-store-public/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/ios-app-store-public/</guid>
      <description>App Store上架流程
 申请开发者账号 登录开发者网站，注册cer APP ID， profile (xcode 只能解决测试证书配置) 登录iTunes connection网站，注册APP xcode选择distribution profile 证书，设置build id，打包 上传到App Store。 设置APP story 发布信息，提交等待审核  </description>
    </item>
    
  </channel>
</rss>