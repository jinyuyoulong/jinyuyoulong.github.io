<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>为吾优</title>
    <link>https://blog.v5u.win/</link>
    <description>Recent content on 为吾优</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Mon, 01 Jul 2019 15:05:09 +0800</lastBuildDate>
    
	<atom:link href="https://blog.v5u.win/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Nginx 动态生成缩略图</title>
      <link>https://blog.v5u.win/post/system-nginx/</link>
      <pubDate>Mon, 01 Jul 2019 15:05:09 +0800</pubDate>
      
      <guid>https://blog.v5u.win/post/system-nginx/</guid>
      <description>[TOC]
有的时候要生成大量尺寸的缩图，事先不知道有哪些尺寸，所以可以用php动态生成；
1.在nginx中配置
location ~ ..(gif|jpg|jpeg|png|bmp)$ { if ( !-f $request_filename) { rewrite ^(.)/(.*)(\d+)(\d+).(gif|jpg|jpeg|png|bmp) /ImageTransferController.php?s=1/2_3_4.5; } expires 30d; }   完善 ImageTransferController.php 文件  </description>
    </item>
    
    <item>
      <title>免费读书笔记</title>
      <link>https://blog.v5u.win/post/read-%E5%85%8D%E8%B4%B9-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Fri, 28 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/read-%E5%85%8D%E8%B4%B9-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</guid>
      <description>​ 之前我们所学习的营销学，财会学，都是建立在收费理论之上的，因为资源是稀缺的，所以就必然有选择，有选择机会有机会成本，价格的下限是生产者的平均成本，而上限是消费者的意愿，同行如果激烈竞争，那么价格就会趋近于平均成本。而垄断或者供不应求，就会接近于意愿价格。而互联网世界的出现，让免费成为了一种新的模式，这种做法完全是违背之前所有商业原则的，但他就这么出现了，而且越来越广泛的存在。已经让很多商业活动被彻底颠覆，一些企业被免费的浪潮完全淘汰出局了。
​ 免费这本书，是继长尾理论后，安德森对于互联网经济的延伸思考，是一脉相承，长尾理论是互联网1.0的话，那么免费就是互联网范围经济的2.0版本，前者是从品类角度的颠覆，后者是从价格上的总结。
​ 免费到底是什么意思，也许并不是大家理解的那样，不要钱，经济学家把它叫做交叉补贴，交叉补贴可以有很多不同的方式，比如用付费产品来补贴免费产品，用日后的付费来补贴当前免费，由付费人群来给不付费人群补贴。世界就是一个交叉补贴的大舞台，你在浏览免费的内容的时候，其实也帮别人刷了流量和信誉。而流量和信誉会变成别人的收入。
​ 如果要把交叉补贴分类，主要有4类免费。
​ 第一种，直接交叉补贴，用一款免费的东西吸引你的注意，然后把成本摊到别的商品上。
​ 第二种，三方市场，也就是我们常说的，羊毛出在猪身上，让狗来买单，你提供免费的内容，服务，软件，然后让广告商来交费。在这个模式中，广告商就是一个第三方的身份。
​ 第三种，免费加收费模式，就是刚才我们讲的游戏模式酒吧模式，当然这也不止于游戏，很多软件也是如此，免费版只提供基础数据，而收费版则提供专业服务。免费加收费模式的精髓就是提供差别化服务，一方面赚人气，另一方面赚钱，一般这个模式遵循5%定律，也就是5%的付费用户，形成了一个网站全部的收入来源。20个人中，只有1个人是付费的，其他19个是免费的，由于免费，所以这部分用户也没啥需求，所以对免费用户的服务成本其实非常低，趋近于0，而只要服务好那个付费用户就可以了。
​ 第四种，非货币市场，也就是纯粹不为赚钱而存在的产品，比如维基百科，他就没有利益驱动，就是一些人在进行知识共享。纯粹的利他主义。
​ 政府提供的服务也是一种交叉补贴，政府的钱来自于集体纳税人，但他的一些公共设施，只能惠及一部分人民生，所以他并不是直接的，一对一的，而是间接的，错配的。看似政府提供了很多免费的东西，但背后都有其他人买单。
​ 昨天我们从世界经济供给的角度分析了，世界随着技术的进步，商品已经变得越来越充裕，资源的价格正在逐渐降低。未来这种趋势只能更快，而不会逆转。那么今天我们再来从需求的角度来分析下免费，免费会让你忽略成本，从而减少纠结和犹豫。
​ 免费是一种心态，但是花一分钱订阅，其实又是另外一种心态，一分钱肯定是无足重轻，但是他却产生了一层新的意思，那就是在脑海中引入了成本的概念，也就是说无论多少钱，你会马上想到，这钱花的是不是值，但如果是完全免费的话，你就不会再考虑这个问题。
​ 所以免费是一个终极策略，一旦你免费了，别人就不会再超越你，顶多跟你比肩。如果你是市场中唯一一个免费的人，那么你很快就会获取大量的市场份额，当年周鸿祎就是这么干死杀毒软件的。
​ 其实，商业之中，只有两个市场， 一个是免费市场，另一个是非免费市场，他们有着天壤之别，如果你收费，都会有一条营收曲线，收费越低，销量越高。而你的利益会有一个平衡点，所以企业家经常思考的问题就是如何在销量与收费之间取舍，达到利益最大化的目的。但是一旦你免费，那么销量就会趋近于无穷大。甚至要比只卖1分钱，大的多的多。
​ 所以便宜和免费之间是有区别的，在收费的世界里你需要苦心经营去抓住每一个顾客的体验，但免费会开创另一个市场，免费的生意很好做，而收费的生意很难做下去。
​ 有一家网站叫做扎珀斯，是卖鞋的电商，他的做法也是免运费，而且一次会给你带好几个号码的鞋子，你试穿合不合脚，留下最合适的，把不合适的退回去即可。但他们家的鞋子比同类电商略贵一点，显然这种服务的价格已经包含在了商品之中。但对于很多用户来说，买鞋最大的风险就是不合脚，而他们的做法，刚好规避了这个风险，而且还让你有一种更好的体验。
​ 时间和金钱，往往是人生的两个极端的维度，如果一个年轻人，他可能很穷，但他却有很多的时间，而岁数大了，你可能会有很多钱是你人生财富的巅峰，但留给你的时间却不多了。商业社会也是如此，像乔布斯说，有些人可能会花很多时间去找盗版音乐，从而省钱，但也有人会选择花钱下载音质更好的正版音乐。
​ 信息对我们来说，既贵又便宜，说他贵是因为他很宝贵，而说他便宜是他在网络中的传输成本持续下降已经接近于0，所以最后的结论就是充裕的信息将变得免费，而稀缺的信息将变得昂贵。或者说，人人都能得到的大众版信息将变得免费，而客户定制化的，对你有独特意义的信息将变得十分昂贵。
价格等于边际成本
​ 现在美国人还有一种玩法，把教科书也可以免费，而且把它变成开源模式，也就是先把教科书放在线上，然后任何人都可以对教科书进行再加工，形成自己的新内容，你也可以销售你重新编辑后的教科书，估计很多学渣是愿意买学霸笔记版教科书的。这就形成了一个良性的循环，有利于教科书的不断优化。学霸们还可以通过这种优化教科书的方式，赚点外快。
​ 免费经济已经对经济学造成了冲击，信息替代了货币，个体注意力替代了一般等价物，信息市场替代了股票市场。钞票不再是市场上最重要的交易信号。相反两个非货币因素，开始被大家重视，也就是注意力经济和声誉经济。
​ 其实这也很好理解，现在信息大爆炸，他消耗了我们太多的注意力，所以让我们的注意力开始变得稀缺起来，稀缺的东西通常就会很贵。
​ 而在游戏中，也发生着金钱与时间的转换，年轻的玩家时间充裕，所以他们会选择多做任务多练级，然后打出好装备，交换给那些没有时间练级的中年玩家，他们会选择用金钱，来交换其他人的时间。游戏的设计者就是要促进这种交换，力求免费用户和付费用户的平衡。
​ 昨天我们说到了浪费有时候也是一种美德。作者说了一句很关键的话，匮乏让大规模更具价值，而充裕让多样化更具价值，在上个世纪，我们擅长匮乏思维，而这个世纪，我们要慢慢的适应充裕思维，也就是多样化思维。
​ 总结一下，匮乏经济，规则是准入制，而且是主观自大的，比如官媒永远就是自说自话，决策过程是自上而下的，管理风格也是命令加控制，充裕经济则刚好相反，他是只要不禁止，所有人都可以参与，是一种平等模式，有需要的才是最好的，他的决策过程是从下往上的，智慧来自民间，而他的管理是不受控制的。从趋势上来讲，充裕经济代表未来，正在杀死匮乏经济。
作者说，免费经济的前沿阵地在中国和巴西，而理由就是，我们这里盗版横行
​ 世界依然在往前发展，作者说很可能未来会出现后匮乏时代，也即是我们走的太远，以至于忘记了来时的路，
​ 所以充裕带来了免费，但后匮乏可能又会让以前的一些东西变得昂贵起来，比如现在大家又讲究吃有机蔬菜，吃人工散养的有机肉类，穿手工制作的布鞋，和衣服。
​ 21世纪已经滚滚而来，商业模式也已经发生了全方位的变化，很多人到现在都不知道为什么自己的生意每况愈下，因为你落伍了，人家玩的东西你已经看不懂了。别人都在免费吸引用户，而你还在做单品销售，这就整整差了一个时代。所以各位企业家，各位职场精英，是时候给自己洗洗脑了，看未来的生意该怎么做，你们公司的产品能够免费吗？能够付费补贴免费吗？能够引入第三方付费吗？能够转移付费吗？</description>
    </item>
    
    <item>
      <title>Go Toml</title>
      <link>https://blog.v5u.win/post/go-toml/</link>
      <pubDate>Wed, 26 Jun 2019 15:33:44 +0800</pubDate>
      
      <guid>https://blog.v5u.win/post/go-toml/</guid>
      <description>[TOC]
常用的配置文件有：ini, ymal, json, toml
说一下为什么要选择 toml。toml 格式是最新公布的配置文件格式，由GitHub创始人 Tom Preston-Werner 发明。TOML 的目标是成为一个极简的配置文件格式。TOML 被设计成可以无歧义地被映射为哈希表，从而被多种语言解析。
TOML的优势  可以添加注释 没有缩进要求 表达简洁，丰富。 大小写敏感  写法 config.toml [app] #app名称 name = &amp;quot;project-web&amp;quot; url = &amp;quot;http://localhost&amp;quot; port = &amp;quot;:8080&amp;quot; debug = false [database] dirver = &amp;quot;mysql&amp;quot; [mysql] dbname = &amp;quot;@tcp(127.0.0.1:3306)/superstar?charset=utf8&amp;quot; username = &amp;quot;root&amp;quot; password = &amp;quot;333&amp;quot; [website] static_uri = &amp;quot;/static&amp;quot; site_title = &amp;quot;后台管理&amp;quot; copy_right = &amp;quot;&amp;lt;small&amp;gt;&amp;amp;copy;2019&amp;lt;/small&amp;gt;&amp;quot; [image] image_lib = &amp;quot;Imagick&amp;quot; # GD || Imagick image_path = &amp;quot;.</description>
    </item>
    
    <item>
      <title>开源贡献者盟约</title>
      <link>https://blog.v5u.win/post/system-%E8%B4%A1%E7%8C%AE%E8%80%85%E7%9B%9F%E7%BA%A6/</link>
      <pubDate>Tue, 25 Jun 2019 15:38:20 +0800</pubDate>
      
      <guid>https://blog.v5u.win/post/system-%E8%B4%A1%E7%8C%AE%E8%80%85%E7%9B%9F%E7%BA%A6/</guid>
      <description>[TOC]
参与者公约 我们的保证 为了促进一个开放透明且友好的环境，我们作为贡献者和维护者保证：无论年龄、种族、民族、性别认同和表达（方式）、体型、身体健全与否、经验水平、国籍、个人表现、宗教或性别取向，参与者在我们项目和社区中都免于骚扰。
我们的标准 有助于创造正面环境的行为包括但不限于：
 使用友好和包容性语言 尊重不同的观点和经历 耐心地接受建设性批评 关注对社区最有利的事情 友善对待其他社区成员  身为参与者不能接受的行为包括但不限于：
 使用与性有关的言语或是图像，以及不受欢迎的性骚扰 捣乱/煽动/造谣的行为或进行侮辱/贬损的评论，人身攻击及政治攻击 公开或私下的骚扰 未经许可地发布他人的个人资料，例如住址或是电子地址 其他可以被合理地认定为不恰当或者违反职业操守的行为  我们的责任 项目维护者有责任为「可接受的行为」标准做出诠释，以及对已发生的不被接受的行为采取恰当且公平的纠正措施。
项目维护者有权利及责任去删除、编辑、拒绝与本行为标准有所违背的评论 (comments)、提交 (commits)、代码、wiki 编辑、问题 (issues) 和其他贡献，以及项目维护者可暂时或永久性的禁止任何他们认为有不适当、威胁、冒犯、有害行为的贡献者。
使用范围 当一个人代表该项目或是其社区时，本行为标准适用于其项目平台和公共平台。
代表项目或是社区的情况，举例来说包括使用官方项目的电子邮件地址、通过官方的社区媒体账号发布或线上或线下事件中担任指定代表。
该项目的呈现方式可由其项目维护者进行进一步的定义及解释。
强制执行 可以通过[在此放入EMAIL]，来联系项目团队来举报滥用、骚扰或其他不被接受的行为。
任何维护团队认为有必要且适合的所有投诉都将进行审查及调查，并做出相对应的回应。项目小组有对事件回报者有保密的义务。具体执行的方针近一步细节可能会单独公布。
没有切实地遵守或是执行本行为标准的项目维护人员，可能会因项目领导人或是其他成员的决定，暂时或是永久地取消其参与资格。
来源 本行为标准改编自贡献者公约，版本 1.4 可在此观看https://www.contributor-covenant.org/zh-cn/version/1/4/code-of-conduct.html</description>
    </item>
    
    <item>
      <title>Go Iris Redis</title>
      <link>https://blog.v5u.win/post/go-iris-redis/</link>
      <pubDate>Tue, 11 Jun 2019 10:15:20 +0800</pubDate>
      
      <guid>https://blog.v5u.win/post/go-iris-redis/</guid>
      <description>[TOC]
iris 中使用 Redis iris 内置对 Redis 的支持，但是她和 session 结合的比较紧密，比如每一个方法传参都大部分都有 sid，在当前文件 database.go 找了半天没找到在哪里定义了 sid，func (db *Database) Get(sid string, key string) (value interface{})
只能推断是 sessionId，果然在 Session struct 中发现了 sid。
Session struct { sid string isNew bool flashes map[string]*flashMessage mu sync.RWMutex // for flashes. Lifetime LifeTime provider *provider }  所以可以下结论，iris中必须使用内置的 Redis 是只对 session 的配合支持，如果需要单独操作 Redis 数据库，则需要使用其他的第三方库来操作，比如：redigo 和 go-redis/redis</description>
    </item>
    
    <item>
      <title>iOS SwiftUI</title>
      <link>https://blog.v5u.win/post/ios-swiftui/</link>
      <pubDate>Wed, 05 Jun 2019 10:37:16 +0800</pubDate>
      
      <guid>https://blog.v5u.win/post/ios-swiftui/</guid>
      <description>[TOC]
什么是swiftUI？ Apple的解释：
 更好的应用。更少的代码。
 SwiftUI是一种创新的，非常简单的方法，可以通过Swift的强大功能在所有Apple平台上构建用户界面。仅使用一组工具和API为任何Apple设备构建用户界面。SwiftUI具有易于阅读和自然编写的声明式Swift语法，可与新的Xcode设计工具无缝协作，使您的代码和设计完美同步。自动支持动态类型，暗模式，本地化和可访问性意味着您的第一行SwiftUI代码已经是您编写过的最强大的UI代码。
声明性语法 SwiftUI使用声明性语法，因此您可以简单地说明您的用户界面应该做什么。例如，您可以编写需要包含文本字段的项目列表，然后描述每个字段的对齐方式，字体和颜色。您的代码比以前更简单，更易于阅读，从而节省您的时间和维护。
import SwiftUI struct Content : View { @State var model = Themes.ListModel var body: some View { List(model.items,action: model.selectItem){ item in Image(item.image) VStack(alignment: .leading){ Text(item.title) Text(item.subtitle) .color(.gray) } } } }  这种声明式风格甚至适用于复杂的概念，如动画。轻松地将动画添加到几乎任何控件中，并选择只有几行代码的即用型效果集合。在运行时，系统会处理创建平滑移动所需的所有步骤，甚至可以处理中断以保持应用稳定。通过动画这么简单，您将寻找新的方法来让您的应用程序活跃起来。
设计工具 Xcode 11包含直观的新设计工具，使得使用SwiftUI构建界面就像拖放一样简单。当您在设计画布中工作时，您编辑的所有内容都与相邻编辑器中的代码完全同步。在您键入时，代码会立即显示为预览，您对该预览所做的任何更改都会立即显示在您的代码中。Xcode会立即重新编译您的更改，并将其插入到应用程序的运行版本中，始终可见且可编辑。
拖放。只需拖动画布上的控件即可在用户界面中排列组件。单击以打开检查器以选择字体，颜色，对齐方式和其他设计选项，并使用光标轻松重新排列控件。许多这些可视化编辑器也可以在代码编辑器中使用，因此您可以使用检查器为每个控件发现新的修改器，即使您更喜欢手动编码界面部分。您还可以从库中拖动控件并将其拖放到设计画布上或直接放在代码上。
动态更换。Swift编译器和运行时完全嵌入到Xcode中，因此您的应用程序将不断构建和运行。您看到的设计画布不仅仅是您的用户界面的近似 - 它是您的实时应用程序。Xcode可以直接在您的实时应用程序中使用“动态替换”交换已编辑的代码，这是Swift中的一项新功能。
预览。您现在可以创建任何SwiftUI视图的一个或多个预览以获取示例数据，并配置用户可能看到的几乎任何内容，例如大字体，本地化或暗模式。预览还可以在任何设备和任何方向上显示您的UI。
所有Apple平台都是原生的 SwiftUI建立在数十年创建世界上最具创新性和直观的用户界面的经验之上。用户喜欢Apple生态系统的所有内容，例如控件和特定于平台的体验，都会在您的代码中呈现出来。SwiftUI是真正的原生，因此您的应用程序可以通过少量代码和交互式设计画布直接访问每个平台的成熟技术。
对开发者和公司的影响 通过swiftUI的发布可以看到，Apple 在逐步拜托对 Objective-C &amp;amp; Cocoa 的依赖，将精力和资源倾斜到swift语言上，这一次是对UIKit的摆脱。以 Apple 一贯的强势政策，很有可能后期会逐步放弃对 Objective-C 的持续优化(事实上有证据表明已经开始了)和App Store 上的政策制裁。以到达逐步引导开发者加入到新的平台上，这是在之前有过先例的：比如Mac OS从 power-pc 架构转到 x86架构.这将会是一个逐步渐进的过程，但是不会太长最多一两年，并且改变不可逆。</description>
    </item>
    
    <item>
      <title>Go 单例</title>
      <link>https://blog.v5u.win/post/go-%E5%8D%95%E4%BE%8B/</link>
      <pubDate>Mon, 27 May 2019 00:00:00 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/go-%E5%8D%95%E4%BE%8B/</guid>
      <description>为什么使用单例？
由于Go的多协程机制，当只是单核的时候，变量还不会出现问题，但是当设置成多核之后，就会涉及到变量的作用域问题，只用普通方式常见的变量在其他线程上会得到错误的方法
一、 sync.Once用法
在Go中有一个简洁的方法就是使用sync.Once，它可以在多协程中起到控制作用。实现起来也非常简单。
var ( once sync.Once instance *SingleTon ) func GetInstance(str string) *SingleTon { once.Do(func() { instance = &amp;amp;SingleTon{Attr: str} }) return instance }  二、使用加锁机制 在Go语言中有个基础对象sync.Mutex，可以实现协程之间的同步逻辑。
var mu sync.Mutex func GetInstance() *SingleTon { mu.Lock() defer mu.Unock() if Instance == nil { instance = &amp;amp;SingleTon{} } return instance }  三、简单粗暴模式. 这种方式实现起来特别简单，直接判断一个实力是不是为nil， 如果是，则新生成；否则返回已有的。但它和多数语言一样，只适合用在单线程。
type SingleTon struct { } var instance *SingleTon func GetInstance() *SingleTon { if Instance == nil { instance = &amp;amp;SingleTon{} } return instance }  测试代码如下，从运行结果来看，都是一致的。</description>
    </item>
    
    <item>
      <title>Go DI LoC研究</title>
      <link>https://blog.v5u.win/post/go-di-loc/</link>
      <pubDate>Fri, 24 May 2019 00:00:00 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/go-di-loc/</guid>
      <description>依赖注入，控制反转
目的：实现模块与项目的解耦
实现流程
首先模块有指针，其次DI拿到指针，再次DI将指针赋给调用者
共调研了三个框架：iris内置的di&amp;amp;mvc，uber-dig，google/wire
最终决定使用 wire
google DI 框架 wire 它通过使用代码生成构建容器来避免运行时反射。
用法：
// file main.go package main import &amp;quot;bytes&amp;quot; type Logger struct{} func (logger *Logger) Log(message string) { println(message) } type HttpClient struct { logger *Logger } func (client *HttpClient) Get(url string) string { client.logger.Log(&amp;quot;Getting &amp;quot; + url) return &amp;quot;my response from &amp;quot; + url } func NewHttpClient(logger *Logger) *HttpClient { return &amp;amp;HttpClient{logger} } type ConcatService struct { logger *Logger client *HttpClient } func NewConcatService(logger *Logger, client *HttpClient) *ConcatService { return &amp;amp;ConcatService{logger, client} } func (service *ConcatService) GetAll(urls .</description>
    </item>
    
    <item>
      <title>imagick</title>
      <link>https://blog.v5u.win/post/go-imagick/</link>
      <pubDate>Fri, 17 May 2019 00:00:00 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/go-imagick/</guid>
      <description>Go语言imagick 使用总结 imagick 是一个开源的 c语言图片处理库，所以需要本地安装，并且配置 CGO
Mac 安装imagic
brew install imagemagick
CGO配置
export CGO_CFLAGS_ALLOW=&#39;-Xpreprocessor&#39; #cgo	 Initialize() 和 Terminate 根据ImageMagick C API，Initialize()应该只调用一次来设置使用ImageMagick的资源。这通常在您main()或init()整个应用程序或库中完成。应用程序可以推迟调用以Terminate()拆除ImageMagick资源。
多次调用特殊方法，导致常见的问题，这是一个错误对于Initialize，和Terminate来说，如死机或丢失代理。除了在程序中对ImageMagick的绝对需求外，不要使用Terminate。
内存管理 由于这是一个CGO绑定，并且Go GC不管理由C API分配的内存，因此必须使用Terminate（）和Destroy（）方法。
通过New*构造函数（MagickWand，DrawingWand，PixelIterator，PixelWand，&amp;hellip;）创建的类型由Go GC通过使用终结器进行管理。
如果使用struct literals，则应手动释放资源：
package main import &amp;quot;github.com/gographics/imagick/imagick&amp;quot; func main() { imagick.Initialize() // Schedule cleanup defer imagick.Terminate() var err error mw := imagick.NewMagickWand() defer mw.Destroy() err = mw.ReadImage(&amp;quot;header.png&amp;quot;) if err != nil { panic(err) } // Get original logo size width := mw.</description>
    </item>
    
    <item>
      <title>markdown 常用语法整理</title>
      <link>https://blog.v5u.win/post/system-markdown%E5%8E%9F%E7%90%86/</link>
      <pubDate>Fri, 10 May 2019 00:00:00 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/system-markdown%E5%8E%9F%E7%90%86/</guid>
      <description>Text  1级标题 Text  2级标题 Text  3级标题 Text  4级标题 Text  5级标题 Text  6级标题 有序列表 ul&amp;gt;li  有 序
无序列表 ol&amp;gt;li 无
 序
任务列表 ul&amp;gt;li&amp;gt;input [ ] 任务
 [x] 列表
代码修饰 短代码 &amp;lt;code&amp;gt;
  var name = 代码块 div&amp;gt;pre&amp;gt;span &amp;lt;div&amp;gt; &amp;lt;pre&amp;gt; &amp;lt;span&amp;gt;var&amp;lt;/span&amp;gt; name = 代码块 &amp;lt;/pre&amp;gt; &amp;lt;/div&amp;gt;   &amp;lt;blockquote&amp;gt;&amp;lt;p&amp;gt;块级引用&amp;lt;/p&amp;gt;&amp;lt;/blockquote&amp;gt;
 段落 中间没有空行的连续不断的几行文字被视为一个段落。空一行 作为段落间的分割符
行内格式 删除线 del 标签 加粗 strong 标签 斜体 em 标签</description>
    </item>
    
    <item>
      <title>Go-Authorization</title>
      <link>https://blog.v5u.win/post/go-authorization/</link>
      <pubDate>Mon, 15 Apr 2019 14:52:48 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/go-authorization/</guid>
      <description>接口认证 一般接口开发中有以下常用的几种安全机制：
 用户认证 数字签名 接口加密  用户认证 一般的接口测试工具都会提供一个User Auth/Authorization的选项
 基本认证（Basic Auth） 摘要认证（Digest Auth） OAuth 2.0（最常见，现在的网站接口多数提供此用户认证方式）授权认证方式  接口需要认证：auth=(&amp;ldquo;username&amp;rdquo;,&amp;ldquo;password&amp;rdquo;)
数字签名 在使用 HTTP/SOAP 协议传输数据的时候，签名作为其中一个参数，可以起到关键作用：通过客户的密钥，服务端的密钥匹配；当服务器接收到请求后，同样需要对“signpassword”进行 MD5 加密，然后，比对与调用者传来的 sign 加密串是否一致，从而来鉴别调用者是否有权限使用该接口。
http://127.0.0.1:8000/sign/?a=1&amp;amp;b=2&amp;amp;sign=6648e929329e53e7a91c50ae685a88b5
接口加密 通常接口会使用更复杂一点的方式来进行加密的操作，常见的是AES的使用
AES加密里面有两个关键，一个是key（必须为16,24,32位），一个是VI（必须为16位） 解密：解密者必须要同时知道key和VI才可以解密
参考</description>
    </item>
    
    <item>
      <title>markdown 流程图</title>
      <link>https://blog.v5u.win/post/system-markdown-%E6%B5%81%E7%A8%8B%E5%9B%BE/</link>
      <pubDate>Mon, 15 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/system-markdown-%E6%B5%81%E7%A8%8B%E5%9B%BE/</guid>
      <description> Sequence Alice-&amp;gt;Bob: Hello Bob, how are you? Note right of Bob: Bob thinks Bob--&amp;gt;Alice: I am good thanks!  flow st=&amp;gt;start: Start op=&amp;gt;operation: Your Operation cond=&amp;gt;condition: Yes or No? e=&amp;gt;end st-&amp;gt;op-&amp;gt;cond cond(yes)-&amp;gt;e cond(no)-&amp;gt;op  mermaid graph LR A[Hard edge] --&amp;gt;B(Round edge) B --&amp;gt; C{Decision} C --&amp;gt;|One| D[Result one] C --&amp;gt;|Two| E[Result two]  Gantt %% Example with selection of syntaxes gantt dateFormat YYYY-MM-DD title Adding GANTT diagram functionality to mermaid section A section Completed task :done, des1, 2014-01-06,2014-01-08 Active task :active, des2, 2014-01-09, 3d Future task : des3, after des2, 5d Future task2 : des4, after des3, 5d section Critical tasks Completed task in the critical line :crit, done, 2014-01-06,24h Implement parser and jison :crit, done, after des1, 2d Create tests for parser :crit, active, 3d Future task in critical line :crit, 5d Create tests for renderer :2d Add to mermaid :1d section Documentation Describe gantt syntax :active, a1, after des1, 3d Add gantt diagram to demo page :after a1 , 20h Add another diagram to demo page :doc1, after a1 , 48h section Last section Describe gantt syntax :after doc1, 3d Add gantt diagram to demo page : 20h Add another diagram to demo page : 48h  </description>
    </item>
    
    <item>
      <title>Go gRPC研究总结</title>
      <link>https://blog.v5u.win/post/go-grpc%E7%A0%94%E7%A9%B6%E6%80%BB%E7%BB%93/</link>
      <pubDate>Thu, 11 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/go-grpc%E7%A0%94%E7%A9%B6%E6%80%BB%E7%BB%93/</guid>
      <description>什么是RPC RPC（Remote Procedure Call）—远程过程调用，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。RPC协议假定某些传输协议的存在，如TCP或UDP，为通信程序之间携带信息数据。在OSI网络通信模型中，RPC跨越了传输层和应用层。RPC使得开发包括网络分布式多程序在内的应用程序更加容易。——百度百科
支持环境配置(Mac)
安装protobuf 这是 Google 开源的一套成熟的结构数据序列化机制protocol buffer
brew info protobuf brew install protobuf  检验protobuf安装结果
protoc --version libprotoc 3.5.1  安装第三方包
go mod download github.com/golang/protobuf/proto go mod download github.com/golang/protobuf/protoc-gen-go go mod download google.golang.org/grpc go install github.com/golang/protobuf/protoc-gen-go //编译 protoc-gen-go 可执行文件  创建 protobuf 文件
vi add.proto add some date  生成 gRPC 代码
protoc -I ./protos ./protos/helloworld.proto --go_out=plugins=grpc:helloworld 或 protoc -I . add.proto --go_out=plugins=grpc:.  这生成了 helloworld.pb.go ，包含了我们生成的客户端和服务端类，此外还有用于填充、序列化、提取 HelloRequest 和 HelloResponse 消息类型的类。</description>
    </item>
    
    <item>
      <title>Go modules</title>
      <link>https://blog.v5u.win/post/go-modules/</link>
      <pubDate>Wed, 03 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/go-modules/</guid>
      <description> go modules [TOC]
环境配置  正确配置 GOROOT
 export GOPROXY=&amp;quot;https://athens.azurefd.net&amp;quot; # 微软提供的公共代理，解决golang/x/tools 下载失败
  初始化 同时 确定了项目的绝对目录路径 go mod init v5u.win/projectapi 生成 go.mod 导入包：import &amp;quot;v5u.win/projectapi/src/app/service&amp;quot;
添加依赖 go mod tidy
生成 go.sum 自动添加依赖关系到 go.mod go run main.go
下载依赖包 go mod download github.com/pelletier/go-toml
Tips:  不能在 golib/src 下创建项目 在 Go1.11 版本下，GOPATH 目录中的项目默认是禁用 Go Module 的，需要手动开启 export GOPROXY=&amp;ldquo;https://athens.azurefd.net&amp;quot; // 微软提供的公共代理,也可以以此技术建立自己的公共库 export export GO111MODULE=on // 必须使用module依赖，在src/ 目录下可以使用module  常用命令 go mod tidy //拉取缺少的模块，移除不用的模块。 go mod download //下载依赖包 go mod graph //打印模块依赖图 go mod vendor //将依赖复制到vendor下 go mod verify //校验依赖 go mod why //解释为什么需要依赖 go list -m -json all //依赖详情  </description>
    </item>
    
    <item>
      <title>Go-API 项目模板文档</title>
      <link>https://blog.v5u.win/post/go-api-%E9%A1%B9%E7%9B%AE%E6%A8%A1%E6%9D%BF%E6%96%87%E6%A1%A3/</link>
      <pubDate>Wed, 03 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/go-api-%E9%A1%B9%E7%9B%AE%E6%A8%A1%E6%9D%BF%E6%96%87%E6%A1%A3/</guid>
      <description>项目目录结构规范 PROJECT_NAME ├── README.md //介绍软件及文档入口 ├── bin //编译好的二进制文件,执行./build.sh自动生成，该目录也用于程序打包 ├── build.sh //自动编译的脚本 ├── doc //该项目的文档 ├── pack //打包后的程序放在此处 ├── pack.sh //自动打包的脚本，生成类似xxxx.20170713_14:45:35.tar.gz的文件，放在pack文件下 └── src //该项目的源代码 ├── main //项目主函数 ├── test //测试 ├── app //项目代码 ├── public //公共文件/静态文件 └── vendor //存放go的库 ├── github.com/xxx //第三方库 └── xxx.com/abc //公司内部的公共库  项目的目录结构尽量做到简明、层次清楚。
./app ├── bootstrap	//入口引导文件 ├── cache ├── config	//项目配置 ├── controller	//request请求处理中心 ——&amp;gt; controller ——&amp;gt; Response / view ├── library	//项目工具库 ├── log	//日志 —— 考虑发布目录 ├── middleware	//中间件 ├── model	//data model.</description>
    </item>
    
    <item>
      <title>mac中如何卸载pkg包</title>
      <link>https://blog.v5u.win/post/mac-mac%E4%B8%AD%E5%A6%82%E4%BD%95%E5%8D%B8%E8%BD%BDpkg%E5%8C%85/</link>
      <pubDate>Tue, 19 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/mac-mac%E4%B8%AD%E5%A6%82%E4%BD%95%E5%8D%B8%E8%BD%BDpkg%E5%8C%85/</guid>
      <description>mac中如何卸载pkg包 pkgutil &amp;ndash;pkgs
cd /private/var/db/receipts
ls
lsbom com.apple.pkg.JavaForMacOSX107.bom //查看所有关联文件。</description>
    </item>
    
    <item>
      <title>Go-iris-template</title>
      <link>https://blog.v5u.win/post/go-iris-template/</link>
      <pubDate>Fri, 08 Mar 2019 17:25:10 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/go-iris-template/</guid>
      <description>Iris 支持五个开箱即用的模板引擎，所有这五个模板引擎都具有通用API的共同特征，如布局，模板功能，特定于派对的布局，部分渲染等。
 标准的html,它的模板解析器就是 golang.org/pkg/html/template/
Django,它的模板解析器就是 github.com/flosch/pongo2
Pug(Jade),它的模板解析器就是 github.com/Joker/jade
Handlebars, 它的模板解析器 github.com/aymerick/raymond
Amber, 它的模板解析器 github.com/eknkc/amber
 </description>
    </item>
    
    <item>
      <title>Go Iris 路由</title>
      <link>https://blog.v5u.win/post/go-iris-%E8%B7%AF%E7%94%B1/</link>
      <pubDate>Fri, 08 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/go-iris-%E8%B7%AF%E7%94%B1/</guid>
      <description> 路由配置规则 直接通过 function 绑定 controller，function name 映射到 路由的地址
function named rule：
func(*Controller) GetLoginBy(id int64) 绑定的controller HTTP-method+routePath map to - GET:/user/login/{param:long}  通过控制器方法的输入参数访问动态路径参数，不需要绑定。当您使用Iris的默认语法来解析来自控制器的处理程序时，您需要使用By字来为方法添加后缀，大写是一个新的子路径。例： 如这种形式 mvc.New(app.Party(&amp;ldquo;/user&amp;rdquo;)).Handle(new(user.Controller)) 则:
 func(*Controller) Get() - GET:/user. func(*Controller) Post() - POST:/user. func(*Controller) GetLogin() - GET:/user/login func(*Controller) PostLogin() - POST:/user/login func(*Controller) GetProfileFollowers() - GET:/user/profile/followers func(*Controller) PostProfileFollowers() - POST:/user/profile/followers func(*Controller) GetBy(id int64) - GET:/user/{param:long} func(*Controller) PostBy(id int64) - POST:/user/{param:long}  </description>
    </item>
    
    <item>
      <title>Go Error 错误处理</title>
      <link>https://blog.v5u.win/post/go-error-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/</link>
      <pubDate>Wed, 06 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/go-error-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/</guid>
      <description>常用的有五种方式
第一种策略 首先，也是最常用的方式是传播错误。这意味着函数中某个子程序的失败，会变成该函数的失败。我们使用该函数前缀添加额外的上下文信息到原始错误信息。当错误最终由main函数处理时，错误信息应提供清晰的从原因到后果的因果链，就像美国宇航局事故调查时做的那样：
 genesis: crashed: no parachute: G-switch failed: bad relay orientation
 编写错误信息时，我们要确保错误信息对问题细节的描述是详尽的。尤其是要注意错误信息表达的一致性，即相同的函数或同包内的同一组函数返回的错误在构成和处理方式上是相似的。
第二种策略 第二种策略。如果错误的发生是偶然性的，或由不可预知的问题导致的。一个明智的选择是重新尝试失败的操作。在重试时，我们需要限制重试的时间间隔或重试的次数，防止无限制的重试。
第三种策略 如果错误发生后，程序无法继续运行，我们就可以采用第三种策略：输出错误信息并结束程序。需要注意的是，这种策略只应在main中执行。对库函数而言，应仅向上传播错误，除非该错误意味着程序内部包含不一致性，即遇到了bug，才能在库函数中结束程序。
调用log.Fatalf可以更简洁的代码达到与上文相同的效果。log中的所有函数，都默认会在错误信息之前输出时间信息。
if err := WaitForServer(url); err != nil { log.Fatalf(&amp;quot;Site is down: %v\n&amp;quot;, err) } // 我们可以设置log的前缀信息屏蔽时间信息，一般而言，前缀信息会被设置成命令名。 log.SetPrefix(&amp;quot;wait: &amp;quot;) log.SetFlags(0)  第四种策略 第四种策略：有时，我们只需要输出错误信息就足够了，不需要中断程序的运行。
我们可以通过log包提供函数
if err := Ping(); err != nil { log.Printf(&amp;quot;ping failed: %v; networking disabled&amp;quot;,err) } //log包中的所有函数会为没有换行符的字符串增加换行符。  或者标准错误流输出错误信息。
if err := Ping(); err != nil { fmt.Fprintf(os.Stderr, &amp;quot;ping failed: %v; networking disabled\n&amp;quot;, err) }  第五种策略 第五种，也是最后一种策略：我们可以直接忽略掉错误。</description>
    </item>
    
    <item>
      <title>Go HTML template</title>
      <link>https://blog.v5u.win/post/go-html-template/</link>
      <pubDate>Tue, 05 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/go-html-template/</guid>
      <description>文档 go doc text/template $ go doc html/template  应用 func main() { // 定义模板显示格式 const templ = `&amp;lt;p&amp;gt;A: {{.A}}&amp;lt;/p&amp;gt;&amp;lt;p&amp;gt;B: {{.B}}&amp;lt;/p&amp;gt;` // 模板配置函数 t := template.Must(template.New(&amp;quot;escape&amp;quot;).Parse(templ)) var data struct { A string // untrusted plain text B template.HTML // trusted HTML } // A是一个普通字符串，B是一个信任的template.HTML字符串类型。 data.A = &amp;quot;&amp;lt;b&amp;gt;Hello!&amp;lt;/b&amp;gt;&amp;quot; data.B = &amp;quot;&amp;lt;b&amp;gt;Hello!&amp;lt;/b&amp;gt;&amp;quot; // 使用定义好的 模板 输出到 控制台 if err := t.Execute(os.Stdout, data); err != nil { log.Fatal(err) } } /* autoescape.html 结果 A:&amp;lt;b&amp;gt;Hello!</description>
    </item>
    
    <item>
      <title>如何学习一门新的编程语言</title>
      <link>https://blog.v5u.win/post/system-%E5%A6%82%E4%BD%95%E5%AD%A6%E4%B9%A0%E4%B8%80%E9%97%A8%E6%96%B0%E7%9A%84%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/</link>
      <pubDate>Thu, 28 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/system-%E5%A6%82%E4%BD%95%E5%AD%A6%E4%B9%A0%E4%B8%80%E9%97%A8%E6%96%B0%E7%9A%84%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/</guid>
      <description> 安装开发环境 熟悉数据类型和函数声明 查看内置标准库，了解该语言的基础方法/标准功能 学习一个框架，实现一个具有完整功能的Demo  </description>
    </item>
    
    <item>
      <title>Go-语言要点</title>
      <link>https://blog.v5u.win/post/go-%E8%AF%AD%E8%A8%80%E8%A6%81%E7%82%B9/</link>
      <pubDate>Wed, 27 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/go-%E8%AF%AD%E8%A8%80%E8%A6%81%E7%82%B9/</guid>
      <description>[TOC]
要点 本章对Go语言做了一些介绍，Go语言很多方面在有限的篇幅中无法覆盖到。本节会把没有讲到的内容也做一些简单的介绍，这样读者在读到完整的内容之前，可以有个简单的印象。
控制流 在本章我们只介绍了if控制和for，但是没有提到switch多路选择。这里是一个简单的switch的例子：
switch coinflip() { case &amp;quot;heads&amp;quot;: heads++ case &amp;quot;tails&amp;quot;: tails++ default: fmt.Println(&amp;quot;landed on edge!&amp;quot;) }  在翻转硬币的时候，例子里的coinflip函数返回几种不同的结果，每一个case都会对应一个返回结果，这里需要注意，Go语言并不需要显式地在每一个case后写break，语言默认执行完case后的逻辑语句会自动退出。当然了，如果你想要相邻的几个case都执行同一逻辑的话，需要自己显式地写上一个fallthrough语句来覆盖这种默认行为。不过fallthrough语句在一般的程序中很少用到。
Go语言里的switch还可以不带操作对象（译注：switch不带操作对象时默认用true值代替，然后将每个case的表达式和true值进行比较）；可以直接罗列多种条件，像其它语言里面的多个if else一样，下面是一个例子：
func Signum(x int) int { switch { case x &amp;gt; 0: return +1 default: return 0 case x &amp;lt; 0: return -1 } }  这种形式叫做无tag switch(tagless switch)；这和switch true是等价的。
像for和if控制语句一样，switch也可以紧跟一个简短的变量声明，一个自增表达式、赋值语句，或者一个函数调用(译注：比其它语言丰富)。
break和continue语句会改变控制流。和其它语言中的break和continue一样，break会中断当前的循环，并开始执行循环之后的内容，而continue会跳过当前循环，并开始执行下一次循环。这两个语句除了可以控制for循环，还可以用来控制switch和select语句(之后会讲到)，在1.3节中我们看到，continue会跳过内层的循环，如果我们想跳过的是更外层的循环的话，我们可以在相应的位置加上label，这样break和continue就可以根据我们的想法来continue和break任意循环。这看起来甚至有点像goto语句的作用了。当然，一般程序员也不会用到这种操作。这两种行为更多地被用到机器生成的代码中。
命名类型 类型声明使得我们可以很方便地给一个特殊类型一个名字。因为struct类型声明通常非常地长，所以我们总要给这种struct取一个名字。本章中就有这样一个例子，二维点类型：
type Point struct { X, Y int } var p Point  类型声明和命名类型会在第二章中介绍。</description>
    </item>
    
    <item>
      <title>Centos7 添加 桌面运行环境</title>
      <link>https://blog.v5u.win/post/system-centos7-%E6%B7%BB%E5%8A%A0-%E6%A1%8C%E9%9D%A2%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83/</link>
      <pubDate>Mon, 25 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/system-centos7-%E6%B7%BB%E5%8A%A0-%E6%A1%8C%E9%9D%A2%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83/</guid>
      <description>Centos7 添加 桌面运行环境
 root 权限执行 yum groupinstall &amp;quot;X Window System&amp;quot; 检查安装情况 yum grouplist   </description>
    </item>
    
    <item>
      <title>Go 语言简介</title>
      <link>https://blog.v5u.win/post/go-%E8%AF%AD%E8%A8%80%E7%AE%80%E4%BB%8B/</link>
      <pubDate>Thu, 21 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/go-%E8%AF%AD%E8%A8%80%E7%AE%80%E4%BB%8B/</guid>
      <description>Go 的底层语言是什么 借用大神的话来说
 编译器就是输入源代码输出其他语言源代码的程序
 所以这个程序用什么语言实现无所谓
然而，一开始没有go，所以用c实现了一版go编译器，后来go语言存在了，那就可以用go再重写一遍编译器，用c写的编译器来编译这个新的编译器的源代码 然后就成了现在这个样子 你可以找找老版本看看c实现
 2015年8月19日，Go语言Go 1.5版发布，本次更新中移除了”最后残余的C代码”
 从此 Go 实现了自举
Go 的市场定位 Go语言尤其适合编写网络服务相关基础设施，同时也适合开发一些工具软件和系统软件。
​ ——《The Go Programming Language》
Go 语言能吞食的一定是 PaaS 上的项目，比如一些消息缓存中间件、服务发现、服务代理、控制系统、Agent、日志收集等等，没有复杂的业务场景，也到不了特别底层（如操作系统）的中间平台层的软件项目或工具。而 C 和 C++ 会被打到更底层，Java 会被打到更上层的业务层。这是左耳朵耗子的一个判断。
用上面的标尺来量一下 Go 语言的杀手级应用 Docker，你会发现基本是一样的。
学习文档</description>
    </item>
    
    <item>
      <title>词法作用域</title>
      <link>https://blog.v5u.win/post/itblack-%E8%AF%8D%E6%B3%95%E4%BD%9C%E7%94%A8%E5%9F%9F/</link>
      <pubDate>Thu, 21 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/itblack-%E8%AF%8D%E6%B3%95%E4%BD%9C%E7%94%A8%E5%9F%9F/</guid>
      <description>首先你得明白程序设计中作用域这个概念：通常来说，一段程序代码中所用到的名字并不总是有效／可用的，而限定这个名字的可用性的代码范围就是这个名字的作用域。
词法作用域 VS 动态作用域 词法作用域，也叫静态作用域，它的作用域是指在词法分析阶段就确定了，不会改变。动态作用域是在运行时根据程序的流程信息来动态确定的，而不是在写代码时进行静态确定的。
主要区别：词法作用域是在写代码或者定义时确定的，而动态作用域是在运行时确定的（this也是！）。词法作用域关注函数在何处声明，而动态作用域关注函数从何处调用。
作者：康斌
链接：https://www.jianshu.com/p/70b38c7ab69c
來源：简书
简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。</description>
    </item>
    
    <item>
      <title>Go异常处理</title>
      <link>https://blog.v5u.win/post/go-error/</link>
      <pubDate>Mon, 18 Feb 2019 15:48:37 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/go-error/</guid>
      <description>type error interface { Error() string }  error的声明
创建一个error
if path == &amp;quot;&amp;quot; { return nil, errors.New(&amp;quot;The parameter is invalid!&amp;quot;) }  error的使用
func readFile(path string) ([]byte, error) { file, err := os.Open(path) if err != nil { return nil, err } defer file.Close() return ioutil.ReadAll(file) }  异常处理——panic 译为运行时恐慌
内建函数panic和recover是天生的一对。前者用于产生运行时恐慌，而后者用于“恢复”它。
不过要注意，recover函数必须要在defer语句中调用才有效。因为一旦有运行时恐慌发生，当前函数以及在调用栈上的所有代码都是失去对流程的控制权。只有defer语句携带的函数中的代码才可能在运行时恐慌迅速向调用栈上层蔓延时“拦截到”它。
defer func() { if p := recover(); p != nil { fmt.Printf(&amp;quot;Fatal error: %s\n&amp;quot;, p) } }()  panic函数。该函数可接受一个interface{}类型的值作为其参数。也就是说，我们可以在调用panic函数的时候可以传入任何类型的值。不过，我建议大家在这里只传入error类型的值。这样它表达的语义才是精确的。更重要的是，当我们调用recover函数来“恢复”由于调用panic函数而引发的运行时恐慌的时候，得到的值正是调用后者时传给它的那个参数。因此，有这样一个约定是很有必要的。</description>
    </item>
    
    <item>
      <title>Go-流程控制</title>
      <link>https://blog.v5u.win/post/go-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/</link>
      <pubDate>Mon, 18 Feb 2019 11:38:16 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/go-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/</guid>
      <description>[TOC]
if 判断语句 if 100 &amp;gt; number { number += 3 } else if 100 &amp;lt; number { number -= 2 } else { fmt.Println(&amp;quot;OK!&amp;quot;) }  //变量赋值 if number := 4; 100 &amp;gt; number { number += 3 }  // 标识符的重声明和标识符的遮蔽 var number int if number := 4; 100 &amp;gt; number { number += 3 }  // 或条件 if (width == 0) ||(height == 0) || (offsetX == 0 )|| (offsetY == 0) { return nil }  标识符的重声明和标识符的遮蔽 上述代码被执行完毕之后，第二次声明的number变量的值会是7，而第一次声明的number变量的值仍会是0。</description>
    </item>
    
    <item>
      <title>Go的函数 结构体</title>
      <link>https://blog.v5u.win/post/go-function/</link>
      <pubDate>Sun, 17 Feb 2019 21:15:19 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/go-function/</guid>
      <description>func(input1 string ,input2 string) string type MyFunc func(input1 string ,input2 string) string// 函数声明  函数实现
func myFunc(part1 string, part2 string) (result string) { result = part1 + part2 return } //如果结果声明是带名称的，那么它就相当于一个已被声明但未被显式赋值的变量。 //我们可以为它赋值且在return语句中省略掉需要返回的结果值。  或
func myFunc(part1 string, part2 string) string { return part1 + part2 }  var splice func(string, string) string // 等价于 var splice MyFunc //只要一个函数的参数声明列表和结果声明列表中的数据类型的顺序和名称与某一个函数类型完全一致，前者就是后者的一个实现。  var result = func(part1 string, part2 string) string { return part1 + part2 }(&amp;quot;1&amp;quot;, &amp;quot;2&amp;quot;)  结构体</description>
    </item>
    
    <item>
      <title>Go的数据结构</title>
      <link>https://blog.v5u.win/post/go-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</link>
      <pubDate>Sun, 17 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/go-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</guid>
      <description>[TOC]
先来看看Golang关于类型设计的一些原则
 变量包括（type, value）两部分，理解这一点就知道为什么nil != nil了 type 包括 static type和concrete type. 简单来说 static type是你在编码是看见的类型(如int、string)，concrete type是runtime系统看见的类型 类型断言能否成功，取决于变量的concrete type，而不是static type. 因此，一个 reader变量如果它的concrete type也实现了write方法的话，它也可以被类型断言为writer.  变量声明 var num int = 1 //变量 const channle = &amp;quot;go&amp;quot;	//常量  注意变量作用域：在Go语言中，我们对程序实体的访问权限控制只能通过它们的名字来实现。名字首字母为大写的程序实体可以被任何代码包中的代码访问到。而名字首字母为小写的程序实体则只能被同一个代码包中的代码所访问。
数据类型 基本数据类型 整型 int8 int16 int32 int64, uint8 uint16 uint32 uint64
byte 是 uint8 的别名
rune 是 int32 的别名，用来表示Unicode。&amp;rsquo;A&amp;rsquo;: U+0041
浮点型 float32,float64
复数 complex64(3.7E+1+5.98E-2i),由两个浮点型组成分别表示实部和虚部
字符型 byte 没有专门的字符型，使用byte 来保存单个字母字符
布尔型 bool 字符串 string ​ 从表象上来说是字符序列，但是在底层，一个字符串值却是由若干个字节来表现和存储的。一个字符串（也可以说字符序列）会被Go语言用Unicode编码规范中的UTF-8编码格式编码为字节数组。</description>
    </item>
    
    <item>
      <title>go 常用命令</title>
      <link>https://blog.v5u.win/post/go-%E5%91%BD%E4%BB%A4/</link>
      <pubDate>Fri, 15 Feb 2019 15:50:32 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/go-%E5%91%BD%E4%BB%A4/</guid>
      <description>[TOC]
go run 编译并运行Go源码文件，编译的可执行文件在tmp目录下，这会影响相对路径
go build 编译源码文件，代码包，依赖包
go get / go mod download xxx 动态获取远程代码包
go get 简介（1) 用于从远程代码仓库（如著名Github )上下载并安装代码包
受支持的代码版本控制系统有：Git、Mercurial ( hg )、SVN、Bazaar
指定的代码包会被下载到$G〇PATH中包含的第一个工作区的src目录中
常用命令参数 -d 只下载 不安装 -x 查看执行过程 -u 更新已下载的代码包 -fix 将旧版本的代码包转换成新版规则  mac@name:~/go/golib/src/pkgtool$ go install -v -work 在源码目录下，执行 go install，会编译 a 文件到 $HOME/golang/goc2p: bin/ pkg/ linux_386/ pkgtool.a src/  例：go get github.com/hyper-carrot/go_lib/logging
go install go install简介( 1 )
​ 用于编译并安装代码包或源码文件
​ 安装代码包会在当前工作区的pkg/&amp;lt;平台相关目录&amp;gt;下生成归档文件
​ 安装命令源码文件会在当前工作区的bin目录或$GOBIN目录下生成可执行文件
go install 简介(2 )</description>
    </item>
    
    <item>
      <title>vscode安装golang.org的golint</title>
      <link>https://blog.v5u.win/post/go-vscode%E5%AE%89%E8%A3%85golang.org%E7%9A%84golint/</link>
      <pubDate>Fri, 15 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/go-vscode%E5%AE%89%E8%A3%85golang.org%E7%9A%84golint/</guid>
      <description>vscode 安装了 go 插件后，一些 Extensions 无法通过 vscode 自动安装，此时可以手动从控制台安装。下面是一些基础标准库
go get -u -v github.com/nsf/gocode go get -u -v github.com/rogpeppe/godef go get -u -v github.com/zmb3/gogetdoc go get -u -v github.com/golang/lint/golint go get -u -v github.com/lukehoban/go-outline go get -u -v sourcegraph.com/sqs/goreturns go get -u -v golang.org/x/tools/cmd/gorename go get -u -v github.com/tpng/gopkgs go get -u -v github.com/newhook/go-symbols go get -u -v golang.org/x/tools/cmd/guru go get -u -v github.com/cweill/gotests/...  其中 golint guru gorename 需要手动编译。</description>
    </item>
    
    <item>
      <title>go-代码组织方式</title>
      <link>https://blog.v5u.win/post/go-%E4%BB%A3%E7%A0%81%E7%BB%84%E7%BB%87%E6%96%B9%E5%BC%8F/</link>
      <pubDate>Thu, 14 Feb 2019 15:48:05 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/go-%E4%BB%A3%E7%A0%81%E7%BB%84%E7%BB%87%E6%96%B9%E5%BC%8F/</guid>
      <description>[TOC]
Go源码文件以 .go 为后缀。
Go语言的代码通过包（package）组织，包类似于其它语言里的库（libraries）或者模块（modules）。一个包由位于单个目录下的一个或多个.go源代码文件组成, 目录定义包的作用。每个源文件都以一条package声明语句开始，这个例子里就是package main, 表示该文件属于哪个包，紧跟着一系列导入（import）的包，之后是存储在这个文件里的程序语句。
main包比较特殊。它定义了一个独立可执行的程序，而不是一个库。在main里的main 函数 也很特殊，它是整个程序执行时的入口
多个源码文件需要用源码包组织起来。
同一 package 下多文件代码管理 实现：在同一目录下，创建多个 go 文件， 文件的 package 都设置为同一个 package 名。但是同一个目录下只能声明一个package name。
例：package main
无需导入文件，直接调用其他文件里的方法。
举例：
在 mutifiles-package/ 目录下创建两个文件：main.go util.go
package main func main(){ foo() } // main.go  package main import &amp;quot;fmt&amp;quot; func foo(){ fmt.Println(&amp;quot;foo()&amp;quot;) } // util.go	 命令行执行 go build,生成一个 mutifiles-package 可执行文件。
./mutifiles-package 打印 foo() 。
注意：直接运行 go run main.go util.go 也可以打印 foo()，必须将两个文件都引入。
代码包的导入 import用法 import( &amp;quot;fmt&amp;quot; )  上面这个fmt是Go语言的标准库，他其实是去GOROOT下去加载该模块（先找GOROOT，如果GOROOT找不到在去GOPATH找），当然Go的import还支持如下两种方式来加载自己写的模块：</description>
    </item>
    
    <item>
      <title>工作区和GOPATH</title>
      <link>https://blog.v5u.win/post/go-workspace-gopath/</link>
      <pubDate>Thu, 14 Feb 2019 15:34:03 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/go-workspace-gopath/</guid>
      <description> 工作区和GOPATH 工作区是放置Go源码文件的目录，一般情况下，Go源码文件都需要放在工作区，但是对于命令源码文件来说，这不是必须的。
工作区目录结构：
/ src/ pkg/ bin/  src/ #放源码的 pkg/ #存放归档文件(.a文件)所有归档文件都会存放到该目录下的平台相关目录中，同样以代码包为组织形式 bin/ #存放当前工作区中的Go程序的可执行文件
平台相关目录 用两个隐含的Go语言环境变量：GOOS和GOARCH
以$GOOS_$GOARCH为命名方式，例：linux_amd64和darwin_amd64
bin目录  当环境变量GOBIN已有效设置时，该目录会变得无意义 当GOPATH的值中包含多个工作区的路径时，必须设置GOBIN，否则无法成功安装Go程序的可执行文件  </description>
    </item>
    
    <item>
      <title>mac-nginx-php-mysql</title>
      <link>https://blog.v5u.win/post/mac-nginx-php-mysql/</link>
      <pubDate>Tue, 25 Dec 2018 10:04:25 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/mac-nginx-php-mysql/</guid>
      <description>[TOC]
安装环境  brew install nginx brew install php brew install mysql  配置环境  /usr/local/homebrew/etc/nginx/nginx.conf /etc/php-fpm.conf  启动环境  brew services start nginx php-fpm（启动php-fpm）  nginx.conf server { location / { root /rootDocument/; index index.html index.htm index.php; autoindex on; # //开启目录浏览功能； autoindex_exact_size off; #//关闭详细文件大小统计，让文件大小显示MB，GB单位，默认为b autoindex_localtime on; #//开启以服务器本地时区显示文件修改日期！ } location ~ \.php$ { root html; fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME /rootDocument$fastcgi_script_name; include fastcgi_params; }  php-fpm.conf error_log = /usr/local/homebrew/var/log/php-fpm.</description>
    </item>
    
    <item>
      <title>scrapy</title>
      <link>https://blog.v5u.win/post/python-scrapy/</link>
      <pubDate>Tue, 18 Dec 2018 00:00:00 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/python-scrapy/</guid>
      <description>scrapy crawl m530pcrawl会去搜搜cmd目录下的scrapy.cfg
有些Scrapy命令(比如 crawl)要求必须在Scrapy项目中运行。 您可以通过下边的 commands reference 来了解哪些命令需要在项目中运行，哪些不用。</description>
    </item>
    
    <item>
      <title>tp5</title>
      <link>https://blog.v5u.win/post/php-tp5/</link>
      <pubDate>Tue, 18 Dec 2018 00:00:00 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/php-tp5/</guid>
      <description># 表达式 不区分大小写， # EQ = # NEQ &amp;lt;&amp;gt;	不等于 # LT &amp;lt; # ELT &amp;lt;= # RT &amp;gt; # ELT &amp;gt;= # BETWEEN BETWEEN * AND * # NOTBETWEEN NOTBETWEEN * AND * # IN IN (*,*) # NOTIN NOT IN (*,*)  $sql = $db-&amp;gt;where(&#39;id&#39;,&#39;between&#39;,&amp;quot;1,5&amp;quot;)-&amp;gt;buildSql();</description>
    </item>
    
    <item>
      <title>vagrant&amp;homestead的使用</title>
      <link>https://blog.v5u.win/post/system-vagranthomestead%E7%9A%84%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Tue, 04 Dec 2018 00:00:00 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/system-vagranthomestead%E7%9A%84%E4%BD%BF%E7%94%A8/</guid>
      <description>~/Homestead 目录下执行下面的命令 - 初始化虚拟机vagrant up - 登录vagrant ssh - 退出虚拟机exit - 关闭 Homesteadvagrant halt</description>
    </item>
    
    <item>
      <title>沙龙举办流程</title>
      <link>https://blog.v5u.win/post/read-%E6%B2%99%E9%BE%99%E4%B8%BE%E5%8A%9E/</link>
      <pubDate>Mon, 19 Nov 2018 00:00:00 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/read-%E6%B2%99%E9%BE%99%E4%B8%BE%E5%8A%9E/</guid>
      <description>在开放的基础上，环境应当设置的尽可能的平等。比如尽可能的采用圆桌形式，而且参与人员尽量围成一个圈，避免层次上的区别，
主持人的重点不是表达自己观点，而是传承上下，并尽量避免一个人表达过多，要适时打断，并及时将话语权传递给其他的人。如果读书会参与人数合适的话，可以争取让每一个人都发表自己的观点。
主持人是轮流的，效果挺好，会有轮流发言和自由讨论环节。</description>
    </item>
    
    <item>
      <title>thinkPHP5.0 学习总结</title>
      <link>https://blog.v5u.win/post/php-thinkphp5.0-%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/</link>
      <pubDate>Thu, 15 Nov 2018 00:00:00 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/php-thinkphp5.0-%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/</guid>
      <description> thinkPHP5.0 学习总结感悟  免费的是最贵的，学习使用文档和手册，学习效率低下——改用优秀视频后，效果显著，如果使用付费内容想必效果会更好，参考买的《数据结构与算法》：内容很容易理解，让我从浩瀚的理论书籍中解脱了出来。 技能的习得是曲折前进，螺旋上升的，学习路径：PHP基础——&amp;gt;练手项目(sqlite，MySQL学习)——&amp;gt;tp5手册——&amp;gt;tp5视频。所有的学习都没有白费。化作了以后习得技能的土壤。  </description>
    </item>
    
    <item>
      <title>PHP 命名空间 namespace</title>
      <link>https://blog.v5u.win/post/php-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4-namespace/</link>
      <pubDate>Mon, 12 Nov 2018 00:00:00 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/php-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4-namespace/</guid>
      <description>PHP 命名空间 namespace
 声明： ```php &amp;lt;?php // file1.php namespace MyProject; namespace MyProject\Sub\Level; //声明分层次的单个命名空间  	namespace MyProject { const CONNECT_OK = 1; class Connection { /* &amp;hellip; / } function connect() { / &amp;hellip; */ }
namespace Foo\Bar\subnamespace; const FOO = 1;  	function foo() {} class foo { static function staticmethod() {} } } ?&amp;gt;
2. 使用 ```php &amp;lt;?php //file2.php namespace Foo\Bar; include &#39;file1.php&#39;; subnamespace\foo(); // 解析为函数 Foo\Bar\subnamespace\foo subnamespace\foo::staticmethod(); // 解析为类 Foo\Bar\subnamespace\foo, // 以及类的方法 staticmethod \Foo\Bar\foo(); // 解析为函数 Foo\Bar\foo \Foo\Bar\foo::staticmethod(); // 解析为类 Foo\Bar\foo, 以及类的方法 staticmethod ?</description>
    </item>
    
    <item>
      <title>thinkphp5开发规范</title>
      <link>https://blog.v5u.win/post/php-thinkphp5%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/</link>
      <pubDate>Fri, 09 Nov 2018 00:00:00 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/php-thinkphp5%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/</guid>
      <description>目录结构 ./application
​ ./index
​ ./controller 控制层
​ ./model 模型
​ ./view
​ ./admin 后台模块
​ command.php 控制台配置，命令行执行，读取该模块
​ common.php 项目的公共文件，通用函数，全局调用
​ config.php 应用的配置文件
​ database.php 数据库配置文件
​ router.php 路由配置文件，对URL进行美化
​ tags.php 应用行为配置文件，默认提供很多钩子，对框架进行扩展，达到无需修改框架源码，注册函数/行为——&amp;gt;改变执行流程
./extend 非composer的第三方库存放地址
./public 网站根目录
​ favicon.ico 网站标签页图标
​ index.php 整个网站入口文件
​ robots.txt 搜索引擎配置文件
​ router.php 快速启动配置文件，无Apache时，通过thinkPHP内置的work server读取该文件，启动框架。例:php -S localhost:8888 router.php
​ ./static 静态资源存放处，例: css、js、image
./runtime 网站运行中缓存文件，日志、缓存、编译文件
./thinkphp 框架文件
​ base.php 定义一些常量
​ composer.json composer的配置文件
​ console.php 控制台入口文件</description>
    </item>
    
    <item>
      <title>chrome 调试</title>
      <link>https://blog.v5u.win/post/web-chrome-%E8%B0%83%E8%AF%95/</link>
      <pubDate>Thu, 08 Nov 2018 00:00:00 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/web-chrome-%E8%B0%83%E8%AF%95/</guid>
      <description>chrome 调试
keyword: workspace,breakpoints
 将调试代码文件添加到Chrome 的Workspace中：Sources&amp;ndash;&amp;gt;filesystem&amp;ndash;&amp;gt;+Add folder to workspace&amp;ndash;&amp;gt;chrome 警告框，设置允许访问—&amp;gt;在workspace中打开文件，直接编写，cmd+s保存&amp;ndash;&amp;gt;刷新网页查看效果. breakpoints: Sources&amp;ndash;&amp;gt;Event Listener Breakpoints&amp;ndash;&amp;gt;Mouse&amp;ndash;&amp;gt;click 选中——&amp;gt;在调试代码出添加断点——&amp;gt;执行代码（例：点击button，执行js）——&amp;gt;使用断点调试器，R,➡️,⬇️，⬆️  </description>
    </item>
    
    <item>
      <title>php 网站效率原理</title>
      <link>https://blog.v5u.win/post/php-%E7%BD%91%E7%AB%99%E6%95%88%E7%8E%87%E5%8E%9F%E7%90%86/</link>
      <pubDate>Wed, 07 Nov 2018 00:00:00 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/php-%E7%BD%91%E7%AB%99%E6%95%88%E7%8E%87%E5%8E%9F%E7%90%86/</guid>
      <description>确实如你所言, 是我对php的认识不足. 刚刚补了一下这里的知识, 应该是这样的: php有三种工作模式. 其中是最常见的是php作为一个模块工作在一个多进程的webserver中, 例如apache webserver. apache会启动一个主进程, 多个子进程(php). 主进程分发请求到子进程上处理. 目前流行的nginx + php-fpm应该也是类似这一种模式, ngnix会把请求转发给php-fpm处理. php-fpm是一个php进程管理器, 维护了一个php进程池, 在接收到请求后分发给php子进程. 在这种模式下, php进程可以是一直存活的. 进程启动时会做进程相关的初始化操作, 比如加载插件. 对于接收到的请求, 会做请求处理的相关初始化-&amp;gt;调用相应的php代码做业务操作-&amp;gt;销毁请求上下文. 对于php程序员来讲, 每个请求的处理都是全新的上下文, 所有定义/对象/变量完全限定在单个请求处理的这个上下文中. 大家写的php代码到此结束. 当然, php进程也可以被销毁, 这与php-fpm的工作模式有关. 更多细节详见相关文档1+2. 因此, 对于一个这样的php进程, 是可以做持久化数据库连接的, 只是稍有不同. 每个php进程只保留一个持久连接. 例如, php-fpm启动了20个php子进程, 对于同一个数据库和同一个用户名, 最多有20个持久连接. 对于同一个php进程所处理的多个请求, 它们都使用同一个数据库连接. 更多详见文档3. 所以, 这个效果与使用一个连接池也差不多了. 持久连接数取决与php进程的数量. 最终, 持久连接数量/进程数量就需要按实际的情况来调优了. 目前理解是这样, 如有误请指正.
相关文档:
\1. php生命周期 http://www.slideshare.net/laruence/the-php-life-cycle \2. php-fpm配置文档: http://php.net/manual/en/install.fpm.configuration.php \3. php持久化连接: http://php.net/manual/en/features.persistent-connections.php
对于 php 应用来说， 数据库的链接重用并不是瓶颈， 所以语言开发者不花这个心思也是正常的。 从目前看来， php 应用的最大瓶颈， 是没有 jit 和 弱类型带来的性能负担。这也是 php 社区所应该尽快解决的问题。另外一个问题就是 yii2、lavarel 这些把开发者带进坑里的玩意，大型网站压根就没法用这些往死里浪费性能的重型框架。</description>
    </item>
    
    <item>
      <title>《程序员的咆哮》阅读总结</title>
      <link>https://blog.v5u.win/post/read-%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E5%92%86%E5%93%AE%E9%98%85%E8%AF%BB%E6%80%BB%E7%BB%93/</link>
      <pubDate>Wed, 10 Oct 2018 09:40:11 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/read-%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E5%92%86%E5%93%AE%E9%98%85%E8%AF%BB%E6%80%BB%E7%BB%93/</guid>
      <description> 编程界的数学
学校的数学教育体系是错误的，因为这是数学领域的连续知识，但是在现实生活中很多没有实际用处。
学校不教，现实中很有用的数学：统计，代数——线性代数，数理逻辑，信息论和柯氏复杂性
运用数学的第一步是：界定问题。当一个问题在手却不知道如何下手的时候，是最花时间的。
编译原理是计算机科学第二重要的科学，很重要，因为他非常切实的将你学到的几乎所有东西都捏合在了一起。 编译原理3个领域： 1. 解析，词法分析，语法分析生成解析树
 类型检查 代码生成的正确性  Google的面试
 细的马克笔 大O复杂度分析 知道排序是怎么回事，两个nlog(n)的排序算法，比如快排和归并排序 哈希表是人类已知的最重要的数据结构，一定要弄明白原理。 树，必须弄懂 图，内存中表示图的方法有3中(指针和对象，矩阵，邻接表) 每次遇到问题首先考虑的是图算法。他们是任何关系里最基本，最灵活的方法。 基本的离散数学 操作系统：线程，进程，并发这些概念，掌握锁的概念， 编程，对一门语言的细节有相当的了解  </description>
    </item>
    
    <item>
      <title>数据结构与算法1-复杂度分析1</title>
      <link>https://blog.v5u.win/post/system-datastructureandalgorithm1/</link>
      <pubDate>Mon, 08 Oct 2018 10:53:57 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/system-datastructureandalgorithm1/</guid>
      <description>为什么需要复杂度分析？
有两种估算方法：1.事后统计法 2.大O复杂度表示法  事后统计法: 把代码跑一遍，通过统计、监控，就能得到算法执行的时间和占用的内存大小 测试结果非常依赖测试环境   测试结果受数据规模的影响很大   我们需要一个不用具体的测试数据来测试，就可以粗略的估计计算法的执行效率的方法——大O复杂度表示法  从CPU角度看，代码的执行类似这种操作：读数据——运算——写数据。
所有代码的执行时间T(n)与每行代码的执行次数n成正比。T(n)=O(f(n)),例：T(n)=O(2n+2),T(n)=O(2n²+2n+3)
大O时间复杂度实际上并不具体表示代码真正的执行时间，而是表示代码执行时间随数据规模增长的变化趋势，所以也叫，渐进时间复杂度，简称时间复杂度。T(n) = O(n)； T(n) = O(n²)。
时间复杂度分析  只关注循环执行次数最多的一段代码：核心代码执行次数的 n 的量级，就是整段要分析代码的时间复杂度 加法法则：总复杂度等于量级最大的那段代码的复杂度 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积  几种常见时间复杂度实例分析 常量阶O(1) 对数阶O(logn) 线性阶O(n) 线性对数阶O(nlogn) 指数阶O(2^n) 阶乘阶O(n!)  粗略分为两类：多项式量级和非多项式量级，非多项式量级只有两个：O(2^n)和O(n!)。</description>
    </item>
    
    <item>
      <title>code review</title>
      <link>https://blog.v5u.win/post/system-codereview/</link>
      <pubDate>Mon, 10 Sep 2018 00:00:00 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/system-codereview/</guid>
      <description>Code Review的好处我觉得不用多说了，主要是让你的代码可以更好的组织起来，有更易读，有更高的维护性，同时可以达到知识共享，找到bug只是其中的副产品。
我个人认为代码有这几种级别：1）可编译，2）可运行，3）可测试，4）可读，5）可维护，6）可重用。通过自动化测试的代码只能达到第3）级，而通过Code Review的代码少会在第4）级甚至更高。
在Amazon，开发工程师都会被教育拿到需求后一定要问——“为什么要做？业务影响度有多大？有多少用户受益？”，
review实施思路 先Review设计实现思路，然后Review设计模式，接着Review成形的骨干代码，最后Review完成的代码，如果程序复杂的话，需要拆成几个单元或模块分别Review。当然，最佳的practice是，每次Review的代码应该在1000行以内，时间不能超过一部电影的时间——1.5小时（因为据说那个一个正常人的膀胱可以容纳尿液的最长限度）
1.- 经常进行Code Review 2.- Code Review不要太正式，而且要短 3.- 尽可能的让不同的人Reivew你的代码 4.- 保持积极的正面的态度 5.- 学会享受Code Reivew
https://coolshell.cn/articles/1302.html
review工具
1. Review board:
Codestriker:
Groogle:：
 各式各样语言的语法高亮。 支持整个版本树的比较。 支持当个文件不同版本的diff功能，并有一个图形的版本树。 邮件通知所有的Reivew的人当前的状态。 认证机制。  4. Rietveld:
Review board 很像。它也是一个基于Web的应用，并在Google App Engine 上。
5. JCR
基于WEB界面的最初设计给Reivew Java 语言的
JCR 主要想协助：
 审查者。所有的代码更改都会被高亮，以及大多数语言的语法高亮。Code extracts 可以显示代码评审意见。如果你正在Review Java的代码，你可以点击代码中的类名来查看相关的类的声明。 项目所有者。可以 轻松创建并配置需要Review的项目，并不需要集成任何的软件配置管理系统（SCM）。 流程信仰者。 所有的评语都会被记录在数据库中，并且会有状态报告，以及各种各样的统计。 架构师和开发者。 这个系统也可以让我们查看属于单个文件的评语，这样有利于我们重构代码。  JCR 主要面对的是大型的项目，或是非常正式的代码评审，从这方面看来，他并不像上面的那些工具。
Jupiter
它是一个Eclipse IDE 的插件。
Gerrit
使用 Git 作为底层版本控制系统。它分支自Rietveld，作者为Google公司的Shawn Pearce，原先是为了管理Android计划而产生。</description>
    </item>
    
    <item>
      <title>cocoapods-library-create</title>
      <link>https://blog.v5u.win/post/mac-cocoapods-library-create/</link>
      <pubDate>Wed, 15 Aug 2018 14:48:36 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/mac-cocoapods-library-create/</guid>
      <description>readme文件如何添加 这种说明
 打开网站https://shields.io/#/examples/funding 选择flat Style 在Link和Image中输入http://img.shields.io/cocoapods/v/库名称.svg，网站会自动解析库的版本，生成img copy下面的Markdown，paste到要显示说明的地方  </description>
    </item>
    
    <item>
      <title>不完备定理</title>
      <link>https://blog.v5u.win/post/life-%E4%B8%8D%E5%AE%8C%E5%A4%87%E5%AE%9A%E7%90%86/</link>
      <pubDate>Tue, 14 Aug 2018 16:38:59 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/life-%E4%B8%8D%E5%AE%8C%E5%A4%87%E5%AE%9A%E7%90%86/</guid>
      <description>转一段清华大学赵昊彤博士的解读，我认为算是简单清晰准确。 ““哥德尔不完备定理”到底说了些什么？——（一）
【中文网上深入介绍哥德尔不完备定理的文章很少，我这篇文章写得很长，花了不少时间打磨它，希望能帮助到爱好数学与逻辑的人。文章把理解哥德尔不完备定理分为了五重，建议只是想初步了解的读者，可以重点看第一重；希望了解一些背景的读者，可以修炼到第二重；希望较深入理解哥德尔证明思路的读者，建议修炼到第三重；如果确实感兴趣，希望详细了解哥德尔证明过程以及其严谨性的读者，可以修炼到第四重；如果还想多知道一些知识的读者，可以练到第五重。
——— 作者】
1931年，库尔特∙弗雷德里希∙哥德尔（KurtFriedrich Gödel）发表了一篇影响深远的论文“On formally undecidablepropositions of Principia Mathematica and related systems I”[1]（论文的原文是用德文发表的，这里给出的是英译名）。今天，我们一般笼统的把论文中提出的定理称为“哥德尔不完备定理”。80多年过去了，“哥德尔不完备定理”的影响仍然持续、深远，特别是引起了很多非数学界人士的兴趣，引发了各种各样的解读。很遗憾，有一些解读是不准确的，甚至是错误的；更为严重的是，有一些人出于对“哥德尔不完备定理”的一知半解，甚至开始怀疑、批判人类的理性，以至于发展到相信、鼓吹不可知论。近期，我在认真研读了哥德尔论文原文（英译版，本人实在是不懂德文）和相关资料的基础上，加深了自己的认识，同时也很希望尽自己绵薄之力，分享对“哥德尔不完备定理”的理解，厘清对“哥德尔不完备定理”的误解。
“哥德尔不完备定理”是数学、逻辑学领域的划时代成果，使人们对于数学研究基础的认识更加深刻、准确，同时它也是现代逻辑史上的重要里程碑。“哥德尔不完备定理”虽然伟大、深刻，但是个人认为它并不深奥。对于一个普通人，只要愿意动脑，都可以在一定程度上准确理解它。当今的互联网时代，网上有不少对“哥德尔不完备定理”的介绍和解读；60多年前，两位美国作家欧内斯特·内格尔（Ernest Nagel）和詹姆士 R. 纽曼 （James R. Newman）撰写的的著作《哥德尔证明》更是科普“哥德尔不完备定理”的重要作品。如今网上能看到的中文介绍“哥德尔不完备定理”的文章，绝大部分是转述《哥德尔证明》这本书的内容的。不过这本书撰写太早，有些新的结论当年尚不了解；另外这本书在普及哥德尔证明的时候，更多的是讲解背景、思路，并用作者自己的理解来讲述哥德尔的证明，个别地方不够严谨，一些讲述方式也不够准确。本文则全部基于哥德尔论文的原文来介绍“哥德尔不完备定理”的证明，并适当融入一些80多年来新的认识和结论，希望能帮助数学、逻辑学爱好者了解并理解“哥德尔不完备定理”。
为了帮助更多人在各自需要的层面上理解“哥德尔不完备定理”，下面的介绍把理解“哥德尔不完备定理”分为了五重，从对定理的基本含义的理解一直到对核心证明的了解都包括了进来。读者可以像修习“乾坤大挪移”神功一样，依照自身内力基础，修炼到适合自己的层面即可。祝愿大家都能练成“哥德尔不完备定理”第五重神功！
第一重：“庐山真面目”——准确了解“哥德尔不完备定理”
赏玩一块美玉的时候，首先不应该是听各类专家讲这块玉多么晶莹剔透、多么价值连城，而应该是首先把玉拿出来让大家看看，有个感性认识。在哥德尔的论文中，我们一般所说的“哥德尔不完备定理”（有时候也被叫做“哥德尔第一不完备定理”）是指论文中的定理VI，原文如下：
TheoremVI: For every ω-consistent primitive recursive class κ of formulae, there is aprimitive recursive class-sign r , such that neither forall(v,r) nornot(forall(v,r)) belongs to Conseq(κ) (where v is the free variable of r).
尽量原汁原味的翻译如下：
定理VI：对于任意一个ω一致（第四重）的原始递归公理集合κ，一定存在一个原始递归（第三重、第四重）的表达式r，使得无论是“r总成立”这个命题，还是“r不总成立”这个命题，都不属于通过κ可推导出来的定理的集合（原文中的Conseq(κ)）。
补充说明一点，哥德尔论文中的κ所代表的公理集合，是指蕴含了皮亚诺算术公理（Peano Axioms）的集合，这是在哥德尔论文的前面明确了的，所以在阐述定理VI时就没有再特意强调。
修炼第一重神功的读者可能会问了“大哥，你说的这些都是啥？”。别担心，修炼第一重神功没那么复杂。
让我们先从公理说起，公理其实就是无需证明而被认定为成立的命题。公理体系是指一组公理的集合。通过这些公理和基本的逻辑关系，可以推导出更多成立的命题，称为定理。公理体系一般被认为发源于2300多年前欧几里德撰写的《几何原本》。在现代科学形成的过程中，人们发现通过定义一组公理再加上合理的逻辑推演，可以证明很多命题或结论。公理体系是当今数学研究和科学研究的基础，数学研究成果就是（或者说在极大的程度上依赖于）一组公理体系的推演，而其它科学研究除了依赖公理体系进行推演外，还需要通过系统的实验来进行验证。
“哥德尔不完备定理”是针对公理体系的一项结论，它之所以如此伟大且深刻，正是因为它撼动的是一切科学的研究基础——公理体系。修炼第一重神功的时候，我们简要理解“哥德尔不完备定理”说的是：一个足够复杂的公理体系（至少蕴含了皮亚诺算术公理），如果它是一致的（相容的，无矛盾的），那么它就是不完备的。这里的完备，指的是“对于任何可在这个公理体系内描述的命题，都可以在这个公理体系内得到判定，要么是正确的，要么是错误的”。
再用大白话解释一下，就是说，一个没有矛盾的公理体系内，总有一些命题是说不清楚对还是错的（务必注意，这是指在这个体系内说不清楚，不是说永远都说不清楚了）。也许有人说了，既然没矛盾的公理体系有问题，那就搞个有矛盾的公理体系呗。如果设想一个公理体系，一会儿告诉我们“1+1=2”，一会儿又告诉我们“1+12”，相信不会再有人把这个公理体系当回事。有矛盾的公理体系会导致彻底的无意义和虚无，修炼第二重神功的时候会详细阐明这一点。
上述结论听起来是比较可怕的，公理体系必须没有矛盾，可是没有矛盾的公理体系又会导致出现一些命题说不清楚对错。于是开始出现了各种各样的解读，比如“哥德尔定理告诉了我们数学和逻辑的极限，这也几乎是人类理性的极限。它证明理性不是无所不能的”、“哥德尔定理告诉我们，人类不可能真正认识这个世界，永远不可能理解宇宙的真理”等等。相信作为人类理性智慧光辉代表之一的哥德尔，如果听到这些说法，可能也会很无奈吧。
第一，“哥德尔不完备定理”不仅不是所谓人类理性的极限，恰恰相反，它是人类理性智慧的重大成果。它告诉了我们，正是由于有了人类理性的智慧，才有可能认识到这样深刻的结论。哥德尔是通过构造出了一个无法在这个公理体系内证明的命题来证明出“哥德尔不完备定理”的。这个命题的内容说的正是“命题自身无法在此公理体系内被证明”，既然哥德尔已经清楚的证明了这一点，说明这个命题毫无疑问是正确的。所以，“哥德尔不完备定理”的证明过程其实告诉了我们，存在一个可在这个公理体系内表达的正确的命题，但是在这个公理体系内却既不能证明它，也无法证伪它。如果说“哥德尔不完备定理”阐明了什么极限的话，那它阐明的也只是“某类公理体系的极限”，而不是“数学、逻辑的极限”，更不是什么“人类理性的极限”。</description>
    </item>
    
    <item>
      <title>专业术语，行业黑话</title>
      <link>https://blog.v5u.win/post/itblack-profession-word/</link>
      <pubDate>Thu, 09 Aug 2018 15:52:32 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/itblack-profession-word/</guid>
      <description>专业术语，行业黑话总结，解释
软件开发 jQuery插件
两个问题：什么是jQuery插件？jQuery插件如何使用？
第一个问题，jQuery插件就是用来扩展jQuery原型对象的一个方法，简单来说就是jQuery插件是jQuery对象的一个方法。其实回答了第一个问题，也就知道第二个问题的答案了，jQuery插件的使用方式就是jQuery对象方法的调用。</description>
    </item>
    
    <item>
      <title>Xcode-debug-view-hierarchy</title>
      <link>https://blog.v5u.win/post/xcode-debug-view-hierarchy/</link>
      <pubDate>Fri, 03 Aug 2018 10:34:49 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/xcode-debug-view-hierarchy/</guid>
      <description>Xcode 教程之调试视图层次结构 Xcode开发，当我们需要调整/检查UI时正确的处理方式是什么？
答案：debug view hierarchy
P.s. 下面是为什么要使用debug view hierarchy，没时间的读者自行略过
很多人知道
很多人不知道
很多人知道仅仅了解了一下
少部分的人知道了解，并经常用它辅助开发。
范子属于知道作为新功能仅仅了解了一下。包括之前的Mac软件reveal。
因为实际的开发过程中，并不是很关心UI的处理，毕竟前期要先保证业务逻辑正确，后期还有调整&amp;amp;测试UI的过程。
然而在这次的产品在上线之前临时提出调整UI的需求，在调整UI的过程中，让范子重新审视了一下自己画UI的过程是否合理。
其实范子之前就知道自己画UI很不用心，或者说没有给予足够的重视，在整个产品开发过程中，经常出现后期调整，耽误工程进度的情况。
这次的反思并不是因为影响进度，而是基于自身的编码习惯的反思审视。我们可以通过debug view hierarchy一次完成完美的代码布局，并以此优化自己代码布局逻辑，其实是有助于提升自己的编码水平的。
以前是因为没有合适的工具比如reveal收费昂贵。现在Xcode早就原生支持了，那么我们也就不应错过这个可以提升效率的工具。
完！</description>
    </item>
    
    <item>
      <title>程序员成长书录</title>
      <link>https://blog.v5u.win/post/read-booklist-for-program/</link>
      <pubDate>Wed, 01 Aug 2018 18:29:31 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/read-booklist-for-program/</guid>
      <description> 《程序员修炼之道》1 《人月神话》2   经验这个东西，往往并不能告诉我们什么一定对，但是可以告诉我们什么一定不对。这本书完全是经验凝成，没有大道理，没有新观念。这些朴素的道理就是创造一个合格软件和作一个好程序员所必须了解的。这本书涉猎的范围相当广，如何设计架构，如何思考问题，如何测试，如何编码，如何处理文档&amp;hellip;如果细心琢磨，构建软件的所有主干和细微枝节都有所涉及。 [return] 人月在软件工程中是用来评估软件复杂度的单位——&amp;gt;即一人一月的工作量.本书讲的是软件工程相关的东西。 [return]   </description>
    </item>
    
    <item>
      <title>npm-scripts.md</title>
      <link>https://blog.v5u.win/post/nodejs-npm-scripts/</link>
      <pubDate>Tue, 17 Jul 2018 16:47:27 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/nodejs-npm-scripts/</guid>
      <description>scripts是npm的脚本编辑的地方，不是node的 所以在package.json中scripts的命令行使用方式是这样的，如下 npm run start
 &amp;quot;scripts&amp;quot;: { &amp;quot;start&amp;quot;: &amp;quot;node ./bin/www&amp;quot; },  详细使用方法请参考http://www.ruanyifeng.com/blog/2016/10/npm_scripts.html</description>
    </item>
    
    <item>
      <title>Linux版本使用总结</title>
      <link>https://blog.v5u.win/post/system-linux%E7%89%88%E6%9C%AC%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/</link>
      <pubDate>Mon, 16 Jul 2018 00:00:00 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/system-linux%E7%89%88%E6%9C%AC%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/</guid>
      <description>Linux版本使用总结
社区系 Debian9 没有中文系统，中文输入法。通病，没有内置Apache Ubuntu18 gnome3卡，虚拟机不支持全屏，没有内置Apache，放弃 Ubuntu14 桌面美观，完成度高 deepin深度 桌面美观，完成度高，虚拟机卡，UI优化，gnome味道 mint 18 桌面美观，完成度高，卡，UI优化，gnome味道，同deepin体验类似  红帽系 Fedora 26 RDHL试验田，源库变动频繁，放弃 centos7 很好，配置完ssh Apache  </description>
    </item>
    
    <item>
      <title>iterm比terminal好在哪里？</title>
      <link>https://blog.v5u.win/779.html</link>
      <pubDate>Thu, 12 Jul 2018 02:38:00 +0000</pubDate>
      
      <guid>https://blog.v5u.win/779.html</guid>
      <description>iterm比terminal好在哪里？ 为什么要用iterm  多窗口切换 command + T 同个窗口横向分屏 command + d 同个窗口，竖向分屏 command + shift + d 自动补齐命令 comm + ; 直接打开文件 按住command键并点击文件名 (ps: terminal用open命令也可以) 自动复制 直接双击需要复制的文字，即可自动复制 设置主题配色 在偏好设置里进行一些基本的颜色设置，在GitHub上下载做好的主题，导入。 (ps: 成品自由度高👍，合心意的需要手动配置-&amp;gt;terminal也可以手动配置)  这么好的东西我还是用terminal好了。</description>
    </item>
    
    <item>
      <title>写代码原则整理</title>
      <link>https://blog.v5u.win/post/system-%E5%86%99%E4%BB%A3%E7%A0%81%E5%8E%9F%E5%88%99%E6%95%B4%E7%90%86/</link>
      <pubDate>Sat, 07 Jul 2018 00:00:00 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/system-%E5%86%99%E4%BB%A3%E7%A0%81%E5%8E%9F%E5%88%99%E6%95%B4%E7%90%86/</guid>
      <description> 写代码原则整理：
写直观的代码 我写代码有一条重要的原则：如果有更加直接，更加清晰的写法，就选择它，即使它看起来更长，更笨，也一样选择它。
 防止过度工程的原则  王垠根据这些，我总结出来的防止过度工程的原则如下：
 先把眼前的问题解决掉，解决好，再考虑将来的扩展问题。 先写出可用的代码，反复推敲，再考虑是否需要重用的问题。 先写出可用，简单，明显没有bug的代码，再考虑测试的问题。  </description>
    </item>
    
    <item>
      <title>论商业名字的重要性</title>
      <link>https://blog.v5u.win/post/life-%E8%AE%BA%E5%95%86%E4%B8%9A%E5%90%8D%E5%AD%97%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7/</link>
      <pubDate>Sat, 07 Jul 2018 00:00:00 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/life-%E8%AE%BA%E5%95%86%E4%B8%9A%E5%90%8D%E5%AD%97%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7/</guid>
      <description>论商业名字的重要性
源起：同一篇文章，我在两个最知名的汽车论坛上同时投稿：汽车之家，易车。3个小时后查看评论量。
汽车之家 ：4，易车：0.
由此推断出一个结论：论坛活跃度,汽车之家 &amp;gt; 易车。
然后想到了一个问题，是什么影响了这两个网站的活跃度？
脑海中闪现的第一个年头是名字。是名字影响的。
那名字是如何影响用户行为偏好的呢？
与我而言，汽车之家，站如其名，是一个关于汽车以前相关的集合，比之于家。
那在家中我们做什么事情呢？我们和朋友讨论什么东西如何选择（购买），和邻居讨论这个东西如何使用（保养，改装，售后），和家人讨论自己真正的需求（前期测评）。所以，汽车之家不过是将这种行为拓展到了网上。
那易车是什么感觉？对于一个小白来说，意味着交易车辆的地方，哦，这个网站就是交易车辆的地方，所有和汽车交易相关的东西是这个网站的定位。比如：汽车交易市场。在汽车交易市场我们，看车，选车，买车。听别人嘚啵嘚，各种介绍。这是完全不同于家的体验。
所以对于用户来说，怎么使用这两种网站就很明显了，你想买个车：想听官方的洗脑，来易车。想听邻里的感受，来之家。然后呢，买车之后怎么办，当然汽车之家，因为汽车交易市场不是交流家长里短（用车感受）的地方。
就名字所隐喻的范围人群和场景而言，很明显汽车之家 &amp;gt; 易车。这大概也是为什么汽车之家的活跃度大的原因吧。</description>
    </item>
    
    <item>
      <title>编程语言特性汇总</title>
      <link>https://blog.v5u.win/768.html</link>
      <pubDate>Tue, 03 Jul 2018 10:23:27 +0000</pubDate>
      
      <guid>https://blog.v5u.win/768.html</guid>
      <description>语言特性汇总：
 类型推导， 类型检查， 惰性求值 currying 闭包 OO lambda  </description>
    </item>
    
    <item>
      <title>语言特性汇总</title>
      <link>https://blog.v5u.win/post/system-%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7%E6%B1%87%E6%80%BB/</link>
      <pubDate>Tue, 03 Jul 2018 00:00:00 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/system-%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7%E6%B1%87%E6%80%BB/</guid>
      <description>语言特性汇总：
 类型推导， 类型检查， 惰性求值 currying 闭包 OO lambda  </description>
    </item>
    
    <item>
      <title>Apache使用总结</title>
      <link>https://blog.v5u.win/post/system-apache%E6%80%BB%E7%BB%93/</link>
      <pubDate>Mon, 02 Jul 2018 00:00:00 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/system-apache%E6%80%BB%E7%BB%93/</guid>
      <description>Apache总结
http.conf配置
开启/关闭目录索引
&amp;lt;Directory &amp;quot;D:/Apache/blog.phpha.com&amp;quot;&amp;gt; Options Indexes FollowSymLinks # 修改为: Options FollowSymLinks #Indexes 的作用就是当该目录下没有 index.html 文件时，就显示目录结构，去掉 Indexes ，Apache 就不会显示该目录的列表了。 AllowOverride None Order allow,deny Allow from all &amp;lt;/Directory&amp;gt;  </description>
    </item>
    
    <item>
      <title>PHP工程总结</title>
      <link>https://blog.v5u.win/post/php%E5%B7%A5%E7%A8%8B%E6%80%BB%E7%BB%93/</link>
      <pubDate>Mon, 02 Jul 2018 00:00:00 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/php%E5%B7%A5%E7%A8%8B%E6%80%BB%E7%BB%93/</guid>
      <description>PHP工程总结
 使用session需要调用session_start()手动开启环境，session_start()调用之前页面不允许输出任何内容，包括空格 sql语句 执行exec(),查询使用query() order不能作为表名称，这是关键字 获取最后一条插入数据 id使用PHP内置的方法调用: $db-&amp;gt;lastInsertRowID();插入一条数据后获取此条数据id。 $\sum_{i=1}^{n}\sqrt{i+\sin(i)}$ include 和 require 除了处理错误的方式不同之外，在其他方面都是相同的：  require 生成一个致命错误（E_COMPILE_ERROR），在错误发生后脚本会停止执行。 include 生成一个警告（E_WARNING），在错误发生后脚本会继续执行。  增 删 改updateRow(tablename, id, key-values ) 查 ```mysql 单表查询: select * from A where to_days(A.create_time)=to_days(&amp;lsquo;2018-10-09&amp;rsquo;)  两表联查: select * from A inner join user on A.uid=B.uid where to_days(A.create_time)=to_days(&amp;lsquo;2018-10-09&amp;rsquo;)
三表联查: select * from ((A left join B on A.orderId = B.id) left join C on B.uid=C.uid) where to_days(A.create_time)=to_days(&amp;lsquo;2018-10-09&amp;rsquo;)
三生万物，只有推到3，才能找到规律，推及万物
11. 遇到问题： unable to open database file ，  原因为:当前文件夹的文件权限，需要为可读可写.</description>
    </item>
    
    <item>
      <title>mac虚拟机上的centos 7实现ssh连接</title>
      <link>https://blog.v5u.win/763.html</link>
      <pubDate>Sat, 30 Jun 2018 08:57:11 +0000</pubDate>
      
      <guid>https://blog.v5u.win/763.html</guid>
      <description>mac虚拟机上的centos7实现ssh连接
 查看是否安装ssh rpm -qa | grep ssh（一般都内置了）
 配置sshd_config文件 /etc/ssh/sshd_config
Port 22
ListenAddress 0.0.0.0
ListenAddress ::
 防火墙配置
 安装iptables: yum install iptables-service 配置防火墙文件：vim /etc/sysconfig/iptables 关闭防火墙：systemctl restart iptables.service systemctl enable iptables.service //设置防火墙开机启动   安装netstat：yum install net-tools （查看监听端口：netstat -ntpl | grep 22）
 关闭虚拟机，设置虚拟机网络为host-only方式，virtualbox需要设置全局设置
 cmd+,-&amp;gt;网络-&amp;gt;仅主机(host-only)网络 添加网络   查看虚拟机ip地址，ip ip addr
 主机找到可以ping 通的ip
 ssh登录 ssh root@192.168.xx.xx
  </description>
    </item>
    
    <item>
      <title>centos7 更改系统启动模式</title>
      <link>https://blog.v5u.win/753.html</link>
      <pubDate>Tue, 26 Jun 2018 01:51:41 +0000</pubDate>
      
      <guid>https://blog.v5u.win/753.html</guid>
      <description>centos7 更改系统启动模式
 查看当前启动模式 systemctl get-default 查看配置文件 cat /etc/inittab 设置启动模式为命令行模式 systemctl set-target multi-user.target 重启 shutdown -r now  </description>
    </item>
    
    <item>
      <title>centos7 PHP7环境配置</title>
      <link>https://blog.v5u.win/751.html</link>
      <pubDate>Tue, 26 Jun 2018 01:50:27 +0000</pubDate>
      
      <guid>https://blog.v5u.win/751.html</guid>
      <description>centos7 PHP7环境配置 目录 1. 开启22端口2. 创建其他用户，使用其他用户ssh登录（root账户禁止登录）3. 关闭防火墙4. 关闭selinux5. 安装Apache6. 安装MySQL7. 安装PHP7.28. 配置 [TOC]
 开启22端口
 创建其他用户，使用其他用户ssh登录（root账户禁止登录）
  ssh test@10.211.55.5 (使用eth0网卡IP)
 关闭防火墙
centos7 默认使用firewalld，不在内置iptables //临时关闭 systemctl stop firewalld //禁止开机启动 systemctl disable firewalld
 sudo yum -y install iptables-services
 sudo vi /etc/sysconfig/iptables
 systemctl restart iptables.service （重启）
 systemctl enable iptables.service （开机自启动iptables）注：并不能开机自动关闭firewalld
 关闭selinux
  gedit /etc/sysconfig/selinux
 安装Apache
 sudo yum install httpd
 sudo service httpd start</description>
    </item>
    
    <item>
      <title>Apache不能访问directory 目录</title>
      <link>https://blog.v5u.win/740.html</link>
      <pubDate>Mon, 28 May 2018 06:14:25 +0000</pubDate>
      
      <guid>https://blog.v5u.win/740.html</guid>
      <description>Mac升级了系统，发现启动了Apache，可以访问index.php文件。 当目录下找不到文件的时候，应该显示Indexes目录， 此时报错Forbidden 403 You don&#39;t have permission to access /www on this server 原因是Apache2.2版config默认设置是：
&amp;lt;Directory /&amp;gt; AllowOverride none Allow from all &amp;lt;/Directory&amp;gt;  Apache2.4 config默认设置是：
&amp;lt;Directory /&amp;gt; AllowOverride none Require all denied &amp;lt;/Directory&amp;gt;  最佳方案，目标&amp;lt;Directory&amp;gt;下设置文件访问权限为: Allow from all 参考：https://www.zyxware.com/articles/4550/solved-forbidden-you-dont-have-permission-to-access-on-this-server</description>
    </item>
    
    <item>
      <title>gitbook如何生成epub</title>
      <link>https://blog.v5u.win/736.html</link>
      <pubDate>Wed, 23 May 2018 15:44:43 +0000</pubDate>
      
      <guid>https://blog.v5u.win/736.html</guid>
      <description>全局安装gitbook ：npm install -g gitbook 下载calibre安装应用 将calibre中的执行文件ebook-convert链接到shall环境：$ sudo ln -s /Applications/calibre.app/Contents/MacOS/ebook-convert /usr/local/bin 验证ebook-convert可用，terminal下输入ebook-convert 后回车 如果可用，导出epub文件 gitbook epub ./ ./mbook.epub  node: gitbook项目需要先npm install,在生成epub</description>
    </item>
    
    <item>
      <title>ternimal</title>
      <link>https://blog.v5u.win/734.html</link>
      <pubDate>Fri, 18 May 2018 08:53:16 +0000</pubDate>
      
      <guid>https://blog.v5u.win/734.html</guid>
      <description>暴力删除文件：输入 sudo rm -rf .Trash 再输入密码后 Enter 。 mac 设置软件安装安全级别 sudo spctl &amp;ndash;master-disable 文件权限修改
 文字设定法 chmod [who] [+ | - | =] [mode] 文件名?
 mkdir code
修改权限的命令格式 chmod [&amp;lt;权限范围&amp;gt;&amp;lt;权限操作&amp;gt;&amp;lt;具体权限&amp;gt;] [文件或目录…] &amp;lt;权限范围&amp;gt; u：User，即文件或目录的拥有者。 g：Group，即文件或目录的所属群组。 o：Other，除了文件或目录拥有者或所属群组之外，其他用户皆属于这个范围。 a：All，即全部的用户，包含拥有者，所属群组以及其他用户。 &amp;lt;权限操作&amp;gt; +：表示增加权限 - ：表示取消权限 =：表示唯一设定权限 &amp;lt;具体权限&amp;gt; r：表示可读取 w：表示可写入 x ：表示可执行 例：chmod o+w 111.txt   打开当前文件夹 open . 打开当前文件用指定的软件 open -a Sublime\ Text Podfile (open -a app_name file_name)</description>
    </item>
    
    <item>
      <title>车险</title>
      <link>https://blog.v5u.win/731.html</link>
      <pubDate>Thu, 17 May 2018 09:40:11 +0000</pubDate>
      
      <guid>https://blog.v5u.win/731.html</guid>
      <description>续保的保费计算逻辑 商业险 一般来说，车主在第一年只要符合下面的这些情况就可以享受降价的好处：
首先，第一年你得没有出险。
其次，出险的次数要少于两次，包含有两次。
最后，第一年的额赔付金额需要低于保险金额。
车主要符合以上三种情况才有资格在第二年享有优惠。否则，就不能享有优惠。
交强险 打个比方说，张先生在第一年驾驶车的时候都没有出过什么以外，也就是没有出险， 那么到了第二年，交强险的价格就会在第一年的基础上少10%， 到了第三年，价格就会下降到原先价格的80%。 但倘若第一年除了事情，第二年交费的时候还和第一年一样，没什么变化， 但如果出了两次事情，就得多交10%了。这是汽车出险第二年保费中的一种。
还有一点需要特别指出的是，如果车主在驾驶的过程中出现了酒驾的情况，那么交强险还会上涨。
各家保险公司比较 阳光车险：三者，车损，交强，无法找到第三人(特色，价低)，16项福利，首次高速送油5L免费，一闪赔。线上视频定损，先钱后修，不要发票，不限修理厂。</description>
    </item>
    
    <item>
      <title>如何增加见识，提高格局</title>
      <link>https://blog.v5u.win/724.html</link>
      <pubDate>Mon, 23 Apr 2018 05:43:54 +0000</pubDate>
      
      <guid>https://blog.v5u.win/724.html</guid>
      <description>一个原则：增加经历—— 不管是经历人还是事，哪个方面都算。 具体办法： 交朋友。了解别人眼中的世界，经历小圈子，小社交的人情处事 旅游。经历社会，自然的世界 读书。经历牛逼的人升华后的世界 工作。经历不同：公司，行业，职位</description>
    </item>
    
    <item>
      <title>brew gem npm cocoapods</title>
      <link>https://blog.v5u.win/post/mac-brew-gem-npm-cocoapods/</link>
      <pubDate>Fri, 20 Apr 2018 05:00:32 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/mac-brew-gem-npm-cocoapods/</guid>
      <description>Mac上的包管理器 常用的有：brew gem npm cocoapods pip3 * brew 用来管理Unix相关工具软件，就像centos之于yum，Ubuntu之于apt-get * gem 即RubyGems,管理ruby社区的软件包。 * npm 是nodejs的包管理器，用来管理nodejs社区的软件包。 * pip 是Python的包管理器，用来管理Python社区的软件包 * cocoapods 是iOS开发的包管理器，用来管理iOS代码包</description>
    </item>
    
    <item>
      <title>古代读书人的学习流程</title>
      <link>https://blog.v5u.win/719.html</link>
      <pubDate>Thu, 19 Apr 2018 09:38:27 +0000</pubDate>
      
      <guid>https://blog.v5u.win/719.html</guid>
      <description>我内亲一家是清代有名的科举世家，从清初到晚清，号称“代有闻人”，十代九进士。他们家在晚清留下过一张单子，大概就是所谓家学流程。单子虽然不方便发图上来，但是可以大概总结一下，不过其中书籍很多都是清中叶的。 家学内容： 学龄前由内亲内眷（姑、姨、姐）开蒙，教“字号”（即单字的大字）。【注：似乎别人家也有父母教的，但是这家只让内亲内眷教。】 六学入家学念书：六学开始：《三字经》、《小学集解》、《龙文鞭影》、《幼学琼林》。八岁开始：四书、《孔子家语》、《孝经》。 十岁开始：《诗义折中》、《书经图说》。并开始学对对子与缀句，进而诗赋。 十二岁开始：《周易折中》、《礼记》、《春秋》、《尔雅》、《说文》。 十几岁开始：《古文观止》、《古文释义》、《文章轨范》、《古文笔法百篇》、《古唐诗合解》、《赋学正鹄》、《骈体文钞》、《六朝文絜》、《昭明文选》。 再之后：前三史、《资治通鉴》、《通鉴辑览》、《纲鉴易知录》、《史论》。 习字：六学开始描红，用自家某代祖先特制的四孔格，共三十二字。 八岁开始小楷行书：先选《词林二妙》中一家学习，再临唐晋小楷。 作者：橘玄雅 链接：https://www.zhihu.com/question/20901379/answer/77825216 来源：知乎 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</description>
    </item>
    
    <item>
      <title>注、疏、解、记、典、经、传</title>
      <link>https://blog.v5u.win/715.html</link>
      <pubDate>Tue, 17 Apr 2018 09:18:10 +0000</pubDate>
      
      <guid>https://blog.v5u.win/715.html</guid>
      <description>古文考据，遣词造句。 （一）传注类（诂、训、传、注、笺等） 1.诂、训这两个名称，笼统说来没有什么区别，凡侧重于字词、名物解释的，一般称作“诂” （通作“故”）、“训”。 2.传，是传述的意思。传原本指解释儒家六经的书。 3.注，是注释的通称。“注”与“传”一脉相承，“注”的名称大致始于东汉郑玄。郑玄对 “三礼”有注，其书称“注”，含有对师儒谦下之意。古代经与注本分离，东汉以来，始经、 注合载，就经下注。 4.笺，是表识的意思。作为注释体，“笺”的名称始于郑玄。郑玄有《毛诗笺》，为《毛诗诂训传》作注。 （二）章句类 章句之名，是离章辨句的省称，是分析古书章节句读的意思。刘师培《国语发微》说：“章句之体，乃分析经文之章句者也。”作为一种注释，章句不像传注类注释那样以解释词义为主，而着重于逐句逐章串讲、分析大意。今仅存东汉赵歧的《孟子章句》，王逸的《楚辞章句》。 （三）义疏类 义疏，是疏通其义的意思。这是一种既释经文，又兼释注文的注释。 义疏兴起于魏晋南北朝，唐人“正前人之疏义，奉诏列裁，定名曰正。”（黄承吉《左传旧疏考证序》）因而义疏在唐代又称作“正义”，也称作“疏”。 （四）集解类 集解类注释是汇集众说并加上编者意见的一种注释。包括集注、集传、集释等。 如 何晏的《论语集解》，朱熹的《孟子集注》、《诗集传》，郭庆藩的《庄子集释》即是。需要指出的是，晋杜预的所撰《春秋经传集解》，名为“集解”，但它只是将《春秋经》和《左氏传》聚集在一起进行注解，与上面所说的汇集众说的“集解”名同实异。 这里附带讲一下补注。补注类注释有补、补疏、补释、补义、补正等名称，这是一种对 前人注释作补充、订正的注释。宋洪兴祖《楚辞补注》就是这类著作。 （五）音义类 音义是一种注音释义的著作，兴起于魏晋，另有音训、音诂、音注、音解、音证、音隐、音释等名称。唐陆德明的《经典释义》由《周易音义》、《尚书音义》、《毛诗音义》、《周礼音义》等十四部典籍的音义组成，是音义类注释的代表作。这类著作以注音为主，有时兼有简单释义，或指出经典不同版本的异文现象。音义书在给多音多义的词注音时，注音本身即暗含着释义，这是应该注意的。 作者：木瓷 链接：https://www.zhihu.com/question/28458046/answer/40951778</description>
    </item>
    
    <item>
      <title>孩子多大能办身份证？</title>
      <link>https://blog.v5u.win/711.html</link>
      <pubDate>Mon, 16 Apr 2018 08:16:03 +0000</pubDate>
      
      <guid>https://blog.v5u.win/711.html</guid>
      <description>孩子多大能办身份证？ 根据派出所的规定，只要孩子愿意办身份证，16岁以下也可以办理，但是需要在家长或监护人的陪同下办理，并且有效期只有5年，当然，这其中也包括新生儿可以办理身份证。 1/孩子多大能办身份证 答：办理身份证不受年龄限制！ 孩子出生后，持出生证明、父母结婚证、准生证到派出所报户口，就会有相应的身份证号； 现在未成年人也可以办理身份证的，没有年龄限制。 16岁以下办理身份证，须在家长或监护人陪同，有效期为5年。 16岁以上的，本人办理，初次有效期10年，26岁以后有效期为20年，46岁以后终身有效。 2/新生儿能办身份证吗？ 答：能办 幼儿身份证就是在未满十六周岁的少年儿童自愿的情况下，申请办理的身份证件，这类身份证必须由家长陪同才能办理，而且有效期只有五年。有了儿童身份证，在很多需要身份证明的场合，不需要再出示户口本，有身份证即可。 未成年人办理身份证，首先要遵循该未成年人自主自愿的原则，在父母的陪同下去办理。 过程： 1、未成年人如何办理身份证 儿童身份证办理流程 2、所需要的证件有：父母的身份证、孩子的户口簿、孩子的出生证明、学籍证明（未上学的可以不必带），以上证件均为原件。 未成年人如何办理身份证 儿童身份证办理流程 3、带齐上述证件之后，带着孩子到户籍所在派出所申请办理即可，一般需要缴纳20元的费用，等待一个月左右取证。领取身份证时，需要带着户口本和取证单据。 注意事项： 1、在申请身份证的时候，孩子要穿着深色有领子的上衣，和我们成人申请身份证的要求相同。 2、未成年人如何办理身份证 儿童身份证办理流程 3、拍摄身份证照片时，要求孩子能够单独坐正，不能有旁人的协助，所以，太小的孩子还不适宜申领身份证。 4、儿童身份证的有效期是5年，如果孩子在成长过程中，样貌发生了较大变化，家长需要及时带孩子去更换身份证上的照片，以免造成不必要的麻烦。 3/孩子办身份证流程 如果年满16岁，可以带户口本到户口所在地派出所申请。 流程如下： 1.先去公安机关定点的照相馆拍证件照。要求免冠（不带帽子，如果由眼镜的话最好眼镜也不要带），穿衣服看自己，不过最好不要太花哨。20元/人 2.取得照片后，照片会附一张单子，上面有你的照片编号。这张单子很重要，一定不能弄丢。 3.带上照片和单子、户口册到户口所在地派出所申请办理。交6块钱，然后公安机关会告诉你什么时候去拿。到时候去拿就是了。通常一代换二代是三到四个月。第一次办理的话通常是当年年底拿 4.如果是老身份证换二带，去拿新证的时候要把老证带过去，如果是第一次办就带户口册去拿 5.如果是大学生或其他原因，户口是集体户口的，还需要相关证明 4/新生儿需要办理哪些证 一，出生医学证明 二，入户户口本 三，身份证 四，独生子女证 五，社保 来源https://www.sohu.com/a/127290283_349098</description>
    </item>
    
    <item>
      <title>xcode 头文件引用</title>
      <link>https://blog.v5u.win/707.html</link>
      <pubDate>Thu, 12 Apr 2018 03:43:53 +0000</pubDate>
      
      <guid>https://blog.v5u.win/707.html</guid>
      <description>头文件引用 头文件引用主要由#include 和#import 两种。每种又分为尖括号(&amp;lt;&amp;gt;)引用和双引号(&amp;rdquo; &amp;ldquo;)引用 。 #include 与 #import 的区别是: #import 不会造成重复引用，它会自己检查是否已经引用过，也可以防止递归包含。 尖括号(&amp;lt;&amp;gt;)引用与双引号(&amp;rdquo; &amp;ldquo;)引用的区别是: 双引号(&amp;rdquo; &amp;ldquo;)引用的文件，编译器会首先在存储源文件的同一目录下搜索，如果文件没有找到编译器会搜索默认目录（配置文件中配置的头文件引用目录）。 尖括号(&amp;lt;&amp;gt;)引用 只会在默认目录下搜索。 换句话说 双引号引入的方式其搜索目录的范围要更大，当然效率差一点。 双引号引用范围=源文件目录+默认目录 尖括号引用范围=默认目录</description>
    </item>
    
    <item>
      <title>WordPress4.4之后原生支持REST API</title>
      <link>https://blog.v5u.win/703.html</link>
      <pubDate>Tue, 10 Apr 2018 05:33:11 +0000</pubDate>
      
      <guid>https://blog.v5u.win/703.html</guid>
      <description>WordPress4.4之后REST API 格式:www.网址/wp-json/wp/v2,例：www.v5u.win/wp-json/wp/v2 路由参数有五个，posts,pages,categories,tags,comments。 例：www.v5u.win/wp-json/wp/v2/posts url参数有： per_page(每页记录数)， page(页码), orderby(排序规则), order(排序方式) 例：?per_page=8&amp;amp;page=1&amp;amp;orderby=date&amp;amp;order=desc每页显示8条，第一页，以时间排序，降序展示。 官方文档REST API在这里查看： https://developer.wordpress.org/rest-api/</description>
    </item>
    
    <item>
      <title>WordPress4 如何添加友情链接</title>
      <link>https://blog.v5u.win/700.html</link>
      <pubDate>Tue, 10 Apr 2018 03:11:38 +0000</pubDate>
      
      <guid>https://blog.v5u.win/700.html</guid>
      <description>链接—&amp;gt;创建链接分类目录 —&amp;gt;添加链接 外观—&amp;gt;小工具—&amp;gt;链接—&amp;gt;选择链接分类目录 以前有用友链插件或者自定义菜单目录（Google第一条），发现这些教程有过时了。特意总结后写到这里</description>
    </item>
    
    <item>
      <title>基金A类B类C类是什么意思？</title>
      <link>https://blog.v5u.win/697.html</link>
      <pubDate>Tue, 10 Apr 2018 02:41:38 +0000</pubDate>
      
      <guid>https://blog.v5u.win/697.html</guid>
      <description>货币基金和短期理财债券基金 在货币基金和短期理财债券基金里，最常见的后缀是A和B，它们的差别主要是参与门槛的不同： A类是低申购起点，1分、1元和100元 B类则是高申购起点的，一般水平在500万元，低的也要近百万元。如此，B类基金的销售服务费会低很多，自然收益会高于A类。
但是A、B两类货币基金在费率上也有差别： 货币基金不收取申购和赎回费，A、B两类货币基金的管理费和托管费都一样，唯一区别是B类的销售服务费比A类少一些，当然我们也经常发现，一般B类货基的七日年化收益率相对高一些。 货基也有一类特殊群体——E类份额，是最近几年才出现的。主要是针对销售渠道的区别，有的是对传统销售渠道的和网络销售渠道的区别；有的是对不同销售平台的的区别；也可能是对某一个专门的销售渠道定制的。比如，华夏现金增利E份额专为百度理财定制；诺安天天宝货币E专为同花顺爱基金收益宝定制。 货基里还有一种特例：基民可以按照持有时间进阶，享受不同的销售费率，比如南方现金通货币基金。 债券型基金 债券型基金有A、B和C三个后缀。其中的不同，就是申购和赎回费用的区别。 A类份额：表示前端收费。 B类份额：表示后端收费，根据持有这只基金的时间长短来决定。 值得注意的是：A类和B类，都要收取基金管理费和托管费，不收取销售服务费。 C类份额：前后端都不收费。认购和赎回时，都不需要手续费，它多了一个销售服务费。 股票型基金和混合型基金 股票型基金和混合型基金ABC的后缀和债券型基金的费率模式一样。 A类份额：是基金前段收费模式； B类份额：是基金后端收费模式； C类份额：不收取申购和赎回费，一般情况下要收取0.5%的销售服务费； 那么下面是选择方案建议 在股票型和混合型基金中，A类、B类和C类的管理费和托管费一样，但C类份额的销售服务费一般从基金净值中扣除，前端收费会随着基金申购金额增加而递减，后端收费随着持有基金时间变长而递减。如果基金的操作资金在100万元以内，且在一年内赎进行回的话，就是前段费率小于后端费率，前段收费具有较大优势；如果是长期持有，特别是超过2年以上，后端收费优势则更加明显。 那么C类份额究竟适合那些投资群体呢？ C类份额由于0申购费、赎回费也比较低，故适合那些对资金流动性要求高且投资期限小于一年的投资者。注意，C类份额有销售服务费，而这个费用是基于基金资产净值计算的，所以C类份额的收费不适合基金规模偏大的投资者。 分级基金 分级基金具有三种份额，分别是母份额、A份额（稳健份额）、B份额（激进份额）。 最初，分级基金需要标识，但只靠名字来标识，效果并不理想，如瑞福优先和瑞福进取、银华稳进和银华锐进。最后，还是用A和B区分，更通俗易懂。于是，A代表的就是低风险份额，B代表的就是高风险份额。</description>
    </item>
    
    <item>
      <title>读给年轻互联网人的一些建议总结</title>
      <link>https://blog.v5u.win/695.html</link>
      <pubDate>Sun, 08 Apr 2018 06:14:21 +0000</pubDate>
      
      <guid>https://blog.v5u.win/695.html</guid>
      <description>ReidHoffman的ABZ计划 a: ios组件化，项目化，当下职业发展方向 b: 大前端，全栈创业，文章分享，连接人与事，支线职业知识储备 z: 投资理财，应对最糟糕的情况</description>
    </item>
    
    <item>
      <title>藏酒</title>
      <link>https://blog.v5u.win/692.html</link>
      <pubDate>Sat, 07 Apr 2018 13:09:36 +0000</pubDate>
      
      <guid>https://blog.v5u.win/692.html</guid>
      <description>操作： 容器：陶罐/瓷罐（结构致密不漏，略有微孔，小分子可以渗透） 温度：3-23°C（维持微生物的活性：冬天冰点以上，夏天不可暴晒） 避光：直射阳光杀菌，紫外线杀死酒中活性物质 干燥：湿气会遮挡陶坛上的微孔，甚至反渗入坛，使酒变质 存放：室内柜子下，床下 密封：生胶带（安装水管水龙头用的白色生胶带化学性质稳定，不带胶质，质地柔软且密封性能好，在酒瓶脖子上缠绕几大圈，效果非常出色） 误区： 溶洞、地洞藏酒；酒糟埋酒</description>
    </item>
    
    <item>
      <title>terminal的显示增加色彩</title>
      <link>https://blog.v5u.win/682.html</link>
      <pubDate>Wed, 04 Apr 2018 10:16:29 +0000</pubDate>
      
      <guid>https://blog.v5u.win/682.html</guid>
      <description>打开 .bash_profile文件，添加：
export GREP_OPTIONS=‘—-color=auto’ #如果没有指定，则自动选择颜色 export CLICOLOR=1 #是否输出颜色 export LSCOLORS=Bxfxcxdxbxegedabagacad#指定颜色  LSCOLORS此变量的值描述使用 CLICOLOR 启用颜色时要使用哪种属性的颜色 。该字符串是 fb格式对的串联，其中f是前景色，b是 背景色。
颜色代号如下：
a黑色 b红色 c绿色 d棕色 e蓝色 f洋红色 g青色 h浅灰色 黑色粗体，通常显示为深灰色 B粗体红色 C粗体绿色 D粗体棕色，通常显示为黄色 E粗体蓝色 F粗体洋红色 G加粗青色 H加粗浅灰色; 看起来像明亮的白色 x默认前景或背景
请注意，以上是标准的ANSI颜色。实际 显示可能根据 使用中的终端的颜色能力而不同。
属性的顺序如下：
1.目录 2.符号链接 3.套接字 4.管道 5.可执行 6.块特殊 7.字符特殊 8.可执行与setuid位设置 9.可执行与setgid位设置 10.目录可写给其他人，粘性位 11。目录可写给其他人，没有粘性 位
默认为“exfxcxdxbxegedabagacad”，即 常规目录的 蓝色前景和默认背景，setuid执行的黑色前景和红色背景 等。</description>
    </item>
    
    <item>
      <title>xcode文档注释规则简要汇总</title>
      <link>https://blog.v5u.win/676.html</link>
      <pubDate>Wed, 04 Apr 2018 08:24:46 +0000</pubDate>
      
      <guid>https://blog.v5u.win/676.html</guid>
      <description>xcode文档注释规则简要汇总 参考源 类与协议
/** 文档B. * * 文档B的详细描述. */ @interface DocB : NSObject /// 文档A. @interface DocA : NSObject  文本链接
/** * - [文档B](DocB) : 类的链接文本.（仅appledoc） */  单行注释
///# 标题1 ///## 标题2 ///hello oc，下面的空行是为了换行 /// ///hello swift /// - 这里使用了无序列表 /// - 使用加粗 **this**， 使用斜体 _this_ /// - 添加一个链接: [百度](http://www.baidu.com) /// - 添加一个图片:![swift picture](http://img0.imgtn.bdimg.com/it/u=14209024,814391630&amp;amp;fm=21&amp;amp;gp=0.jpg )  多行注释文档
/** 多行注释文档相比于普通多行注释多了一个星号。 在这里可以使用markDown语法，书写各种提示信息 如：显示一个有序列表 1. 有序列表 2. 有序列表 3. 有序列表 */  方法/函数的注释 方法的注释包括传入参数、返回值、和异常等说明</description>
    </item>
    
    <item>
      <title>appledoc使用说明</title>
      <link>https://blog.v5u.win/673.html</link>
      <pubDate>Wed, 04 Apr 2018 07:00:34 +0000</pubDate>
      
      <guid>https://blog.v5u.win/673.html</guid>
      <description>appledoc使用说明 安装命令行：
 git clone git://github.com/tomaz/appledoc.git cd ./appledoc sudo sh install-appledoc.sh appledoc —version //检查successed  使用 生成HTML 当需要html文档时，可以加上“&amp;ndash;no-create-docset”——
appledoc --no-create-docset --output ~/doc --project-name &amp;quot;DrowRect&amp;quot; --company-id &amp;quot;com.jinyuyoulong&amp;quot; --project-company &amp;quot;jinyuyoulong&amp;quot; ./  注: &amp;ndash;output ./doc：设置输出目录为“./doc”。 &amp;ndash;project-name objcdoc：设置项目名为“DrowRect”。 &amp;ndash;project-company &amp;ldquo;jinyuyoulong&amp;rdquo;：设置公司名为“jinyuyoulong”。 &amp;ndash;company-id &amp;ldquo;com.jinyuyoulong&amp;rdquo;：设置公司id为“com.jinyuyoulong”。 ./：当前目录。 生成docset 此路不通
appledoc --output ./doc --project-name &amp;quot;DrowRect&amp;quot; --project-company &amp;quot;jinyuyoulong&amp;quot; --company-id &amp;quot;com.jinyuyoulong&amp;quot; ./  Xcode脚本生成文档 Xcode 配置
 add new target —&amp;gt;选择Other—Aggregate，命名为docText
 Build Phases + run script
 编辑run script的内容</description>
    </item>
    
    <item>
      <title>iOS indexPath.item vs indexPath.row</title>
      <link>https://blog.v5u.win/669.html</link>
      <pubDate>Mon, 02 Apr 2018 06:25:02 +0000</pubDate>
      
      <guid>https://blog.v5u.win/669.html</guid>
      <description>Inside NSIndexPath, the indexes are stored in a simple c array called &amp;ldquo;_indexes&amp;rdquo; defined as NSUInteger* and the length of the array is stored in &amp;ldquo;_length&amp;rdquo; defined as NSUInteger. The accessor &amp;ldquo;section&amp;rdquo; is an alias to &amp;ldquo;_indexes[0]&amp;rdquo; and both &amp;ldquo;item&amp;rdquo; and &amp;ldquo;row&amp;rdquo; are aliases to &amp;ldquo;_indexes[1]&amp;rdquo;. Thus the two are functionally identical. In terms of programming style – and perhaps the definition chain – you would be better using &amp;ldquo;row&amp;rdquo; in the context of tables, and &amp;ldquo;item&amp;rdquo; in the context of collections.</description>
    </item>
    
    <item>
      <title>pycharm如何添加 local venv</title>
      <link>https://blog.v5u.win/666.html</link>
      <pubDate>Fri, 30 Mar 2018 03:20:02 +0000</pubDate>
      
      <guid>https://blog.v5u.win/666.html</guid>
      <description>需求：pycharm为项目添加已经存在的venv虚拟环境 前几天学习Django，开始是terminal + sublime text。后来学的差不多了，想想做项目还是得上pycharm，所以开始折腾。 说明，pycharm create project是会询问是否创建新的venv的，换句话说，其实pycharm是建议设置基础引用Python版本，然后在他的基础上，每个项目都有自己的venv。这种策略很好，每个项目的环境互不干扰。奈何范子处于学习阶段，local项目已经有了本地的venv，不需要重新创建。这时候我就需要考虑如何添加一个local venv。 然而道路颇多波折，localvenv的path是确切知道的，但是在pycharm的configurations中Python interperter是一个选择栏，而没有添加栏。这就尴尬了！ 万幸经过摸索，在设置中（Mac版 cmd+,）发现是可以添加的 在这里添加好了之后，在返回configurations，出现了新的选项，选择就可以了。</description>
    </item>
    
    <item>
      <title>范蠡传</title>
      <link>https://blog.v5u.win/642.html</link>
      <pubDate>Mon, 19 Mar 2018 08:19:12 +0000</pubDate>
      
      <guid>https://blog.v5u.win/642.html</guid>
      <description>分事略记 学艺 范蠡生卒约为孔子同时期，出身贫寒。父母早亡，由哥嫂扶养成人。范蠡小时天资聪慧，博闻强识，喜读书，抱负大，不喜耕作，众乡邻不齿。范蠡说：“你们怎么知道我的志向呢？”他苦读了《书》、《易》、《诗》等大量的书籍，学到了许多历史知识和治国安邦的理论。范蠡不仅弄通了风后的《握奇经》，还潜心钻研了姜太公的军事书籍《六韬》和《三略》。姜太公把大力发展农业、手工业和商业作为军事韬略的三***宝，这一点范蠡特别推崇。后来范蠡无论是治家还是治国，姜太公的思想对其影响都很大。
当时著名的理财家计然（计然，名研，姓辛，字文子，著有《文子》一书，春秋时期名人），到南阳云游，范蠡拜其为师，跟他学习经济知识和经商技巧。 范蠡虽满腹经纶，但当时楚国政治黑暗，选拔官吏，非贵族阶层不得做官。范蠡空有文才而不被任用。报国无门，使得范蠡放浪形骸，做事办事不合时宜，作出的事情往往令人惊诧不已，疯疯癫癫，行为怪异，被誉为有名的“楚国狂人”，乡邻们喊他为“范疯子”。  范蠡狗洞遇文种 楚荆王时，楚国名士文种（字子禽，楚国郢人）到宛任令，听说范蠡年纪不大，但很有才能，就差官员去拜访他。手下人回来说：“范蠡行为怪异，疯疯癫癫是个疯子，不值得邀请。”文种却说：“一个人有才能，必假装疯狂，来掩盖其贤德。”此后多次拜访，范蠡都避而不见。这一天，文种又亲自拜访，却发现范蠡的大门紧闭，正要下车，忽见院墙下的一个破洞里有个人蓬头垢面，趴在那里冲着文种学狗叫。手下人便说：“这就是范蠡。”众乡邻都围着看热闹。文种手下的人怕文种难堪，忙用宽大的衣袖把洞遮住。文种却说：“我听说过狗只对着人叫，他是个人身，却对着我学狗叫，意思是说我是个人，是看得起我呀！”于是文种下车便拜，范蠡看也不看，文种只好悄然离去。 第二天，范蠡对其哥嫂说：“今天有贤人来拜访我，请借给我一套干净衣帽。”刚穿戴梳洗完毕，文种就来了。两人交谈后，方觉相见恨晚，结为终身知己。这就是我们南阳广为流传的“范蠡狗洞遇文种”故事。 这时，楚国的政治更加黑暗，有才之士得不到重用，两人的政治抱负眼看无法实现，就商量着要离开楚国，另投贤明，实现政治抱负。因伍子胥已投奔了吴国，于是两人就投奔了越国，遂受到越王的重用，成为越王勾践的左膀右臂。 商人的来历 范蠡认识文种后，生活发生了很大改变，就到处云游、拜访贤人，并开始经商。一次到了商洛，商洛离淅川很近，据说是中国最早发明青铜器的地方。商洛当时生产的青铜器具很精美，远近闻名，当时上至豪门，下至百姓都以使用青铜器为荣耀。范蠡打听到邻近的秦国需求量大。范蠡想：物以稀为贵，如果把商洛的青铜器运到秦国，肯定能够牟取高利。范蠡于是就雇了很多牛车和人，到商洛地区去收集青铜器，到秦国去卖。在去秦国的时候，为了标明身份，就在牛车上和青铜器上都铸个“商”字，“商”的意思是“买卖”。 到了秦国国都咸阳，秦人看到牛头上写着“商”字，青铜器上铸着“商”字，加上一件件器具光亮耀眼，精美绝伦。于是人们都叫着“商人来了”、“商人来了”，不一会儿，就把器具抢购一空。“商人”后来就成为买卖商品人的代称，“商人”的名称由此而来。范蠡是中国最早的商人之一。 范蠡与西施 越王勾践三年，勾践想攻打吴国，范蠡劝阻不听，结果被吴打败。吴国围困勾践于会稽山上，越国面临着亡国的危险，范蠡出计，让文种去议和，刚开始吴王不答应，通过贿赂吴国的太宰喜否，议和成功。越国保住了，但吴王夫差提出勾践必须到吴国为人质。 吴王夫差好色，为投其所好，消磨敌人的斗志，麻痹对方，范蠡向勾践献策：用美人计。勾践同意了，下令在全国遍寻美女上报朝廷。最后各地共报上美女20多个，范蠡亲自去挑选，选出了容貌最美的一个女子———西施。西施是越国苎罗（今浙江诸暨南）人。苎罗山有东西两村，两村人大多姓施，她住西村，故称西施。西施是个绝色美女，其容貌之美，方圆皆知。西施不但貌美，而且深明大义，是一个爱国之人。西施与范蠡几经交往，相互产生爱意，但为了越国就答应前往吴国。范蠡先带西施来到越国国都。快到越国都时，城中的百姓听说西施貌美，纷纷出城来到郊外，想一睹西施的美貌。 范蠡见人多拥挤，道路堵塞，便将西施安排到城外馆舍，并让人传话：“要想观看西施，须先交纳金钱一文。”于是设柜收钱，顷刻之间，钱柜就满了。西施在郊外停留三天，范蠡得金钱无数，他将钱运交国库。 范蠡把西施送给夫差。夫差见到西施，喜其美貌，非常宠幸她。为她修建了馆娃宫，馆娃宫内造了响廊，屐是木板拖鞋，廊下的土地被挖成瓮形大坑，上面用厚木板覆盖铺平，西施和宫女们穿着木鞋在上面行走，铮铮有声，悦耳动听。现部分古迹亦存。夫差还为她修建了姑苏台，夫差与西施经常在姑苏台上饮酒作乐，逐渐不理朝政，朝纲日坏。 吴亡后，西施因与范蠡早已心心相印，就随范蠡一同出走，留下了千古传颂的英雄与美人的传奇佳话，又有一说勾践得到西施后，勾践妻嫉恨杀了西施。 劝文种 公元前476年，在范蠡和文种的帮助下，勾践卧薪尝胆，经过了十年生聚，十年教训，深谋20余年，终于灭掉了吴国。灭掉吴国后，勾践挥师北上，与众诸侯会盟于徐州，勾践当了霸主。自徐州返回后，勾践摆宴祝贺，群臣欢歌笑语，十分高兴。此时，只有勾践一人面无喜色，范蠡看到后叹道：“越王不想将功劳落到大臣名下，只能同患难，不能共享乐，猜忌之心已露，我若不走，必有不测。”第二天，范蠡就向越王道别，勾践说：“灭掉吴国，全凭你的帮助，现吴国已灭，天下太平，我正要和你分享这个国家，共享富贵，为什么要走？如果走，我将杀掉你的全家。”范蠡说：“臣的生死全系大王，但我辞官决心已下，你若要杀我，我亦无法。”于是范蠡在夜间悄悄出走。 范蠡出走之后，给文种去了一封信，信上写道： 你难道没有听说过吗？狡兔死，走狗烹。飞鸟尽，良弓藏。敌国破，谋臣亡。勾践长着长长的脖子，嘴尖像鸟嘴一样，这样的人只能共患难，不能同享乐。我已经走了，你若不走，定有杀身之祸，望你接到信后，尽快行动。 文种接到信后，就称病不朝。越王的左右有嫉恨文种的人向勾践进谗言道：“文种自认为功高盖世，现在大王不封赏他，他心中不满，所以不上朝。”勾践了解文种的才干，觉得吴国已灭，他对自己已经无用，更害怕文种有朝一日作乱，无人能制，现听群臣这么说，就有了杀文种之心。 有一天，越王突然到文种家中探病，随手解下宝剑，放在文种床边，对他说：“你教我七条计谋，我用了三条就已灭吴，剩下的四条你帮我到地下去见先王如何。”说完就走了，文种把宝剑取出一看，正是当年吴王赐令伍子胥自杀的宝剑，立即就明白了越王的意思，于是仰天长叹道：“我不听范蠡的话，今日终被越王所杀，我真后悔呀！”说完举剑自刎而死。 经商致富 范蠡到了齐国，隐姓埋名，自称“鸱夷子皮”即生牛皮，意为“有罪被流放的盛酒皮囊”。这是为了纪念被吴王逼杀、并装入叫“鸱夷”牛皮革囊中抛入大海的伍子胥。范蠡认为自己的遭遇同伍子胥一样。在齐国，范蠡充分利用青年时期向计然学到的经商知识。范蠡想：对付吴国定了七条计策，我只用了三条就灭了吴，我要把治国与治家结合起来，来置家产。所以他们一家在海边开荒种地，引海水煮盐，没多久财产已达数十万钱。齐国人听说他贤能，便想让他做齐国的丞相。范蠡感叹地说：“居家则致千金，居官则至相，这都是普通人最得意的事了，长久地享受这种荣誉不好呀！”于是范蠡归还相印，悄悄地把财产分给亲戚乡邻，只带少量财物又一次不辞而别。 这次，他到了“陶”（今山东定陶）这个地方，陶当时人口稠密，经济发达，商业往来频繁。他认为陶是天下的中心，是交易买卖、互通有无的商业要道。在此谋生置产，可以致富，于是自称陶朱公。陶朱公做生意讲究薄利多销，赚钱只赚十分之一的利润，看准行情买卖货物，货物的买入和出售都很谨慎，不多久家产已达上亿计，富比王侯。天下都知道陶朱公了，诸侯争相与他交往。 救子 范蠡住在陶地时，生了个小儿子。小儿子长大后，不知钱来之不易，花钱如流水。这时范蠡二儿子在楚国因杀了人而被逮了起来。范蠡认为，杀人偿命，理所应当。但是，家里有千金财产的孩子，是不应该在大庭广众面前被处死的。于是就要求他的小儿子，叫他去探视一下。长子听说了，要求让他去办。范蠡不答应，长子觉得很委屈，感到范蠡不相信他的办事能力，闹着自杀。范蠡夫人知道后，对范蠡说：“你派小儿子去，未必能救老二的命，现在老二没救回来，却让长子先死，你咋能这样？”范蠡没办法，只好让长子带了两万四千两黄金去了楚国，并写了一封信给他从前在楚国的好朋友庄先生。 范长子在出发前，又私自带几百镒的黄金。见到庄先生，范长子把信及两万四千两黄金给了他。庄先生收下钱后对他说：“赶快离开楚国，即使你弟弟被放出来也不要问为什么。”庄先生是个很耿直讲信誉的人，虽穷困潦倒，但上至楚王下至百姓都很尊重他。这次他收下范蠡的钱，并不是有意接受，而是表明一种信誉，想等他办成事后，再送还陶朱公。所以庄先生对其夫人说：“这是陶朱公的钱，如果我有什么不测，这钱一定要送还给他。”范蠡的长子却担心把钱送给他，不会起什么作用。为了保险起见，继续在楚国逗留，并用私带的钱去贿赂楚王身边的人。 庄先生找到一个适当的机会对楚王说：某星出现在某个位置，对楚不利，要他施恩德，去避害。楚王答应了，准备大赦天下。楚王身边的人听到这个消息，赶紧告诉范长子。范长子认为只要大赦，他弟弟肯定要放，白白给庄先生那么多钱实在太可惜了，于是他又见了庄先生。庄先生很吃惊，问他为什么不走。范长子说：“楚王准备大赦，我弟弟没事了，特来向你辞别。”庄先生一听就明白啥意思，就把财物给了他。长子很庆幸这次的钱能失而复得。 庄先生对范蠡长子的所作所为，觉得很羞愤，于是又见楚王，对他说：“我听别人议论，这次你大赦天下，完全是因为陶朱公儿子的缘故。”楚王很生气，我大赦天下，完全是为了施恩德，怎么会因为他的儿子呢？于是就把范蠡的二儿子杀了，杀了之后才宣布大赦天下。范蠡的长子把弟弟的尸体运回家的时候，全家除陶朱公外，都很悲伤。陶朱公说：“我老早就知道会有这个结果的。他不是不爱他的弟弟，而是他太爱金钱了，这是因为他年轻的时候和我一起置家产，深知钱财来之不易，看得重。而小儿子生而富有，不知钱财来之不易，所以他会轻易舍弃财物，这一点长子做不到。”这就是著名的成语“千金之子，不死于市”故事的来源。 范蠡年老的时候，由子孙持家，最后的家产越做越大。当时有一个猗顿的人听说陶朱公经商有法，就拜他为师，后来经商致富，家产也达亿计。后人说起富豪就把他俩并称为“陶朱猗顿之富”。范蠡被认为是做生意人的老祖宗。 范蠡搬迁三次，每次搬迁都有自己的目的，每次都能成名。治国则国盛，治家则家富。他淡泊名利、急流勇退的行为给后人很大的启示，后代有贤德的人都把范蠡的这种行为作为处世的楷模。他一人集政治、财富、美人于一身，试想，古今中外，有几人能够达到这一层次？宋王十朋曾写诗“只与君王共辛苦，功成身退步逡出。五湖渺渺烟波阔，谁是扁舟第一人”来赞扬他。 范蠡曾著有《范蠡篇》（已轶）、《范子计然》15卷、《养鱼经》1卷。其中《养鱼经》是世界上最早一本关于养鱼知识的书籍。 范蠡生意经 根据陶朱公的经商思想加工整理而成的《陶朱公生意经》，又称《陶朱公商经》、《陶朱公商训》或《陶朱公经商十八则》，至今仍在定陶一带流传。《陶朱公生意经》内容如下： 生意要勤快，懒惰百事废。 用度要节俭，奢华钱财竭。 价格要证明，含糊争执多。 赊欠要证人，滥欠血本亏。 货物要面验，滥入质价减。 出入要谦慎，潦草错误多。 用人要方正，歪斜托付难。 优劣要细分，混淆耗用大。 货物要修正，散漫查点难。 期限要约定，马虎失信用。 买卖要随时，拖延失良机。 钱财要明慎，糊涂弊端生。 临事要尽责，委托受害大。 账目要稽查，懈怠资本滞。 接纳要谦和，暴躁交易少。 主心要宁静，妄动误事多。 说话要规矩，浮躁失事多。 工作要精细，粗糙出劣品。 文言原文 范蠡事越王勾践，既苦身戮力，与勾践深谋二十馀年，竟灭吴，报会稽之耻，北渡兵於淮以临齐、晋，号令中国，以尊周室，勾践以霸，而范蠡称上将军。还反国，范蠡以为大名之下，难以久居，且勾践为人可与同患，难与处安，为书辞勾践曰：“臣闻主忧臣劳，主辱臣死。昔者君王辱於会稽，所以不死，为此事也。今既以雪耻，臣请从会稽之诛。”勾践曰：“孤将与子分国而有之。不然，将加诛于子。”范蠡曰：“君行令，臣行意。”乃装其轻宝珠玉，自与其私徒属乘舟浮海以行，终不反。於是勾践表会稽山以为范蠡奉邑。 范蠡浮海出齐，变姓名，自谓鸱夷子皮，耕于海畔，苦身戮力，父子治产。居无几何，致产数十万。齐人闻其贤，以为相。范蠡喟然叹曰：“居家则致千金，居官则至卿相，此布衣之极也。久受尊名，不祥。”乃归相印，尽散其财，以分与知友乡党，而怀其重宝，间行以去，止于陶，以为此天下之中，交易有无之路通，为生可以致富矣。於是自谓陶朱公。复约要父子耕畜，废居，候时转物，逐什一之利。居无何，则致赀累巨万。天下称陶朱公。 朱公居陶，生少子。少子及壮，而朱公中男杀人，囚於楚。朱公曰：“杀人而死，职也。然吾闻千金之子不死於市。”告其少子往视之。乃装黄金千溢，置褐器中，载以一牛车。且遣其少子，朱公长男固请欲行，朱公不听。长男曰：“家有长子曰家督，今弟有罪，大人不遣，乃遗少弟，是吾不肖。”欲自杀。其母为言曰：“今遣少子，未必能生中子也，而先空亡长男，柰何？”朱公不得已而遣长子，为一封书遗故所善庄生。曰：“至则进千金于庄生所，听其所为，慎无与争事。”长男既行，亦自私赍数百金。 至楚，庄生家负郭，披藜藋到门，居甚贫。然长男发书进千金，如其父言。庄生曰：“可疾去矣，慎毋留！即弟出，勿问所以然。”长男既去，不过庄生而私留，以其私赍献遗楚国贵人用事者。 庄生虽居穷阎，然以廉直闻於国，自楚王以下皆师尊之。及朱公进金，非有意受也，欲以成事后复归之以为信耳。故金至，谓其妇曰：“此朱公之金。有如病不宿诫，后复归，勿动。”而朱公长男不知其意，以为殊无短长也。 庄生间时入见楚王，言“某星宿某，此则害於楚”。楚王素信庄生，曰：“今为柰何？”庄生曰：“独以德为可以除之。”楚王曰：“生休矣，寡人将行之。”王乃使使者封三钱之府。楚贵人惊告朱公长男曰：“王且赦。”曰：“何以也？”曰：“每王且赦，常封三钱之府。昨暮王使使封之。”朱公长男以为赦，弟固当出也，重千金虚弃庄生，无所为也，乃复见庄生。庄生惊曰：“若不去邪？”长男曰：“固未也。初为事弟，弟今议自赦，故辞生去。”庄生知其意欲复得其金，曰：“若自入室取金。”长男即自入室取金持去，独自欢幸。 庄生羞为儿子所卖，乃入见楚王曰：“臣前言某星事，王言欲以修德报之。今臣出，道路皆言陶之富人朱公之子杀人囚楚，其家多持金钱赂王左右，故王非能恤楚国而赦，乃以朱公子故也。”楚王大怒曰：“寡人虽不德耳，柰何以朱公之子故而施惠乎！”令论杀朱公子，明日遂下赦令。朱公长男竟持其弟丧归。 至，其母及邑人尽哀之，唯朱公独笑，曰：“吾固知必杀其弟也！彼非不爱其弟，顾有所不能忍者也。是少与我俱，见苦，为生难，故重弃财。至如少弟者，生而见我富，乘坚驱良逐狡兔，岂知财所从来，故轻弃之，非所惜吝。前日吾所为欲遣少子，固为其能弃财故也。而长者不能，故卒以杀其弟，事之理也，无足悲者。吾日夜固以望其丧之来也。”故范蠡三徙，成名於天下，非苟去而已，所止必成名。卒老死于陶，故世传曰陶朱公。 太史公曰：禹之功大矣，渐九川，定九州，至于今诸夏艾安。及苗裔句践，苦身焦思，终灭强吴，北观兵中国，以尊周室，号称霸王。句践可不谓贤哉！盖有禹之遗烈焉。范蠡三迁皆有荣名，名垂后世。臣主若此，欲毋显得乎！ 译文（没有逐句翻译）：范蠡，字少伯，楚国宛三户人，据说是宛城区黄台岗三十里屯人（另有淅川、内乡说），春秋时期著名的政治家、军事家、大商人。他被当时楚宛令文种所赏识，相交甚深。后两人一起投奔越国，辅佐越王勾践。他存越灭吴，雪会稽之耻，成为春秋时期叱咤风云的人物。功成名就后，他淡泊名利，毅然弃官经商，累治家产数以亿计，富比王侯。他的经商思想和经商理论一直到现在还被人们流传、使用，成为我国古代的商界先圣，被后人尊称“陶朱公”、“商圣”。</description>
    </item>
    
    <item>
      <title>关键字探索 define const</title>
      <link>https://blog.v5u.win/post/itblack-defineconst/</link>
      <pubDate>Fri, 19 Jan 2018 09:37:16 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/itblack-defineconst/</guid>
      <description> define 单纯的代码替换，预编译时进行 const 常数，不变的。 ​ const是一个关键字。它限定一个变量不允许被改变，产生静态作用。
 编译时进行处理
 只分配一次内存
 修饰关键字右边部分表示的内容不可变
// stringConst 地址能修改，stringConst值不能修改 NSString * const stringConst = @&amp;ldquo;I am a NSString * const string&amp;rdquo;;
  static 局部变量（只在文件内使用）  延长被修饰变量的生命周期，程序结束才被销毁 只生成一份内存，只做一次初始化 修改变量作用域，限制在本文件内  </description>
    </item>
    
    <item>
      <title>各大pages提供商对比</title>
      <link>https://blog.v5u.win/post/business-pages%E6%8F%90%E4%BE%9B%E5%95%86/</link>
      <pubDate>Fri, 08 Dec 2017 16:17:33 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/business-pages%E6%8F%90%E4%BE%9B%E5%95%86/</guid>
      <description>各大pages提供商对比 ### github 稳定，全球高效，使用者众 ### coding 国内速度飞快，使用复杂，坑多，使用者正在增加 ### oschina 国内提供商，速度一般，使用者寡，和github相似度极高  </description>
    </item>
    
    <item>
      <title>python-sublime</title>
      <link>https://blog.v5u.win/post/python-sublime/</link>
      <pubDate>Wed, 29 Nov 2017 17:29:24 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/python-sublime/</guid>
      <description>sublime text 下的Python编译环境设置
file name : python3.sublime-build
{ &amp;quot;shell_cmd&amp;quot;: &amp;quot;Python编译器的路径 ${file}&amp;quot;, &amp;quot;selector&amp;quot; :&amp;quot;source.python&amp;quot;, &amp;quot;file_regex&amp;quot;:&amp;quot;^(...*?):[0-9]:?([0-9]*)&amp;quot;, &amp;quot;working_dir&amp;quot;:&amp;quot;${file_path}&amp;quot;, &amp;quot;env&amp;quot;: {&amp;quot;PYTHONIOENCODING&amp;quot;: &amp;quot;utf8&amp;quot;}, }  </description>
    </item>
    
    <item>
      <title>三省吾身，日醒三身</title>
      <link>https://blog.v5u.win/post/read-introspection/</link>
      <pubDate>Thu, 09 Nov 2017 16:06:38 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/read-introspection/</guid>
      <description>孩子，中国人常说三省吾身，指的是每天自我审视三次，也就是我跟你提到的复盘，可如果方向错了，审视的思路不对，再多的次数那也是无用，所以我们佛家讲究日省三身，法身、报身、化身，法身就是佛法，一切的根源，报身是自己内心的思想，化身是对外所做的事情，法身在上，报身在心，化身在外，若坚信自信报身胜于一切化身，就是自我想法压过了现实，则飘飘然心向恶，背离法身入地狱了，切记！状态决定你的成就</description>
    </item>
    
    <item>
      <title>mac下 pip 设置豆瓣源</title>
      <link>https://blog.v5u.win/post/mac-pip/</link>
      <pubDate>Thu, 19 Oct 2017 07:18:14 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/mac-pip/</guid>
      <description>在用户目录下创建文件夹.pip，在.pip下创建pip.conf pip.conf填入内容 [global] index-url = https://pypi.douban.com/simple [list] format=columns</description>
    </item>
    
    <item>
      <title>中国人的“故土难离”其实缘于中国式求人,缘于故土有其多年织下的关系网</title>
      <link>https://blog.v5u.win/post/life-cont-leave-hometown/</link>
      <pubDate>Wed, 20 Sep 2017 02:12:10 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/life-cont-leave-hometown/</guid>
      <description>这些年,中国人似乎往远走的多些了。但往远走的中国人大多年轻,上了一点儿年龄的,还是大都不喜远走,哪怕这旮旯兔子都不拉屎,他也愿窝在这儿。 什么原因呢?仅是中国人恋乡土吗?是“谁不说俺家乡好”吗?不是。他在这苦巴苦业的窝了一辈子,也没窝出几顿饱饭来,家乡好吗? 但究竟是什么东西扯着中国人不喜远走呢?人际关系。亲人圈、朋友圈、同事圈、同学圈、战友圈,这几年又添上网友圈。
中国人不喜远走的真正原因,是离不了这些东西。“哪也不去了,在这儿这么多年了。”在这儿这么多年了。是舍不得这地方吗?不是,是舍不得这么多年,好不容易建立的一圈套一圈的人际关系网。
那么到一个新地方不可以再建人际关系吗?可以,但需要时间。一个人活不满百,大都只扑腾几十年。没走上社会之前的十几年刨去后,进新单位,熟悉同事、熟悉领导、交朋友、扩大交往、没个十年八年的,这人际关系网你织不好。你不离开家,偎在父母身边,织网的速度能快点儿。你独闯世界去,就会慢点儿。
偎在父母身边为何织网快?先有了七大姑八大姨的亲人圈,由亲人圈向四周扩展了朋友圈,进了单位建了同事圈;人到中年,人际关系还不够用,再将从前的小学、中学、大学,以及在部队时的时间捡回来,修补成同学圈、战友圈,这几年又添上网友圈。网上热恋网下见面。往哪去,有人。没有同学找战友,没有战友找网友。那么新到一个地方,没这些圈子,没熟人行不?也行,跟上旅行社转山转水玩几天行。真在这儿住上,你试试?不是说祖国处处有亲人吗?是有人说,但你信吗?
中国人为什么要穷尽一生的大多数时光搭建这些圈子,编织人际关系网?如果祖国处处有亲人,他还费这个劲儿?这些年,大量民工进城,有没有老乡圈子?不多说了吧。有人际关系,人好见、事好办;无人际关系,人难见、事难办,说明了什么?人与人之间近乎残酷的冷漠。那种看似火炭似的沸腾的生活状态,实际上是一个又一个大大小小、形态各异的圈子在转动,置身圈子之外的人,会实实在在感到孤独和寂寞。这就是为什么好多置身大都市的人大喊太冷了。因为他没进到那些小圈子里。
中国人喜欢圈子，反映了中国目前仍缺少一个公共道德体系,缺少一种制度化的人文关怀。当一个陌生个体遭遇困难,我们常常看到的是:麻木不仁、漠不关心。为什么?他不认识你。这就是为什么车祸后,面对跪地求救者,一辆又一辆大小车辆扬长而去;为什么,一个倒地少年,围观者众多,但无一人上前施求。他要认识你,起码打个电话。
在家靠父母,出门靠朋友;打虎亲兄弟,上阵父子兵。这些我们并不陌生的人生经验总结,过时了吗?没有。而且,有些东西愈演愈烈。你干点啥儿,不得进行“中国式求人”?
那么不喜欢远走的中国人,为什么这些年远走国外的越来越多?人家那里同咱这儿不一样。笔者的弟弟某年去德国,人生地不熟,车站外正徘徊,一老者上前问需要帮助吗?然后,将弟弟送到要去的地方后,开车而去。极自然、极正常,该做的,不须感谢。
另有文章介绍:中国人的车出故障后,几个外国人帮忙几个小时，完事后当中国人致谢时，老外说：不需要感谢,你遇到这种情况会不管吗?找政府办事,该办的会尽力给你办,不必送礼吃饭。这种社会道德环境,需要建圈子织网吗？
呜呼！一圈一圈又一圈,大圈套小圈,小圈连大圈,中国人已经被这一个又一个的圈子勒得呼吸愈发困难。
文章转自华声论坛</description>
    </item>
    
    <item>
      <title>python venv 虚拟环境使用</title>
      <link>https://blog.v5u.win/post/python-venv/</link>
      <pubDate>Tue, 04 Jul 2017 09:53:23 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/python-venv/</guid>
      <description>virtualenv就是用来为一个应用创建一套“隔离”的Python运行环境。
Python3.3以上的版本通过venv模块原生支持虚拟环境，可以代替Python之前的virtualenv。
该venv模块提供了创建轻量级“虚拟环境”，提供与系统python的隔离支持。每一个虚拟环境都有其自己的Python二进制（允许有不同的Python版本创作环境），并且可以拥有自己独立的一套Python包。
需要注意的是，在Python3.3中使用”venv”命令创建的环境不包含”pip”，你需要进行手动安装。在Python3.4中改进了这一个缺陷。
安装 python -m venv .
启动 source venv/bin/activate
退出 deactivate
&amp;nbsp;
&amp;nbsp;
virtualenv是如何创建“独立”的Python运行环境的呢？原理很简单，就是把系统Python复制一份到virtualenv的环境，用命令source venv/bin/activate进入一个virtualenv环境时，virtualenv会修改相关环境变量，让命令python和pip均指向当前的virtualenv环境。</description>
    </item>
    
    <item>
      <title>mac下安装composer</title>
      <link>https://blog.v5u.win/post/mac-composer/</link>
      <pubDate>Fri, 09 Jun 2017 03:35:06 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/mac-composer/</guid>
      <description>composer是PHP的包管理器
mac下如何安装呢？
最简单的方法是通过brew工具
brew install composer
这时候可能会遇到这个问题：
Searching for a previously deleted formula&amp;hellip;
所以我们检查一下brew/core 中是否有composer可供安装
brew search composer
得到这个结果：
homebrew/php/composer
homebrew/php/composer@1.2
caskroom/versions/multimarkdown-composer-beta
caskroom/cask/multimarkdown-composer-pro
caskroom/cask/multimarkdown-composer
所以其实是有的，只是没找到
这时候我们通过brew 的 tap方法来设置一下
brew tap homebrew/php
完事之后，再运行brew install composer就可以了。
当然，还有其他的方法安装，但是我都不推荐，因为太麻烦！</description>
    </item>
    
    <item>
      <title>mac下nvm 使用记录</title>
      <link>https://blog.v5u.win/post/mac-nvm/</link>
      <pubDate>Tue, 02 May 2017 10:29:55 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/mac-nvm/</guid>
      <description>mac下nvm 使用记录 断开连接 brew unlink nvm 安装 brew install nvm 环境变量 add to ~/.bash_profile export NVM_DIR=&amp;ldquo;$HOME/.nvm&amp;rdquo; . &amp;ldquo;$(brew &amp;ndash;prefix nvm)/nvm.sh&amp;rdquo; 配置国内镜像源 export NVM_NODEJS_ORG_MIRROR=https://npm.taobao.org/dist 配置npm镜像源 创建 ~/.npmrc 写入registry=https://registry.npm.taobao.org 更新环境变量 . ~/.bash_profile
查看可安装的nodejs版本 nvm ls-remote 安装node nvm install
删除版本 nvm uninstall v6 查看 nvm ls 切换nvm use //只针对当前shall 设置默认 nvm alias default v7
&amp;nbsp;</description>
    </item>
    
    <item>
      <title>mac文件权限修改</title>
      <link>https://blog.v5u.win/post/mac-file-right-change/</link>
      <pubDate>Mon, 13 Mar 2017 17:20:42 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/mac-file-right-change/</guid>
      <description>文件或目录的访问权限分为只读，只写和可执行三种。 文件被创建时，文件所有者自动拥有对该文件的读、写和可执行权限，以便于对文件的阅读和修改。 有三种不同类型的用户可对文件或目录进行访问：文件所有者，同组用户、其他用户。
用ls -l命令显示文件或目录的详细信息，最左边的一列为文件的访问权限
例:
$ ls -l script.swift
-rw-r--r-- 1 fans staff 39 3 13 16:16 script.swift
横线代表空许可。r代表只读，w代表写，x代表可执行
这里共有10个位置。第一个字符指定了文件类型。 在通常意义上，一个目录也是一个文件。如果第一个字符是横线，表示是一个非目录的文件。如果是d，表示是一个目录。
   - rw- r-- r--     普通文件 文件主 组用户 其他用户    是文件script.swift 的访问权限，表示script.swift是一个普通文件； script.swift的属主有读写权限；与script.swift属主同组的用户只有读权限；其他用户也只有读权限。
chmod 命令 功能：用于改变文件或目录的访问权限.用户用它控制文件或目录的访问权限. 语法：该命令有两种用法。一种是包含字母和操作符表达式的文字设定法；另一种是包含数字的数字设定法。
 文字设定法
chmod u+x script.swift
[详情点一下][http://blog.csdn.net/nitghost/article/details/4224034]
 数字设定法
略。。。知道那么多干嘛，一种还不够你用的！^_^
  swift研究学习</description>
    </item>
    
    <item>
      <title>mac 安装nginx</title>
      <link>https://blog.v5u.win/post/mac-nginx/</link>
      <pubDate>Sun, 26 Feb 2017 00:12:18 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/mac-nginx/</guid>
      <description>安装 brew install nginx
启动 sudo nginx
重新启动 sudo nginx -s reload
停止 sudo nginx -s stop</description>
    </item>
    
    <item>
      <title>brew 安装</title>
      <link>https://blog.v5u.win/post/mac-brew-install/</link>
      <pubDate>Sat, 25 Feb 2017 22:54:49 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/mac-brew-install/</guid>
      <description>Mac自带ruby 安装brew ruby -e &amp;quot;$(curl -fsSL https://raw.github.com/Homebrew/homebrew/go/install)&amp;quot; 已经安装了可以输入这个命令 ruby -e &amp;quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&amp;quot; 如何使用brew 举个栗子: wget 这个工具 输入命令: brew install wget 输入命令 brew uninstall wget</description>
    </item>
    
    <item>
      <title>nvm管理不同的node版本</title>
      <link>https://blog.v5u.win/post/nodejs-nvm/</link>
      <pubDate>Fri, 24 Feb 2017 09:59:52 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/nodejs-nvm/</guid>
      <description>前任栽树后人乘凉 ：http://www.cnblogs.com/kongxianghai/p/5660101.html
安装多版本node  安装nvm 通过下面的命令可进行一步到位的安装，下面两种方式可二选一。 curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.31.2/install.sh | bash 或者: wget -qO- https://raw.githubusercontent.com/creationix/nvm/v0.31.2/install.sh | bash  安装  在命令行中运行命令，安装当前最新的稳定版。 nvm install stable 运行命令，指明版本，安装早期的版本0.12.4。 nvm install 0.12.4 安装后，当前使用的node版本默认为最后一次安装的版本，在命令行中运行命令可查看当前版本。 nvm current 切换node版本 nvm use 6 显示所有安装的版本 nvm ls 设置默认使用的版本 nvm alias default &amp;amp;lt;version&amp;amp;gt;  卸载  删除引用 nvm deactivate 卸载 nvm uninstall 7  安装全局组件
非nvm管理的情况下，全局组件是安装到/usr/local/lib/node_modules下，然后通过软连接的方式把包中bin目录下的可执行文件链接到/usr/local/bin。不管用什么版本都装到这些目录下，多版本就没法玩了。
在nvm管理下，以沙箱的方式，全局组件会装到.nvm目录的当前版本node下，也就是装在nvm这个沙箱里，跟在指定版本的node下，当前有什么版本的node，就有对应的全局组件。这是nvm强大的地方，在多运行环境的管理和切换极为好用。
使用.nvmrc文件运行
在服务器上很多时候会运行多个应用系统，每个应用系统使用的node版本是不一样的，老系统用0.12.x甚至0.10.x，新系统用了新特新所以用最新的node版本，都很实际很正常。
为了让不同的应用系统使用各自所需的node版本运行，我们只需在各应用系统内的根目录里生成一个.nvmrc文件，在其内写一个版本号，利用nvm run &amp;lt;系统启动文件&amp;gt;的方式运行系统，即可完成要求。详情请看文章开头链接。</description>
    </item>
    
    <item>
      <title>二十四种常见的逻辑谬误</title>
      <link>https://blog.v5u.win/post/life-24-logic-error/</link>
      <pubDate>Tue, 07 Feb 2017 13:52:49 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/life-24-logic-error/</guid>
      <description>二十四种常见的逻辑谬误
 第一条：稻草人 第二条：错误归因 第三条：诉诸感情 第四条：谬误谬误 第五条：滑坡谬误 第六条：人身攻击 第七条：诉诸虚伪 第八条：个人怀疑 第九条：片面谬误 第十条：诱导性问题 第十一条：举证责任 第十二条：语义模糊 第十三条：赌徒谬误 第十四条：乐队花车 第十五条：诉诸权威 第十六条：合成谬误 第十七条：没有真正的苏格兰人 第十八条：基因谬误 第十九条：非黑即白 第二十条：窃取论点 第二十一条：诉诸自然 第二十二条：轶事证据 第二十三条：德克萨斯神枪手 第二十四条：中间立场
 第一条：稻草人 你歪曲了别人的观点，使你自己能够更加轻松的攻击别人。 你夸张、歪曲，甚至凭空创造了别人的观点，来让你本身的观点显得更加合理。这是一种极端不诚实的行为，这不但影响了理性的讨论，也影响了你自己观点的可信度。因为如果你可以负面的歪曲别人的观点，你就有可能从正面歪曲自己的观点。 例子：小明说国家应该投入更多的预算来发展教育行业，小红回复到：“想不到你这么不爱国，居然想减少国防开支，让外国列强有机可乘。” 小红就犯了稻草人谬误。
第二条：错误归因 你从两个事物可能存在相关性，就得出一个事物是造成另一个事物的原因。 你看到了两个事物同时存在，就觉得其中一个事物是另一个的起因。你的错误在于，同时存在的两个事物未必有因果关系，可能这两个事物有共同的起因，或者两个事物根本没有因果关系，它们直接的共存只是 2 巧合。一个事情比另一个事情先发生同样不能说明两个事物肯定存在因果性。 例子：小红指出，过去几个世纪全球海盗数量减少，全球温度在升高，从而得出是海盗的数量的减少造成了气候变化，海盗能够降低全球温度。小红犯了错误归因的谬误.
第三条：诉诸感情 你试图通过操作别人的感情来取代一个有力的论述。 你操作的感情可能包括恐惧、嫉妒、怜悯、骄傲等等。一个逻辑严谨的论述可能激起别人的情感波动，但是如果只用感情操作而不用逻辑论述，那你就犯了诉诸感情的错误。每个心智健康的人都会受感情影响，所以这种谬误很有效，但这也是为什么这种谬误是低级和不诚实的手段。 例子：小红在饭店看到小明吃狗肉，于是上前训斥：“你怎么可以吃狗肉，小狗多么可爱，就像小朋友一样，你忍心伤害小朋友吗？” 小红犯了诉诸感情的谬误。
第四条：谬误谬误 你看到别人的论述水平很低，或者别人的论述里面有谬误，就认为别人的观点一定是错误的。 很多时候，辩论的赢家获胜并不是因为观点正确，而是因为辩论技巧更好。作为一个理性的人，你不能因为别人的论述中存在谬误或者错误，就认为别人的观点一定是错误的。 例子：一个提倡健康饮食的人在电视上发表了很荒唐的饮食理论来推广健康饮食理念，小红看后觉得健康饮食就是骗人的，于是开始每天暴饮暴食。小红犯了谬误谬误
第五条：滑坡谬误 你搞得好像如果A发生了，那么Z也一定会发生会，以此来表示A不应该发生。 你不讨论现下的事物(A)，而是把讨论重心转移到了意淫出来的极端事物(Z)。因为你没能给出任何证据来证明A的发生一定会造成极端事物Z的发生，所以这是一种诉诸恐惧的谬误，也影响了人们讨论A时候的客观性。 例子：小红反对同性恋婚姻，因为她认为如果我们允许同性恋结婚，那么就会有人想要和桌子、椅子结婚。小红犯了滑坡谬论。
第六条：人身攻击 你讨论时针对对方的人格、动机、态度、地位、阶级或处境等，而进行攻击或评论，并以此当作提出了理据去驳斥对方的论证或去支持自己的论点 人身攻击时不一定是直接进行攻击，也可能是通过背后捅刀子、暗示听众等等方式来造成对对方人格的质疑。你试图用你对别人人格的攻击来取代一个有力的论述。更多关于人身攻击。 例子：当小明提出了一个很合理的关于基础设施建设的提议的时候吗，小红说她不相信任何小明说的话，因为小明不爱国，经常批评政府，不懂得感恩。小红犯了人身攻击的谬误。
第七条：诉诸虚伪 你不正面回应别人对你的批评，而是用批评别人作为你的回复——“你不也曾经&amp;hellip;..” 你想要把通过用批评回应批评的方式，免去你为自己辩护的责任。你通过这种方法来暗示对方是个虚伪的人，但是不管别人虚伪与否，你都只是在回避别人对你的批评。 例子：小明在和小红争论的时候指出小红犯了一个逻辑谬误，小红不正面捍卫自己，反而回应：“你之前也犯了逻辑谬误。” 小红在这里犯了诉诸虚伪的谬误
第八条：个人怀疑 你因为自己不明白或者知识水平不够，就得出一个事物可能是假的。 一些很复杂的概念，比如生物进化等等需要一些基本的理解和知识。有些人因为不理解这些复杂的概念，而觉得这些东西是错误的。 例子：小红指着块石头说：“你说进化论是真的，那你让这块石头进化人给我看看。”小红犯了个人怀疑的谬误
第九条：片面谬误 当你的观点被证明是错误的时候，你用特例来给自己开脱。 人类都不喜欢被证明是错的，所以当他们被证明是错的时候总会想办法给自己开脱。人总是觉得自己以前觉得正确的东西必须是正确的吗，所以总能找到理由让自己阿Q一下。只有诚实和勇敢的人才能面对自己的错误，并且承认自己犯错了。 例子：小红说自己有特异功能，能用塔罗牌算出未出生小孩的性别，但是孩子生下来后发现猜错了，于是她就说是算命的人缺乏信仰。小红犯了片面谬误。
第十条：诱导性问题 你在提出问题的时候加入了诱导的成分，使得对方只能按着你的意思来回答。 你试图用诱导性的问题来逼对方回答你提出的低级问题，从而破坏理性的讨论。 例子：小红怀疑自己的丈夫孙越搞外遇，为了一探究竟，于是就问他：“陈轩的屁股上是不是有个胎记？”小红使用的就是诱导性问题。</description>
    </item>
    
    <item>
      <title>使用sublime text 3 进行Python3开发</title>
      <link>https://blog.v5u.win/post/sublime-python3/</link>
      <pubDate>Mon, 23 Jan 2017 15:22:20 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/sublime-python3/</guid>
      <description>痛点1：每次编写完Python文件后都要切到terminal下输入python fileName.py命令执行文件。 解决：mac版sublime text编辑器使用shift+command+b选择Python 直接执行文件
痛点2：sublime默认执行的Python版本是系统默认的，不能直接使用Python3来执行Python文件 解决：Tools&amp;ndash;&amp;gt;Build System&amp;ndash;&amp;gt;New Build System 写入：
{ &amp;quot;shell_cmd&amp;quot;: &amp;quot;/usr/bin/env python3 ${file}&amp;quot;, &amp;quot;selector&amp;quot;: &amp;quot;source.python&amp;quot;, &amp;quot;file_regex&amp;quot;: &amp;quot;^(...*?):([0-9]*):?([0-9]*)&amp;quot;, &amp;quot;working_dir&amp;quot;: &amp;quot;${file_path}&amp;quot;, }  ​ 保存为/Packages/User/python3.sublime-build ​ 然后选择环境为python3即可</description>
    </item>
    
    <item>
      <title>mac 如何使用wget</title>
      <link>https://blog.v5u.win/post/mac-wget/</link>
      <pubDate>Sat, 21 Jan 2017 23:38:52 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/mac-wget/</guid>
      <description>下载单个文件， 为什么不用mac原生自带的工具：curl &amp;ldquo;网址链接&amp;rdquo; -o &amp;ldquo;输出文件名&amp;rdquo; 解释一下，wget是Linux下自带的文件下载工具非常好用，mac下还是推荐使用原生。 呵呵哒，也许我是一片假的教程文章。</description>
    </item>
    
    <item>
      <title>抓包调试工具mitmproxy</title>
      <link>https://blog.v5u.win/post/system-%E6%8A%93%E5%8C%85%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7mitmproxy/</link>
      <pubDate>Tue, 27 Dec 2016 10:39:15 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/system-%E6%8A%93%E5%8C%85%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7mitmproxy/</guid>
      <description>安装：brew install mitmproxy 其他安装方式: http://docs.mitmproxy.org/en/latest/install.html
启动：mitmproxy -p 8080(监听端口号)
设置代理，具体设置方法请自行查找
抓取https：用 iPhone 打开 Safari 浏览器并输入 mitm.it，安装信任证书
使用：键盘上下移动，Enter 键进入查看详情，按 Tab 键切换顶部导航栏
拦截修改 request 和 response： 输入 i，然后输入 ~s 再按回车键，这时候就进入了 response 拦截模式。如果输入 ~q 则进入 request 的拦截模式，更多的命令可以输入 ？ 查看。 其中橘红色的表示请求正被拦截，这时 Enter 进入后 再按 e 就可以修改 request 或者 response。修改时是用 vim 进行编辑的，修改完成后按 a 将请求放行，如果要放行所有请求输入 A 即可</description>
    </item>
    
    <item>
      <title>MySQL 数据库迁移</title>
      <link>https://blog.v5u.win/post/system-mysql-change/</link>
      <pubDate>Thu, 15 Dec 2016 14:21:18 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/system-mysql-change/</guid>
      <description> mac 下迁移数据库的结构和内容 迁移准备：数据库文件（可用工具导出Mysql文件）
注意：由于文件权限的问题 可能不能进入Mysql的data文件内  进入文件 /usr/local/mysql/data 如果打不开，修改文件访问权限，（右击，显示简介，修改文件读写权限） 将相应的文件(如：MYD,MYI,frm) copy进合适的数据库内（文件夹） 打开数据库，查看迁移情况  </description>
    </item>
    
    <item>
      <title>OpenShift的使用</title>
      <link>https://blog.v5u.win/post/system-openshift/</link>
      <pubDate>Wed, 14 Dec 2016 17:56:33 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/system-openshift/</guid>
      <description> 注册完成后如何使用命令行连接服务器
登录OpenShift网站，进入app的详情页，找到隐藏的ssh连接，不是下载地址的ssh连接，拷贝后直接在终端打开就行，无需密码
  </description>
    </item>
    
    <item>
      <title>swift中weak和unowned的区别</title>
      <link>https://blog.v5u.win/post/swift-weakunowned/</link>
      <pubDate>Tue, 13 Dec 2016 16:34:00 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/swift-weakunowned/</guid>
      <description>weak和unowned都是解决循环引用的关键字 区别： 如果您是一直写 Objective-C 过来的，那么从表面的行为上来说 unowned 更像以前的 unsafe_unretained，而 weak 就是以前的 weak。 用通俗的话说，就是 unowned 设置以后即使它原来引用的内容已经被释放了，它仍然会保持对被已经释放了的对象的一个 &amp;ldquo;无效的&amp;rdquo; 引用，它不能是 Optional 值，也不会被指向 nil。如果你尝试调用这个引用的方法或者访问成员属性的话，程序就会崩溃。 而 weak 则友好一些，在引用的内容被释放后，标记为 weak 的成员将会自动地变成 nil (因此被标记为 @weak 的变量一定需要是 Optional 值)。 关于两者使用的选择，Apple 给我们的建议是如果能够确定在访问时不会已被释放的话，尽量使用 unowned，如果存在被释放的可能，那就选择用 weak。</description>
    </item>
    
    <item>
      <title>swift 关键字篇</title>
      <link>https://blog.v5u.win/post/swift-%E5%85%B3%E9%94%AE%E5%AD%97/</link>
      <pubDate>Tue, 13 Dec 2016 15:45:27 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/swift-%E5%85%B3%E9%94%AE%E5%AD%97/</guid>
      <description>@noescape：no escape(没有逃脱) 用来修饰闭包，含义为非逃逸闭包。 当闭包作为参数传递进函数时，如果这个闭包只在函数中被使用，则开发者可以将这个闭包声明成非逃逸的，即告诉系统当此函数结束后，这个闭包的生命周期也将结束，这样做的好处是可以提高代码性能，将闭包声明成非逃逸的类型使用@noescape关键字。 (1) 默认，swift 3.0 弃用，函数结束后，这个闭包的生命周期也将结束。 (2) 在其内部如果需要使用self这个关键字，self可以被省略。
@escaping 逃逸闭包 逃逸的闭包常用于异步的操作，这类函数会在异步操作开始之后立刻返回，但是闭包直到异步操作结束后才会被调用。例如这个闭包是异步处理一个网络请求，只有当请求结束后，闭包的生命周期才结束。当闭包作为函数的参数传入时，很有可能这个闭包在函数返回之后才会被执行。
@autoclosure 自动闭包 (1)默认非逃逸 (2)闭包也可以被自动的生成，这种闭包被称为自动闭包，自动闭包自动将表达式封装成闭包。 (3)自动闭包不接收任何参数，被调用时会返回被包装在其中的表达式的值。 (4)当闭包作为函数参数时，可以将参数标记 @autoclosure 来接收自动闭包。 (5)自动闭包能够延迟求值,因为代码段不会被执行直到你调用这个闭包。 (6)自动闭包默认是非逃逸的，如果要使用逃逸的闭包，需要手动声明: @autoclosure @escaping 旧版本：@autoclosure(escaping)
//(a)自动闭包演示 var students = [&amp;ldquo;A&amp;rdquo;,&amp;ldquo;B&amp;rdquo;,&amp;ldquo;C&amp;rdquo;] let studentsProvider = { students.remove(at: 0) } //自动闭包自动将表达式封装成闭包 studentsProvider()//(b)自动闭包演示 var list = [1,2,3,4,5,6]
//创建一个显式闭包 let closures = { list.append(7) }
print(list)//将打印[1,2,3,4,5,6]
closures() print(list)//引用传递，将打印[1,2,3,4,5,6,7]
func func1(closure: ()-&amp;gt;Void) -&amp;gt; Void { //执行显式的闭包 closures() }
func func2(auto: @autoclosure ()-&amp;gt;Void) -&amp;gt; Void { //执行自动闭包 auto() }</description>
    </item>
    
    <item>
      <title>如何对2型糖尿病进行中医的辨证论治呢？</title>
      <link>https://blog.v5u.win/post/life-%E5%A6%82%E4%BD%95%E5%AF%B92%E5%9E%8B%E7%B3%96%E5%B0%BF%E7%97%85%E8%BF%9B%E8%A1%8C%E4%B8%AD%E5%8C%BB%E7%9A%84%E8%BE%A8%E8%AF%81%E8%AE%BA%E6%B2%BB%E5%91%A2/</link>
      <pubDate>Mon, 12 Dec 2016 13:50:17 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/life-%E5%A6%82%E4%BD%95%E5%AF%B92%E5%9E%8B%E7%B3%96%E5%B0%BF%E7%97%85%E8%BF%9B%E8%A1%8C%E4%B8%AD%E5%8C%BB%E7%9A%84%E8%BE%A8%E8%AF%81%E8%AE%BA%E6%B2%BB%E5%91%A2/</guid>
      <description>如何对2型糖尿病进行中医的辨证论治呢？ 2型糖尿病是因为胃肠吸收来的糖不能及时送到四肢、皮肤等外周部位，这些部位的细胞不能正常消耗血糖，最后导致血糖升高。机体内的营养输送和利用由中医的脾来主管，当脾功能衰退或者脾负担过重时候，脾都不能正常地把营养运输到全身，所以，2型糖尿病人可以分为两个大类：脾功能衰退、脾负担过重。在具体用药的时候，还要根据病人体质的寒热来选择药物，寒性体质的要用温性药物，热性体质的要用寒性药物。所以，每个大类中又要分为寒热两个小类。运用中医药治疗2型糖尿病，辨证时必须分为四类。 根据自己的经验，我把2型糖尿病的辨证过程进行了简单化和条理化的整理，具体可以按照下面的方法来操作：
第一步：辨“功能衰退”还是“负担过重” 1、凡有口苦（早上起床时明显），舌苔黄腻，或黑腻等现象，就一定是脾负担过重。 2、凡有胸胁胀闷、肝区或右上腹胀闷疼等现象，属于脾负担过重。 3、只有血糖值升高，而没有任何症状的2型糖尿病人可以根据脉象加以判断： 1) 在没有服用强心药或扩血管药情况下，脉搏有力的是脾负担过重，脉搏弱，软而无力，重按脉搏力道不增加的为脾功能衰退。 2) 脉搏细而有力为脾负担过重，大而无力为脾功能衰退。 3) 左手脉强劲有力，右手脉稍弱，但重按力道增大的属于脾负担过重。 4) 左手脉软而无力，重按力道更小，右手脉即使有一定的力量，也属脾功能衰退。 5) 服用强心药或者扩血管药会改变脉象，因此，给这类2型糖尿病人诊脉，应该选在早上还没有服药的时候，这样才能掌握真实的脉象。 4、体重情况不能作为分型判断的标准，胖人不一定就是脾肺负担过重型。 5、值得注意的是，2型糖尿病人大多数是中老年人，经常既有脾功能衰退的情况，又有脾功能负担过重的情况，就如同汽车既有发动机老化问题，又存在着负担过重的问题一样。
第二步：辨“寒”和“热” 1、判断寒热，首先问诊。“平时怕冷还是怕热？” 2、第二步看舌。 1）如果病人舌质红，舌苔黄或无苔，回答怕热，肯定属热性体质； 2）如果病人舌质红，舌苔白或者黄或者无苔，回答怕冷，平时手足发凉，属内热体质。 （注意黯红和紫红的区别。黯红如放久了的猪肝的颜色，甚至有的微微带龙胆紫的颜色，舌上面必然有水滑，这种情况属于寒性体质；紫红色比暗红色鲜艳，属于热性体质。） 3）如果病人舌质淡，回答“怕冷”，肯定属于寒性体质。 4）如果病人舌质淡，但回答“怕热”，或者“没有注意，无感觉”，这时候就要参考脉象，如果脉沉，重按才能摸到，属于寒性体质；如果脉轻按重按都很有力，属于热性体质，是因为过多使用苦瓜、石膏、知母等寒性药伤了胃阳，全身还是属于热性体质。
正确分清2型糖尿病病人的功能衰退、负担过重，寒热之后，无论是用中药治疗还是平时的饮食、运动都应该有针对性地进行。 功能衰退和负担过重的病人，运动方案不能一样。有的2型糖尿病人运动以后，疲劳乏力、心脏早搏等症状减轻，有的运动后觉得更累，好几天恢复不过来。所以，运动方案不能千篇一律。 现在西医提出了许多糖尿病人食品，比如苦瓜、荞麦、南瓜、薏苡仁等等。有的病人吃了感觉状态转好，但是很多病人吃后不但没有感觉到好，而且，吃出新的疾病。我经常看到吃南瓜吃成了黄疸，吃苦瓜、荞麦吃出胃病的。这些所谓的糖尿病人食品并不是适合所有糖尿病人的，应该“辨证择食”。
本文来源中医纪元的博客 http://blog.sina.com.cn/s/blog_45f8d4f80100hit9.html</description>
    </item>
    
    <item>
      <title>使用Xcode8创建Python项目</title>
      <link>https://blog.v5u.win/post/xcode-xcode8python/</link>
      <pubDate>Tue, 06 Dec 2016 10:44:31 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/xcode-xcode8python/</guid>
      <description> 今天想使用一个IDE来开发Python，省的每次写完后都要在terminal上敲命令。选来选去，既然已经安装了Xcode就先用他吧。
那么怎么才能使用Xcode创建并运行Python文件呢？ 必要准备：mac &amp;amp; Xcode 开发环境整理： 1.1 创建 1.2 选择mac跨平台应用 1.3 添加项目名称 2.1 添加文件 2.2 Other &amp;gt; Empty Empty&amp;rdquo; /&amp;gt;
2.3 给文件命名 3.1 Product &amp;gt; Scheme &amp;gt; Edit Scheme 3.2 Run &amp;gt; info &amp;gt; Executable &amp;gt; Other 3.3 Command+Shift+G 定位文件路径Go to the folder:填写/usr/bin/python 3.4 确认选中的可执行文件 3.5 确认Executable 选中python Debug executable 不用选中 3.6 Arguments &amp;gt; + &amp;gt;新建的文件名 3.7 Options &amp;gt; Working Directory &amp;gt;项目路径 选择文件 3.8 确认设置 4 运行 print &amp;quot;hello world&amp;quot; </description>
    </item>
    
    <item>
      <title>IT公司项目实现流程</title>
      <link>https://blog.v5u.win/post/business-it%E5%85%AC%E5%8F%B8%E9%A1%B9%E7%9B%AE%E5%AE%9E%E7%8E%B0%E6%B5%81%E7%A8%8B/</link>
      <pubDate>Mon, 21 Nov 2016 10:29:52 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/business-it%E5%85%AC%E5%8F%B8%E9%A1%B9%E7%9B%AE%E5%AE%9E%E7%8E%B0%E6%B5%81%E7%A8%8B/</guid>
      <description> 注册公司，注册账号和其他所需资料（apple账号，第三方平台账号，合作平台资料） 市场调查，验证idea 项目立项，搜集需求 设计UE，确定需求 需求评审，完善需求，里程碑计划。 UI设计，设计接口 后台实现，前端实现 测试调试 部署上线  </description>
    </item>
    
    <item>
      <title>pyquery 解析网页乱码</title>
      <link>https://blog.v5u.win/post/python-pyquery-code-type/</link>
      <pubDate>Fri, 18 Nov 2016 10:08:22 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/python-pyquery-code-type/</guid>
      <description> pyquery 解析网页乱码 问题：使用pyquery直接请求的网页，解析中文出现一半乱码，一般正常的情况
花了半天的时间也没找到解决办法，第二天早上无意间点开一个搜索结果链接，经验证，完美解决问题，立字为证。 1\. 确认encode设置正确 2\. 根据知乎@actberw 的解释：pyquery的源码，http 请求使用的是requests，如果没有就调用标准库urllib2 3\. requests可以很好的处理返回的html编码问题，而urllib2不能 4\. 如果安装了requests还是不行的话，requests是有一个bug（2016年3月数据），有两种解决办法： 1). 构建pq对象的时候把encoding参数传进去 d=pq(url=&#39;xxx&#39;, encoding=&amp;quot;gbk&amp;quot;) 2). 把pyquery/openers.py 的_requests 函数中的 if encoding: resp.encoding = encoding 这两行换成 resp.encoding = encoding or None, 或者把 requests中get_encoding_from_headers 函数的后两行删除掉。 3)（我的情况正好就是没有requests库，然后选择了方法一解决了问题）  </description>
    </item>
    
    <item>
      <title>命名规范</title>
      <link>https://blog.v5u.win/post/system-%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83/</link>
      <pubDate>Tue, 08 Nov 2016 14:39:03 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/system-%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83/</guid>
      <description>http://yemengying.com/2016/06/25/cleanCode4naming/</description>
    </item>
    
    <item>
      <title>数据结构</title>
      <link>https://blog.v5u.win/post/system-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</link>
      <pubDate>Mon, 07 Nov 2016 22:13:26 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/system-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</guid>
      <description> 顺序表 链表 栈和队列 散列表 树结构
适合表述层次关系
 图结构
  </description>
    </item>
    
    <item>
      <title>Python_pyspider</title>
      <link>https://blog.v5u.win/post/python-pyspider/</link>
      <pubDate>Wed, 02 Nov 2016 10:34:41 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/python-pyspider/</guid>
      <description>mac 下pyspider的安装 安装环境：OS X EI Capitan 版本 10.11.6 Python2.7
此文章书写原因：经过简单命令pip install pyspider安装失败后，各种解决问题不胜其烦，问题不断。
失败原因：EI Capitan 引入了SIP机制（System Integrity Protection）默认下系统启动SIP系统完整性保护机制，无论是对于硬盘还是运行时的进程 限制对系统目录的写操作
安装成功命令：pip install pyspider —user -U (基于用户的权限来安装模块包)
我最终还是放弃了pyspider的使用，对于一名Python小白来说，花在安装爬虫环境的时间太多了，问题也太多，时间效率很不合算。
现在转而使用了一些简单的库BeautifulSoup和PyQuery，两个都是很优秀的html解析库。
熟悉jQuery语法的人推荐使用PyQuery,PyQuery据说是严格按照jQuery语法实现的一套Python解析库。
其他人可以尝试一下BeautifulSoup，简洁而强大。</description>
    </item>
    
    <item>
      <title>AnyBidirectionalCollection</title>
      <link>https://blog.v5u.win/post/swift-anybidirectionalcollection/</link>
      <pubDate>Thu, 27 Oct 2016 20:01:25 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/swift-anybidirectionalcollection/</guid>
      <description>A type-erased wrapper over any collection with indices that support bidirectional traversal.
一种类型擦除的集合(索引支持双向遍历)</description>
    </item>
    
    <item>
      <title>as as! as?</title>
      <link>https://blog.v5u.win/post/swift-as/</link>
      <pubDate>Wed, 26 Oct 2016 13:52:46 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/swift-as/</guid>
      <description>Swift开发之 is、 as、as!、as?三种类型转换操作符
1，as使用场合
（1）从派生类转换为基类，向上转型（upcasts）
class Animal {} class Cat: Animal {} let cat = Cat() let animal = cat as Animal
（2）消除二义性，数值类型转换
let num1 = 42 as CGFloat let num2 = 42 as Int let num3 = 42.5 as Int let num4 = (42 / 2) as Double
（3）switch 语句中进行模式匹配
如果不知道一个对象是什么类型，你可以通过switch语法检测它的类型，并且尝试在不同的情况下使用对应的类型进行相应的处理。
switch animal { case let cat as Cat: print(&amp;ldquo;如果是Cat类型对象，则做相应处理&amp;rdquo;) case let dog as Dog: print(&amp;ldquo;如果是Dog类型对象，则做相应处理&amp;rdquo;) default: break }</description>
    </item>
    
    <item>
      <title>CocoaPods</title>
      <link>https://blog.v5u.win/post/mac-cocoapods/</link>
      <pubDate>Wed, 26 Oct 2016 10:37:38 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/mac-cocoapods/</guid>
      <description>.podspec文件是做什么的
.podspec文件描述了一个库将怎样被添加进工程中。.podspec文件可以标识该第三方库所需要的源码文件、依赖库、编译选项，以及其他第三方库需要的配置。  Podfile 文件的自述
Podfile是用于配置项目所需要的第三方库的地方，使用格式如下： platform :ios, &#39;7.0&#39; target &#39;xxx&#39; do pod &#39;AFNetworking&#39;, &#39;~&amp;gt; 3.1.0&#39; ## react-native (引用本地文件) pod &#39;React&#39;, :path =&amp;gt; &#39;./node_modules/react-native&#39;, :subspecs =&amp;gt; [ &#39;Core&#39;, ] end   ​</description>
    </item>
    
    <item>
      <title>swift Enum</title>
      <link>https://blog.v5u.win/post/swift-enum/</link>
      <pubDate>Tue, 25 Oct 2016 19:50:02 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/swift-enum/</guid>
      <description>普通创建
enum SomeEnum: NSInteger { case A case B case C }  可以在Objective-C中使用的（添加@objc 关键字）
@objc enum Bear: Int { case Black, Grizzly, Polar }  </description>
    </item>
    
    <item>
      <title>MySQL</title>
      <link>https://blog.v5u.win/post/system-mysql/</link>
      <pubDate>Fri, 21 Oct 2016 13:27:06 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/system-mysql/</guid>
      <description>MYSQL 经常使用tips  terminal登录：路径 -u 用户名 -p //mac下 /usr/local/mysql/bin/mysql -u root -p 更改初始密码：set password for &amp;lsquo;root&amp;rsquo;@&amp;lsquo;localhost&amp;rsquo; = password(&amp;lsquo;newPassword&amp;rsquo;);  db 操作 * show databases; * create NEW_DB; * drop NEW_DB; * use DBname;  table 操作 * CREATE TABLE table_name (column_name column_type); * DROP TABLE table_name ; * INSERT INTO table_name ( field1, field2,...fieldN ) VALUES ( value1, value2,...valueN ); * SELECT column_name,column_name FROM table_name [WHERE Clause] [OFFSET M ][LIMIT N] * DELETE FROM table_name [WHERE Clause]  brew安装MySQL后的提示 ==&amp;gt; .</description>
    </item>
    
    <item>
      <title>mac 下配置PHP环境</title>
      <link>https://blog.v5u.win/post/mac-php/</link>
      <pubDate>Thu, 20 Oct 2016 17:11:54 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/mac-php/</guid>
      <description>set http.conf # ...http_vhost.conf 取消注释# # ServerName www.example.com 打开
set http.vhost.conf For OSX 10.10 Apache 2.4
设置虚拟机
&amp;amp;lt;Directory &amp;quot;/Users/username/Sites/&amp;quot;&amp;amp;gt; AllowOverride All Options Indexes MultiViews FollowSymLinks Require all granted &amp;amp;lt;/Directory&amp;amp;gt;  set php LoadModule php5_module libexec/apache2/libphp5.so 修改文件权限 chmod 777 MetInfo5.3</description>
    </item>
    
    <item>
      <title>如何选择编程语言</title>
      <link>https://blog.v5u.win/post/system-%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/</link>
      <pubDate>Wed, 19 Oct 2016 10:20:13 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/system-%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/</guid>
      <description>学习某个技能，不是单纯为了哪个技能更有前途，而是因为以下几种原因： 1. 解决问题需要用到他； 2. 自己在这方面有天赋能很快的掌握它，技不压身； 3. 学习他能获得对自己有益的一种新的思路； 4. 自己爱用他
想做web界面，学HTML,CSS,JavaScript 想做小成本网站，学php/MySQL (或 ROR) 想入门编程，学python (Stanford 的选择) 想做企业级开发，学JEE 想做iOS开发，学objC和cocoa 想做系统开发，学linux/shell/c/cpp 想做DBA，折腾DBMS 和各种sql</description>
    </item>
    
    <item>
      <title>升级xcode8后不能使用注释</title>
      <link>https://blog.v5u.win/post/xcode-xcode8/</link>
      <pubDate>Fri, 14 Oct 2016 09:58:00 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/xcode-xcode8/</guid>
      <description>苹果解决xcode ghost。把插件屏蔽了。解决方法
命令运行： sudo /usr/libexec/xpccachectl 然后必须重启电脑后生效</description>
    </item>
    
    <item>
      <title>Xcode实用快捷键收集</title>
      <link>https://blog.v5u.win/post/xcode-%E5%BF%AB%E6%8D%B7%E9%94%AE/</link>
      <pubDate>Tue, 20 Sep 2016 13:51:51 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/xcode-%E5%BF%AB%E6%8D%B7%E9%94%AE/</guid>
      <description>整行移动 option+commend+[] 当前页快速定位：ctl+6 项目中file间快速定位：shift+cmd+o 删除光标右边的字符：Ctrl+D 删除本行：Ctrl+K 光标移动到上一行：Ctrl+P 移动光标到下一行：Ctrl + N 折叠全部方法实现：shift+option+commend+left 显示自动提示：ESC  </description>
    </item>
    
    <item>
      <title>weak-unowned</title>
      <link>https://blog.v5u.win/post/swift-weak-unowned/</link>
      <pubDate>Mon, 19 Sep 2016 18:11:47 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/swift-weak-unowned/</guid>
      <description>swift weak和unowned 的区别 unowned 设置以后即使它原来引用的内容已经被释放了，它仍然会保持对被已经释放了的对象的一个 &amp;ldquo;无效的&amp;rdquo; 引用，它不能是 Optional 值，也不会被指向 nil。如果你尝试调用这个引用的方法或者访问成员属性的话，程序就会崩溃。而 weak 则友好一些，在引用的内容被释放后，标记为 weak 的成员将会自动地变成 nil (因此被标记为 @weak 的变量一定需要是 Optional 值)。关于两者使用的选择，Apple 给我们的建议是如果能够确定在访问时不会已被释放的话，尽量使用 unowned，如果存在被释放的可能，那就选择用 weak。</description>
    </item>
    
    <item>
      <title>Xcode8添加iOS7真机调试</title>
      <link>https://blog.v5u.win/post/xcode-xcode8-ios7-device/</link>
      <pubDate>Mon, 19 Sep 2016 11:58:47 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/xcode-xcode8-ios7-device/</guid>
      <description>打开Xcode8和Xcode7的app包内容 Contants/Developer/Platforms/iPhoneOS.platform/DeviceSupport 将Xcode7的iOS7的框架copy到Xcode8内</description>
    </item>
    
    <item>
      <title>Swift3更改</title>
      <link>https://blog.v5u.win/post/swift-swift3%E6%9B%B4%E6%94%B9/</link>
      <pubDate>Sun, 18 Sep 2016 13:51:51 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/swift-swift3%E6%9B%B4%E6%94%B9/</guid>
      <description>升级Swift3后代码的更改差异    before after      error as NSError error    UIColor().blackColor() UIColor().balck    xxx.hidden xxx.isHidden 所有的bool属性，都+前缀：is   private fileprivate    NSBundle Bundle    func fetchInfo(complete: () -&amp;gt; ()) {} func fetchInfo(_ complete: () -&amp;gt; ()) {} function的参数命名必需添加外部访问参数名或_   setValuesForKeysWithDictionary setValuesForKeys    MBProgressHUD.hideHUDForView() MBProgressHUD.hide(for:) for ,with ,of,in 等方法名缩短为(xxx:) 形式   registerClass() register()    CGRectMake CGRect()    forControlEvents: .</description>
    </item>
    
    <item>
      <title>Sublime Text3 使用心得</title>
      <link>https://blog.v5u.win/post/sublime-nodejs/</link>
      <pubDate>Fri, 09 Sep 2016 14:45:12 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/sublime-nodejs/</guid>
      <description>build nodejs项目 sublime text 3自带build的系统，只需要在tools-&amp;gt;build system-&amp;gt; new build system&amp;hellip;
{ &amp;quot;shell_cmd&amp;quot;: &amp;quot;node $file&amp;quot;, &amp;quot;selector&amp;quot;: &amp;quot;source.js&amp;quot; }   保存为 node.sublime-build，就可以使用cmd+shift+b调出窗口选择node编译.
在keymap绑定按键：
{ &amp;quot;keys&amp;quot;: [&amp;quot;ctrl+c&amp;quot;], &amp;quot;command&amp;quot;: &amp;quot;exec&amp;quot;, &amp;quot;args&amp;quot;: { &amp;quot;kill&amp;quot;: true } }  就可以使用快捷键ctrl+c关闭，或者手动点选tools-&amp;gt; cancel build中断。
需要编译es6的代码的话可以考虑用babel，build tools替换成
{ &amp;quot;shell_cmd&amp;quot;: &amp;quot;babel-node $file&amp;quot;, &amp;quot;selector&amp;quot;: &amp;quot;source.js&amp;quot; }  插件安装 shift+commend+p 输入install敲return/Enter，查找插件
我安装的插件： * Babel ES2015语法转化器 * EJS WEB所使用的模板引擎之一 * emmet 提高HTML &amp;amp;amp; CSS3编写速度 * ConvertToUTF8 UTF8转换 *
插件使用教程： emmet : http://www.</description>
    </item>
    
    <item>
      <title>mac下npm的使用方式</title>
      <link>https://blog.v5u.win/post/mac-npm/</link>
      <pubDate>Thu, 08 Sep 2016 14:30:11 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/mac-npm/</guid>
      <description>npm init #创建package.json文件 npm install xxx -g #全局安装 -g npm install xxx #没有package.json文件的时候使用，当前文件下安装 npm install xxx --save #添加到package.json中的dependencies配置中 npm install xxx --save-dev #添加到package.json中devDependencies配置中 npm uninstall xxx 删除包 npm ls #查看当前目录中已安装的包 -g 全局 npm update xxx #单包更新 npm search xxx #搜索 npm ls xxx 查看xxx包的版本信息 npm ls --depth 0 #查看安装包列表 npm prune -x #删除多余的包 npm ls -g --depth xxx #查看全局npm版本  </description>
    </item>
    
    <item>
      <title>Sublime Texts使用tips</title>
      <link>https://blog.v5u.win/post/sublime-tips/</link>
      <pubDate>Sun, 04 Sep 2016 00:07:07 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/sublime-tips/</guid>
      <description> 多行编辑：control + 点击各行编辑位置 全局修改所有单词：双击单词，comment+control+G 选中一个单词：Command + D 选中一个单词及下一个同样的单词 包管理工具：control package ,快捷键：shift+commend+P  </description>
    </item>
    
    <item>
      <title>objective-c代码规范</title>
      <link>https://blog.v5u.win/post/ios-oc-code-style/</link>
      <pubDate>Thu, 25 Aug 2016 16:45:01 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/ios-oc-code-style/</guid>
      <description>Objective-C代码规范 前言 Apple公司提供了一些代码规范文档。如果有内容未在此文档中提及，请参考如下内容：
 The Objective-C Programming Language Cocoa Fundamentals Guide Coding Guidelines for Cocoa iOS App Programming Guide  适用范围 所有适用Objective-C语言开发的项目。 在这里我们希望以类似断言的方式,大家逐条对比写出的代码和下列规范是否吻合,以达到预期的代码的可读性。
代码规范 命名 基于iOS objective-c项目对于命名，目前分为变量名和函数名两类
变量名 在这里我们把描述一个事物或者抽象事物的描述符统称为变量名。变量名目前分为几类: 类名，协议名，组合名，oc类内部变量，全局变量，枚举类型，block类型，结构体类型。 以下分别例举了几种类型的例子。
类名  使用类前缀 需要包含一个名词用来表示这个类是什么,比如 NSString, NSDate, NSScanner等。
@interface MKUserTrackingBarButtonItem : UIBarButtonItem `
协议名 使用类前缀
 在这里我们需要考虑一个重要的问题,不要滥用关键字,。面列了两个协议，&amp;rdquo;delegate&amp;rdquo;通常用于实现委托功能,而第二个用于实现的重载。
 大部分协议实际是包括一组功能相关的函数，并且和具体用于实现的类没有特别紧密的联系。这时候命名要考虑和具体实现类区分开，比如起名为NSLocking而不是NSLock。
 还有一些协议实际上囊括了很多不相关的功能（或者说像是很多个子协议的组合），这时候就可以和具体的实现类保持一致的名字，比如NSObject。
`@protocol MKMapViewDelegate &amp;lt;NSObject&amp;gt; @protocol MKAnnotation &amp;lt;NSObject&amp;gt; ` 组合名 需要类前缀
`@interface NSString (NSStringExtensionMethods) ` oc类内部变量 无需类前缀
 尽可能使用property定义变量
 .</description>
    </item>
    
    <item>
      <title>Express</title>
      <link>https://blog.v5u.win/post/nodejs-express/</link>
      <pubDate>Wed, 17 Aug 2016 11:05:24 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/nodejs-express/</guid>
      <description>nodejs + express 学习记录
设置入口文件 app.use(express.static(__dirname + &#39;/public&#39;)); ###use方法 use是express注册中间件的方法，它返回一个函数。
中间件（middleware）就是处理HTTP请求的函数。它最大的特点就是，一个中间件处理完，再传递给下一个中间件。App实例在运行过程中，会调用一系列的中间件。
set方法用于指定变量的值。 app.set(&amp;ldquo;views&amp;rdquo;, __dirname + &amp;ldquo;/views&amp;rdquo;) 为系统变量views指定值 app.set(&amp;ldquo;view engine&amp;rdquo;, &amp;ldquo;jade&amp;rdquo;)</description>
    </item>
    
    <item>
      <title>struct 和class的区别</title>
      <link>https://blog.v5u.win/post/struct-class/</link>
      <pubDate>Mon, 15 Aug 2016 15:58:34 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/struct-class/</guid>
      <description>struct是值类型，值类型在传递和赋值时将进行复制。 class是引用类型，引用类型只会使用引用对象的一个『指向』
 class有这几个功能struct没有的：
class可以继承，这样子类可以使用父类的特性和方法 类型转换可以在runtime的时候检查和解释一个实例的类型 可以用deinit来释放资源 一个类可以被多次引用 `
struct也有这样几个优势：
`结构较小，适用于复制操作，相比于一个class的实例被多次引用更加安全 无须担心内存memory leak或者多线程冲突问题
  顺便提一下，array在swift中是用struct实现的。Apple重写过一次array，然后复制就是深度拷贝了。猜测复制是类似参照那样，通过栈上指向堆上位置的指针来实现的。而对于它的复制操作，也是在相对空间较为宽裕的堆上来完成的，所以性能上还是不错的。</description>
    </item>
    
    <item>
      <title>use sublime Text</title>
      <link>https://blog.v5u.win/post/sublime-setting/</link>
      <pubDate>Wed, 10 Aug 2016 00:00:00 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/sublime-setting/</guid>
      <description> 如何设置折行 &amp;lsquo;将配置文件里 添加word_wrap:true 字段&amp;rsquo;
{ &amp;quot;color_scheme&amp;quot;: &amp;quot;Packages/Color Scheme - Default/Monokai.tmTheme&amp;quot;, &amp;quot;font_size&amp;quot;: 13, &amp;quot;word_wrap&amp;quot;: true, &amp;quot;ignored_packages&amp;quot;: [ &amp;quot;Vintage&amp;quot; ] }  痛点1：每次编写完Python文件后都要切到terminal下输入python fileName.py命令执行文件。 解决：mac版sublime text编辑器使用shift+command+b选择Python 直接执行文件  痛点2：sublime默认执行的Python版本是系统默认的，不能直接使用Python3来执行Python文件 解决：Tools--&amp;gt;Build System--&amp;gt;New Build System 写入： { &amp;quot;shell_cmd&amp;quot;: &amp;quot;/usr/local/homebrew/bin/python3 ${file}&amp;quot;, &amp;quot;selector&amp;quot; :&amp;quot;source.python&amp;quot;, &amp;quot;file_regex&amp;quot;:&amp;quot;^(...*?):[0-9]:?([0-9]*)&amp;quot;, &amp;quot;working_dir&amp;quot;:&amp;quot;${file_path}&amp;quot;, &amp;quot;env&amp;quot;: {&amp;quot;PYTHONIOENCODING&amp;quot;: &amp;quot;utf8&amp;quot;}, } 保存为/Packages/User/python3.sublime-build 然后选择环境为python3即可 ps: `env` //设置编码格式 `shell_cmd` 使用的路径，通过在terminal中执行which Python3 获得  </description>
    </item>
    
    <item>
      <title>函数式编程</title>
      <link>https://blog.v5u.win/post/system-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/</link>
      <pubDate>Fri, 05 Aug 2016 10:46:42 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/system-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/</guid>
      <description> 函数式编程的三大特性： •immutable data 不可变数据：
像Clojure一样，默认上变量是不可变的，如果你要改变变量，你需要把变量copy出去修改。这样一来，可以让你的程序少很多Bug。因为，程序中的状态不好维护，在并发的时候更不好维护。（你可以试想一下如果你的程序有个复杂的状态，当以后别人改你代码的时候，是很容易出bug的，在并行中这样的问题就更多了）
•first class functions：
这个技术可以让你的函数就像变量一样来使用。也就是说，你的函数可以像变量一样被创建，修改，并当成变量一样传递，返回或是在函数中嵌套函数。这个有点像Javascript的Prototype（参看Javascript的面向对象编程）
•尾递归优化：
我们知道递归的害处，那就是如果递归很深的话，stack受不了，并会导致性能大幅度下降。所以，我们使用尾递归优化技术——每次递归时都会重用stack，这样一来能够提升性能，当然，这需要语言或编译器的支持。Python就不支持。
函数式编程的准则：不依赖于外部的数据，而且也不改变外部数据的值，而是返回一个新的值给你。
函数式编程的理念：把函数当成变量来用，关注于描述问题而不是怎么实现，这样可以让代码更易读。
把代码逻辑封装成了函数后，我们就相当于给每个相对独立的程序逻辑取了个名字，于是代码成了自解释的。
但是这些函数间必需知道其它函数是怎么修改它们之间的共享变量的，所以，这些函数是有状态的。解决办法就是Functional Programming 的编程范式
函数式编程有如下好处：
1.代码更简单了。
2.数据集，操作，返回值都放到了一起。
3.你在读代码的时候，没有了循环体，于是就可以少了些临时变量，以及变量倒来倒去逻辑。
4.你的代码变成了在描述你要干什么，而不是怎么去干。
避免使用程序状态和可变对象,是降低程序复杂度的有效方式之一,而这也正是函数式编程的精髓。 函数式编程强调执行的结果,而非执行的过程。
 我们先构建一系列简单却具有一定功能的小函数,然后再将这些函数进行组装以实现完整的逻辑和复杂的运算,这是函数式编程的基本思想。
 </description>
    </item>
    
    <item>
      <title>swiftError</title>
      <link>https://blog.v5u.win/post/swift-swifterror/</link>
      <pubDate>Fri, 29 Jul 2016 11:46:10 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/swift-swifterror/</guid>
      <description>value of type &amp;lsquo;UILable&amp;rsquo; has no member &amp;lsquo;then&amp;rsquo;
UILable 没有扩展 then的协议 fix： extension UIView: Then{}</description>
    </item>
    
    <item>
      <title>richDadReaded</title>
      <link>https://blog.v5u.win/post/read-richdadreaded/</link>
      <pubDate>Thu, 28 Jul 2016 09:24:11 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/read-richdadreaded/</guid>
      <description> 年轻退休
1. 心智的杠杆 词语是杠杆 2. 计划的杠杆 3. 行动的杠杆   </description>
    </item>
    
    <item>
      <title>物美价廉的VPS云主机</title>
      <link>https://blog.v5u.win/post/businuss-vps/</link>
      <pubDate>Mon, 25 Jul 2016 00:00:00 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/businuss-vps/</guid>
      <description>搬瓦工(2.99$起≈20￥/月)
https://bandwagonhost.com/aff.php?aff=7288 选Los Angeles机房 参考：http://www.panxw.com/posts/good-vps-list.html</description>
    </item>
    
    <item>
      <title>Workspace的使用方法</title>
      <link>https://blog.v5u.win/post/xcode-workspace/</link>
      <pubDate>Thu, 21 Jul 2016 16:39:53 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/xcode-workspace/</guid>
      <description> 更改 xcode-&amp;gt; Preference -&amp;gt; Location -&amp;gt; Advanced -&amp;gt; Custom -&amp;gt; Relative to Workspace 新建Workspace 新建项目或静态库，选择 add workspace name 引入路径依赖，User Header Search Paths 设为 $(BUILT_PRODUCTS_DIR) 选择递归搜索 recursive 检查 scheme manage 中的项目依赖  </description>
    </item>
    
    <item>
      <title>mac下MongoDB</title>
      <link>https://blog.v5u.win/post/mac-bmongodb/</link>
      <pubDate>Mon, 18 Jul 2016 18:16:11 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/mac-bmongodb/</guid>
      <description>1. 安装 1.1 解压缩mongo文件，将解压缩后的文件移动到自己喜欢的目录下 1.2 由于没有配置环境变量，先测试使用。 终端进入mongodb的安装路径，在bin路径下，执行./mongod启动数据库
有可能报错 exception in initAndListen: 29 Data directory /data/db not found 这是因为/data/db 目录不存在，若启动时，不指定任何参数， MongoDB 会默认使用 /data/db 目录存储数据， 我们可以使用 &amp;ndash;dbpath 来指定其它的路径，比如我使用的是下面这样的命令启动的： ./mongod --dbpath ../data/db 新开一个终端，在bin路径下执行./mongo启动mongodb管理
2. 使用 show dbs 显示 数据库s use dbName 切换数据库 show collections 数据库下的显示表 db.表明.find() 显示表中数据</description>
    </item>
    
    <item>
      <title>FF的Git使用整理</title>
      <link>https://blog.v5u.win/post/system-git_use/</link>
      <pubDate>Tue, 05 Jul 2016 14:47:35 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/system-git_use/</guid>
      <description>创建 Git仓库命令：(进入将要管理的Git文件夹地址下) git init 查看当前Git管理状态 git status 添加Git文件 git add * 提交文件到仓库 git commit -m &amp;ldquo;加入注释&amp;rdquo; 推送文件到远程仓库 git push origin master 参考文章：Git简易使用指南 http://www.bootcss.com/p/git-guide/
git 命令行常用命令    git 作用 命令     检查更新状态 git status   将文件添加进更新列表 git add *   commit 提交 git commit * -m &amp;ldquo;add some(not null非空)&amp;rdquo;   发布到服务器 use &amp;ldquo;git push&amp;rdquo; to publish your local commits   发布到主线 git push origin master   发布tag release版本 git tag   add tag git tag -m &amp;ldquo;first release&amp;rdquo; 0.</description>
    </item>
    
    <item>
      <title>如何进入ghostblog的管理面板</title>
      <link>https://blog.v5u.win/post/blog-ghost/</link>
      <pubDate>Mon, 04 Jul 2016 14:39:44 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/blog-ghost/</guid>
      <description>在域名后面加上/ghost 进入网站空间下的ghost路径下就行</description>
    </item>
    
    <item>
      <title>sketch使用tips</title>
      <link>https://blog.v5u.win/post/design-sketch_tips/</link>
      <pubDate>Mon, 04 Jul 2016 14:19:13 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/design-sketch_tips/</guid>
      <description>   记录sketch使用心得     1. 打开设计模板：file&amp;ndash;&amp;gt; New from Template &amp;ndash;&amp;gt;选择需要的模板库（Android Icon Design，iOS APP Icon，iOS UI Design等）   2. 导出资源文件：右下角Make Exportable + &amp;ndash;&amp;gt; 选择导出图片规格 &amp;ndash;&amp;gt; Export xxx   3. 固定图层（加锁）：按住Option+鼠标点击需要加锁的图层    </description>
    </item>
    
    <item>
      <title>使用hexo的第一篇文章</title>
      <link>https://blog.v5u.win/post/blog-hexo/</link>
      <pubDate>Thu, 30 Jun 2016 17:40:48 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/blog-hexo/</guid>
      <description>hexo建站之后如何使用 1.如何写文章 hexo 需要配合git使用 创建文章：需要在terminal 输入命令 hexo new &amp;ldquo;文章名&amp;rdquo; 创建好的&amp;rdquo;文件名.md&amp;rdquo; 文件会放在站点目录 ./source/_posts/ 下
注意：资源文件都放在source/_posts文件下（不要创建其他目录，否则解析的时候可能会报错）
2.如何发布文章 每次发布文章都需要执行命令：
hexo generate
hexo deploy
3.本地启动hexo 查看网站更新 hexo server
4.设置新建文章的模板 创建新文件: hexo new passageName
默认创建在source/_post目录下，使用scaffolds/post.md作为模板
文章filename根据_config.yml配置自动创建为new_post_name: :year-:month-:day-:title.md</description>
    </item>
    
    <item>
      <title>NodeJS 文件系统</title>
      <link>https://blog.v5u.win/post/nodejs-filesystem/</link>
      <pubDate>Thu, 30 Jun 2016 11:39:32 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/nodejs-filesystem/</guid>
      <description>文件加载顺序：
st=&amp;amp;gt;start: 开始require isfc=&amp;amp;gt;condition: 是否在文件缓冲区 isnf=&amp;amp;gt;condition: 是否是原生模块 ff=&amp;amp;gt;operation: 查找文件模块 lfm=&amp;amp;gt;operation: 根据扩展名载入模块 cfm=&amp;amp;gt;operation: 缓存文件模块 isnc=&amp;amp;gt;condition: 是否在原生模块缓存区中 lnf=&amp;amp;gt;operation: 加载原生模块 cnf=&amp;amp;gt;operation: 缓存原生模块 e=&amp;amp;gt;end: 返回exports st-&amp;amp;gt;isfc isfc(yes)-&amp;amp;gt;e isfc(no)-&amp;amp;gt;isnf(no)-&amp;amp;gt;ff-&amp;amp;gt;lfm-&amp;amp;gt;cfm-&amp;amp;gt;e isnf(yes)-&amp;amp;gt;isnc(yes)-&amp;amp;gt;lnf-&amp;amp;gt;cnf-&amp;amp;gt;e isnc(no)-&amp;amp;gt;e  require方法接受以下几种参数的传递： http、fs、path等，原生模块。 ./mod或../mod，相对路径的文件模块。 /pathtomodule/mod，绝对路径的文件模块。 mod，非原生模块的文件模块。</description>
    </item>
    
    <item>
      <title>Swift与Objective-C的兼容方法:@objc和Dynamic</title>
      <link>https://blog.v5u.win/post/swift-objcdynamic/</link>
      <pubDate>Tue, 07 Jun 2016 10:02:09 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/swift-objcdynamic/</guid>
      <description>Swift必须考虑与Objective-C的兼容。
首先通过添加{product-module-name}-Bridging-Header.h文件，并在其中填写想要使用的头文件名称，我们就可以很容易地在Swift中使用Objective-C代码了。Xcode为了简化这个设定，甚至在Swift项目中第一次导入Objective-C文件时会主动弹框进行询问是否要自动创建这个文件，可以说是非常方便。
但是如果想要在Objective-C中使用Swift的类型的时候，事情就复杂一些。如果是来自外部的框架，那么这个框架与Objective-C项目肯定不是处在同一个target中的，我们需要对外部的Swift module进行导入。这个其实和使用Objective-C的原来的Framework是一样的，对于一个项目来说，外界框架是由Swift写的还是Objective-C写的，两者并没有太大区别。我们通过使用2013年新引入的@import来引入module：
[cpp] view plaincopy在CODE上查看代码片派生到我的代码片 @import MySwiftKit;
之后就可以正常使用这个Swift写的框架了。
如果想要在Objective-C里使用的是同一个项目中的Swift的源文件的话，可以直接导入自动生成的头文件{product-module-name}-Swift.h来完成。比如项目的target叫做MyApp的话，我们就需要在Objective-C文件中写：
[cpp] view plaincopy在CODE上查看代码片派生到我的代码片 #import &amp;ldquo;MyApp-Swift.h&amp;rdquo;
但这只是故事的开始。Objective-C和Swift在底层使用的是两套完全不同的机制，Cocoa中的Objective-C对象是基于运行时的，它从骨子里遵循了KVC（Key-Value Coding，通过类似字典的方式存储对象信息）以及动态派发（Dynamic Dispatch，在运行调用时再决定实际调用的具体实现）。而Swift为了追求性能，如果没有特殊需要的话，是不会在运行时再来决定这些的。也就是说，Swift类型的成员或者方法在编译时就已经决定，而运行时便不再需要经过一次查找，而可以直接使用。
显而易见，这带来的问题是如果我们要使用Objective-C的代码或者特性来调用纯Swift的类型时候，我们会因为找不到所需要的这些运行时信息，而导致失败。解决起来也很简单，在Swift类型文件中，我们可以将需要暴露给Objective-C使用的任何地方（包括类，属性和方法等）的声明前面加上@objc修饰符。注意这个步骤只需要对那些不是继承自NSObject的类型进行，如果你用Swift写的class是继承自NSObject的话，Swift会默认自动为所有的非private的类和成员加上@objc。这就是说，对一个NSObject的子类，你只需要导入相应的头文件就可以在Objective-C里使用这个类了。
@objc修饰符的另一个作用是为Objective-C侧重新声明方法或者变量的名字。虽然绝大部分时候自动转换的方法名已经足够好用（比如会将Swift中类似init(name: String) 的方法转换成-initWithName:(NSString *)name这样），但是有时候我们还是期望Objective-C里使用和Swift中不一样的方法名或者类的名字，比如Swift里这样的一个类：
[cpp] view plaincopy在CODE上查看代码片派生到我的代码片 class 我的类 {
func 打招呼(名字: String) { println(&amp;quot;哈喽，&amp;amp;#40;名字)&amp;quot;) }  }
我的类().打招呼(&amp;ldquo;小明&amp;rdquo;)
Objective-C的话是无法使用中文来进行调用的，因此我们必须使用@objc将其转为ASCII才能在Objective-C里访问：
[cpp] view plaincopy在CODE上查看代码片派生到我的代码片 @objc(MyClass)
class 我的类 {
@objc(greeting:) func 打招呼(名字: String) { println(&amp;quot;哈喽，&amp;amp;#40;名字)&amp;quot;) }  }
这样，我们在Objective-C里就能调用 [[MyClass new] greeting:@&amp;ldquo;XiaoMing&amp;rdquo;] 这样的代码了（虽然比起原来一点都不好玩了）。另外，正如上面所说的以及在Selector一节中所提到的，即使是NSObject的子类，Swift也不会在被标记为private的方法或成员上自动加@objc。如果我们需要使用这些内容的动态特性的话，我们需要手动给它们加上@objc修饰。
添加@objc修饰符并不意味着这个方法或者属性会变成动态派发，Swift依然可能会将其优化为静态调用。如果你需要和Objective-C里动态调用时相同的运行时特性的话，你需要使用的修饰符是dynamic。一般情况下在做App开发时应该用不上，但是在施展一些像动态替换方法或者运行时再决定实现这样的 &amp;ldquo;黑魔法&amp;rdquo; 的时候，我们就需要用到dynamic修饰符了。在之后的KVO一节中，我们还会提到一个关于使用dynamic的实例。</description>
    </item>
    
    <item>
      <title>swift 中初始化ViewController</title>
      <link>https://blog.v5u.win/post/swift-init-viewcontroller/</link>
      <pubDate>Mon, 06 Jun 2016 18:25:00 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/swift-init-viewcontroller/</guid>
      <description>let vc = NameVC()
init(title: String){ super.init(nibName: nil, bundle: nil) self.title = title } required init?(coder aDecoder: NSCoder) { fatalError(&amp;quot;init(coder:) has not been implemented&amp;quot;) }  </description>
    </item>
    
    <item>
      <title>Xcode插件XcodeColors的使用</title>
      <link>https://blog.v5u.win/post/xcode-xcodecolors/</link>
      <pubDate>Fri, 27 May 2016 12:51:27 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/xcode-xcodecolors/</guid>
      <description>安装： 在 管理器中搜索 下载 Xcodecolors 重启Xcode 选择load boundle
使用： 配置环境变量－&amp;gt; 打开Product -&amp;gt; Edit Scheme 选择Run-&amp;gt;&amp;ldquo;Arguments&amp;rdquo; tab 增加一个新的Environment Variable ，命名为&amp;rdquo;XcodeColors&amp;rdquo;，值赋为YES
代码中添加：
#define XCODE_COLORS_ESCAPE @&amp;quot;\033[&amp;quot; #define XCODE_COLORS_RESET XCODE_COLORS_ESCAPE @&amp;quot;;&amp;quot; // Clear any foreground or background color char * xcode_colors = getenv(&amp;quot;XcodeColors&amp;quot;); if (xcode_colors &amp;amp;amp;&amp;amp;amp; (strcmp(xcode_colors, &amp;quot;YES&amp;quot;)) == 0) { NSLog(XCODE_COLORS_ESCAPE @&amp;quot;fg0,0,255;&amp;quot; @&amp;quot;Blue text&amp;quot; XCODE_COLORS_RESET); }  说明：getenv()方法为c库中的获取环境变量内容方法。</description>
    </item>
    
    <item>
      <title>mac下wireshark的使用方法</title>
      <link>https://blog.v5u.win/post/mac-wireshark/</link>
      <pubDate>Wed, 18 May 2016 18:47:09 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/mac-wireshark/</guid>
      <description>Wireshark是mac下一款非常好的抓包工具，安装我就不说了，下面我重点来说说如何使用。 1.打开终端 2.rvictl -s  // 创建一个虚拟接口 3.打开Wireshark，点击设置按钮，选择rvi0接口 4.开始调试
通过 RVI 抓取 iPhone 数据包 （1）RVI 简介 使用 Mac 抓取 iPhone 数据包可通过共享和代理两种方式： 使用 Mac 的网络共享功能将 Mac 的网络通过 WiFi 共享给 iPhone 连接； 使用代理软件（例如 Charles）在Mac上建立HTTP代理服务器。 这两种方式都是将 iPhone 的网络流量导入到 Mac 电脑中，通过 Mac 连接互联网。这就要求 Mac 本身是联网的，对于网络共享的方式还要求 Mac 本身的网络不能使用 WiFi，而且在 iPhone 上只能使用 WiFi 连接，无法抓取到 xG（2G/3G/4G） 网络包。 苹果在 iOS 5 中新引入了“远程虚拟接口（Remote Virtual Interface,RVI）”的特性，可以在 Mac 中建立一个虚拟网络接口来作为 iOS 设备的网络栈，这样所有经过 iOS 设备的流量都会经过此虚拟接口。此虚拟接口只是监听 iOS 设备本身的协议栈（但并没有将网络流量中转到 Mac 本身的网络连接上），所有网络连接都是 iOS 设备本身的，与 Mac 电脑本身联不联网或者联网类型无关。iOS设备本身可以为任意网络类型（WiFi/xG），这样在 Mac 电脑上使用任意抓包工具（tcpdump、Wireshark、CPA）抓取 RVI 接口上的数据包就实现了对 iPhone 的抓包。</description>
    </item>
    
    <item>
      <title>JavaScriptCore</title>
      <link>https://blog.v5u.win/post/ios-javascriptcore/</link>
      <pubDate>Fri, 29 Apr 2016 17:43:54 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/ios-javascriptcore/</guid>
      <description>JavaScript 和OC原生交互
- (void)ocCallJSFunction{ JSContext context = [[JSContext alloc]init]; JSValue jsValue = [context evaluateScript:@&amp;quot;21+7&amp;quot;]; int iVal = [jsValue toInt32]; NSLog(@&amp;quot;js value=%@,int=%d&amp;quot;,jsValue, iVal); [context evaluateScript:@&amp;quot;var arr = [21, 7, &#39;fanyiqing.com&#39;];&amp;quot;]; JSValue jsArr = context[@&amp;quot;arr&amp;quot;]; NSLog(@&amp;quot;JS Array:%@ length:%@&amp;quot;,jsArr,jsArr[@&amp;quot;length&amp;quot;]); jsArr[1] = @&amp;quot;blog&amp;quot;; jsArr[7] = @7; NSLog(@&amp;quot;JS Array:%@, length:%d&amp;quot;,jsArr,[jsArr[@&amp;quot;length&amp;quot;] toInt32]); NSArray nsarray = [jsArr toArray]; NSLog(@&amp;quot;nsarray:%@&amp;quot;,nsarray); }  </description>
    </item>
    
    <item>
      <title>class xxx has no initializers</title>
      <link>https://blog.v5u.win/post/swift-class-xxx-has-no-initializers/</link>
      <pubDate>Mon, 25 Apr 2016 17:09:01 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/swift-class-xxx-has-no-initializers/</guid>
      <description>error: class xxx has no initializers 这是说变量没有初始化，比如 var label:UILabel 应该写成 var label:UILabel?</description>
    </item>
    
    <item>
      <title>vim使用记录</title>
      <link>https://blog.v5u.win/post/system-vim/</link>
      <pubDate>Mon, 18 Apr 2016 17:26:21 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/system-vim/</guid>
      <description>剪切复制粘贴 命令模式下（esc）剪切一行：dd ;三行：3dd y复制 d()剪切 p(paste)粘贴</description>
    </item>
    
    <item>
      <title>iOS GCD dispatch barrier</title>
      <link>https://blog.v5u.win/post/ios-gcd-dispatch-barrier/</link>
      <pubDate>Fri, 15 Apr 2016 10:15:25 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/ios-gcd-dispatch-barrier/</guid>
      <description>需求： 两个线程并行执行，当两线程都执行完后，在执行另一个线程，然后在执行并行多线程
thread1 thread4 --&amp;amp;gt; thread3 --&amp;amp;gt; thread2 thread5  一个dispatch barrier 允许在一个并发队列中创建一个同步点。当在并发队列中遇到一个barrier, 他会延迟执行barrier的block,等待所有在barrier之前提交的blocks执行结束。 这时，barrier block自己开始执行。 之后， 队列继续正常的执行操作。
调用这个函数总是在barrier block被提交之后立即返回，不会等到block被执行。当barrier block到并发队列的最前端，他不会立即执行。相反，队列会等到所有当前正在执行的blocks结束执行。到这时，barrier才开始自己执行。所有在barrier block之后提交的blocks会等到barrier block结束之后才执行。
这里指定的并发队列应该是自己通过dispatch_queue_create函数创建的。如果你传的是一个串行队列或者全局并发队列，这个函数等同于dispatch_async函数。</description>
    </item>
    
    <item>
      <title>Xcode7 恢复代码折叠功能</title>
      <link>https://blog.v5u.win/post/xcode-xcode7-code-hidden/</link>
      <pubDate>Fri, 08 Apr 2016 18:14:53 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/xcode-xcode7-code-hidden/</guid>
      <description>升级到Xcode7后，发现代码折叠功能不见了！！！ 苹果默认把这个功能禁掉了：在Xcode菜单里选择Preference——Text Editing，你会发现里面有一个“code folding ribbon”，勾选它就能恢复代码折叠功能了。
然后通过菜单Editor——Code Folding，你就可以使用你需要的折叠功能。
   相关快捷键：     局部折叠（折叠一个函数） ：Command+Option+Left/Right   全局折叠（折叠当前文件下的全部函数）：Shift+Command+Option+Left/Right   折叠注释块：（/* */之间的文字） ： Ctrl+Shift+Command+Left/Right    </description>
    </item>
    
    <item>
      <title>Xcode7.3 cannot create __weak reference in file using</title>
      <link>https://blog.v5u.win/post/xcode-xcode7-3-cannot-create-weak-reference-in-file-using/</link>
      <pubDate>Fri, 08 Apr 2016 16:26:43 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/xcode-xcode7-3-cannot-create-weak-reference-in-file-using/</guid>
      <description>升级xcode7.3后项目编译不通过 error：cannot create __weak reference in file using manual reference counting 解决办法： Set Build Settings -&amp;gt; Apple LLVM 7.1 - Language - Objective C -&amp;gt; Weak References in Manual Retain Release to YES.</description>
    </item>
    
    <item>
      <title>react JS style样式设置总结</title>
      <link>https://blog.v5u.win/post/web-react-js-style-collection/</link>
      <pubDate>Fri, 08 Apr 2016 14:29:04 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/web-react-js-style-collection/</guid>
      <description>const styles = StyleSheet.create({ style_0:{ flex:1, borderColor: &#39;red&#39;, borderWidth:1, }, &amp;amp;lt;View style={styles.style_0}&amp;amp;gt; &amp;amp;lt;View style={[styles.view, styles.center]}&amp;amp;gt;&amp;amp;lt;Text&amp;amp;gt;自由摆放&amp;amp;lt;/Text&amp;amp;gt;&amp;amp;lt;/View&amp;amp;gt; &amp;amp;lt;View style={[styles.style_1, {flexDirection: &#39;column&#39;}]}&amp;amp;gt; &amp;amp;lt;Text style={{marginTop:40, fontSize:25}}&amp;amp;gt;1／4高&amp;amp;lt;/Text&amp;amp;gt;  </description>
    </item>
    
    <item>
      <title>flex属性</title>
      <link>https://blog.v5u.win/post/web-flex/</link>
      <pubDate>Fri, 08 Apr 2016 10:56:38 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/web-flex/</guid>
      <description>   流式布局     flex为可伸缩属性，当flex大于0时View可伸缩 当多个有flex属性的View时，根据flex值分配View的相对大小，   如`&amp;lt;superView style={flex:1}&amp;gt;&amp;lt;View1 style={flex:5}&amp;gt;&amp;lt;/View1&amp;gt;&amp;lt;View2 style={flex:10}&amp;gt;&amp;lt;/View2&amp;gt;&amp;lt;/superView&amp;gt;`   则5+10=15View1占superView的5/15大小，View2是superView的10/15   flexDirection:设定布局方向 value值为: row(横向布局)，column(纵向布局)   alignSelf:对齐方式 主要有四种：flex-start(left居左)、 flex-end(right居右)、 center、 auto(默认自动)、 stretch。    </description>
    </item>
    
    <item>
      <title>xcode设置允许访问http请求</title>
      <link>https://blog.v5u.win/post/xcode-http/</link>
      <pubDate>Sun, 03 Apr 2016 14:30:54 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/xcode-http/</guid>
      <description>项目的info.plist文件添加一下值： App Transport Security Settings Allow Arbitrary Loads 设为YES</description>
    </item>
    
    <item>
      <title>iOS老应用显示不完全</title>
      <link>https://blog.v5u.win/post/ios-screenview-error/</link>
      <pubDate>Sun, 03 Apr 2016 13:55:06 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/ios-screenview-error/</guid>
      <description>解决 ： * 新建launchScreen文件 * 设置plist文件，添加Launch screen interface file base name字段 并将value值设为刚刚新建文件的文件名 * 删除模拟器或真机上的app重新编译运行</description>
    </item>
    
    <item>
      <title>Xcode快捷键</title>
      <link>https://blog.v5u.win/post/xcode-shortcut-key/</link>
      <pubDate>Tue, 29 Mar 2016 23:50:12 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/xcode-shortcut-key/</guid>
      <description>常用xcode快捷键
整行移动 option+commend+[] 当前页快速定位：ctl+6 项目中file间快速定位：shift+cmd+o 删除光标右边的字符：Ctrl+D 删除本行：Ctrl+K 光标移动到上一行：Ctrl+P 移动光标到下一行：Ctrl + N 折叠全部方法实现：shift+option+commend+left 显示自动提示：ESC 变量重命名：ctl+cmd+e (Edit All In Scop) `&amp;lt;/pre&amp;gt; crl+i 对齐代码 1.如果是在打开的文档范围内： 查找： Command+ F 替换： Command+Option+F Replace All 是全部替换本文档范围内的字符串 Replace 是替换当前字符串 Replace &amp;amp;amp; Find是边查找边替换 2.如果是全局查找和替换 查找：点击左边工具栏里面的“放大镜”按钮 或者 Shift+Command +F 替换：点击左边工具栏里面的“放大镜”按钮，然后左边 Find 改为 Replace即可。或者 Shift+Option+Command+F 3.变量重命名 Menu: Editor -&amp;amp;gt; Edit All In Scope (also shows key binding) Keyboard Shortcut: Control-Command-E If you want you can change this key binding on Preferences -&amp;amp;gt; Key Bindings -&amp;amp;gt; search for &amp;quot;Edit all in scope&amp;quot;.</description>
    </item>
    
    <item>
      <title>八大算法思想</title>
      <link>https://blog.v5u.win/post/system-%E5%85%AB%E5%A4%A7%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/</link>
      <pubDate>Wed, 23 Mar 2016 10:31:32 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/system-%E5%85%AB%E5%A4%A7%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/</guid>
      <description> 枚举 递推 递归 分治 贪心 试探 动态迭代 模拟  </description>
    </item>
    
    <item>
      <title>react-native:unexpected token error</title>
      <link>https://blog.v5u.win/post/reactnative-unexpected-token-error/</link>
      <pubDate>Tue, 22 Mar 2016 17:11:47 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/reactnative-unexpected-token-error/</guid>
      <description>react-native新建的项目默认使用ES6写法，所以如果你在用到 componentWillMount:function()这样的代码时会运行出错 解决：改成ES6写法componentWillMount(){} 其他几种方式都改为ES6写法 如果你是使用这种方式 class wyq extends Component {}定义一个组件 那么应该这样定义方法：componentWillMount(){} 如果使用这种方式定义组件 var MovieScreen = React.createClass({}） 那么应该使用这种方式定义方法：render: function() {}
请使用ES6的新写法</description>
    </item>
    
    <item>
      <title>ReactNative如何真机测试</title>
      <link>https://blog.v5u.win/post/reactnative-device-test/</link>
      <pubDate>Fri, 18 Mar 2016 13:24:28 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/reactnative-device-test/</guid>
      <description>初始学习ReactNative 最想现在真机上一睹为快，对于非零基础的程序员，最重要的是先搞明白整个工程的创建到完结的流程，对于编程语言来说从hello world，对于一个完整的项目开发平台，则从一个最简单的dome项目开始。
iOS 真机调试
方法一：（从设备访问开发服务器）
首先，你的笔记本电脑和你的手机必须处于相同的 wifi 网络中。
打开 iOS 项目的 AppDelegate.m 文件
更改 jsCodeLocation 中的 localhost 改成你电脑的局域网IP地址
在 Xcode 中，选择你的手机作为目标设备，Run 即可
可以通过晃动设备来打开开发菜单(重载、调试等)
方法二：（使用离线包）
你也可以将应用程序本身的所有 JavaScript 代码打包。这样你可以在开发服务器没有运行时测试它，并把应用程序提交到到 AppStore。
打开 iOS / AppDelegate.m
遵循“选项 2”的说明：
取消 jsCodeLocation = [[NSBundle mainBundle] URLForResource:@&amp;ldquo;main&amp;rdquo; withExtension:@&amp;ldquo;jsbundle&amp;rdquo;];
在你应用程序的根目录的终端运行给定 curl 命令 （$ curl &amp;ldquo;http://localhost:8081/Game2048.bundle?platform=ios&amp;quot; -o main.jsbundle ）//此时应该先在本地启动服务(react-native start)
//打包项目的根目录下的 js 文件到 main.jsbundle (可以直接使用上述 curl 方法打包 javascript 即可) $ react-native bundle [&amp;ndash;minify]
Packager 支持几个选项：
dev(默认的 true)——设置了 DEV 变量的值。当是 true 时，它会打开一堆有用的警告。对于产品，它建议使用 dev = false。</description>
    </item>
    
    <item>
      <title>ReactNative环境搭建</title>
      <link>https://blog.v5u.win/post/reactnative-install/</link>
      <pubDate>Fri, 18 Mar 2016 13:22:50 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/reactnative-install/</guid>
      <description>最近换了macbook，于是又要装node.js，记录一下 系统：OS X Mountain Lion 10.8.3 1/ 下载node.js for mac http://nodejs.org
双击安装，一路next，很简单。 `&amp;lt;/pre&amp;gt; 2/ 测试是否安装成功 control + space 打开spotlight，输入“终端”，就打开了终端，类似win下的cmd 输入 node -v , 回车； 输入 npm -v , 回车 若无错，则显示版本号 3/ 测试运行 在（Finder &amp;gt; ~username ）目录，新建 helloworld.js &amp;lt;pre&amp;gt;`若在Finder左侧栏看不到你的用户名，则打开Finder的偏好设置，勾选你的用户名 回到主题，helloworld.js 内容： `&amp;lt;/pre&amp;gt; *********code start********** var http = require(&#39;http&#39;); http.createServer(function(req, res){ res.writeHead(200, {&#39;Content-Type&#39;: &#39;text/plain&#39;}); res.end(&#39;Hello Worldn&#39;); }).listen(8808, &#39;127.0.0.1&#39;); console.log(&#39;Server running at http://127.0.0.1:8808&#39;); **********code end********** 运行: 打开“终端”，输入“node helloworld.js” （若在其他目录，则在简介里复制完整位置） such as： node /Users/inman/Sites/node/helloworld.js &amp;lt;pre&amp;gt;`若无误，则显示 Server running at http://127.</description>
    </item>
    
    <item>
      <title>React-Native 初次安装环境报错及解决记录</title>
      <link>https://blog.v5u.win/post/reactnative-first-install/</link>
      <pubDate>Tue, 15 Mar 2016 16:38:19 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/reactnative-first-install/</guid>
      <description>创建第一个项目后，打开xcode运行，terminal报错
Watchman: watchman&amp;ndash;no-pretty get-sockname returned with exit code null dyld: Library not loaded: /usr/local/opt/pcre/lib/libpcre.1.dylib
 解决方案：终端输入 brew link pcre， 如果报错没有写入权限（Could not symlink lib/libpcre.1.dylib /usr/local/lib is not writable.） 则授权给该文件 sudo chown -R $(whoami) /usr/local/lib  </description>
    </item>
    
    <item>
      <title>正确的使用KVO</title>
      <link>https://blog.v5u.win/post/ios-kvo/</link>
      <pubDate>Tue, 15 Mar 2016 11:02:37 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/ios-kvo/</guid>
      <description>KVO，全称为Key-Value Observing，是iOS中的一种设计模式，用于检测对象的某些属性的实时变化情况并作出响应。网上广为流传普及的一个例子是利用KVO检测股票价格的变动，例如这里。这个例子作为扫盲入门还是可以的，但是当应用场景比较复杂时，里面的一些细节还是需要改进的，里面有多个地方存在crash的危险。本文旨在逐步递进深入地探讨出一种目前比较健壮稳定的KVO实现方案，弥补网上大部分教程的不足！
首先，假设我们的目标是在一个UITableViewController内对tableview的contentOffset进行实时监测，很容易地使用KVO来实现为。 在初始化方法中加入：
[_tableView addObserver:self forKeyPath:@&amp;quot;contentOffset&amp;quot; options:NSKeyValueObservingOptionNew context:nil]; `&amp;lt;/pre&amp;gt; 在dealloc中移除KVO监听： &amp;lt;pre&amp;gt;`[_tableView removeObserver:self forKeyPath:@&amp;quot;contentOffset&amp;quot; context:nil]; `&amp;lt;/pre&amp;gt; 添加默认的响应回调方法： &amp;lt;pre&amp;gt;`- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context { [self doSomethingWhenContentOffsetChanges]; } `&amp;lt;/pre&amp;gt; 好了，KVO实现就到此完美结束了，拜拜。。。开个玩笑，肯定没这么简单的，这样的代码太粗糙了，当你在controller中添加多个KVO时，所有的回调都是走同上述函数，那就必须对触发回调函数的来源进行判断。判断如下： &amp;lt;pre&amp;gt;`- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context { if (object == _tableView &amp;amp;amp;&amp;amp;amp; [keyPath isEqualToString:@&amp;quot;contentOffset&amp;quot;]) { [self doSomethingWhenContentOffsetChanges]; } } `&amp;lt;/pre&amp;gt; 你以为这样就结束了吗？答案是否定的！我们假设当前类(在例子中为UITableViewController)还有父类，并且父类也有自己绑定了一些其他KVO呢？我们看到，上述回调函数体中只有一个判断，如果这个if不成立，这次KVO事件的触发就会到此中断了。但事实上，若当前类无法捕捉到这个KVO，那很有可能是在他的superClass，或者super-superClass...中，上述处理砍断了这个链。合理的处理方式应该是这样的： &amp;lt;pre&amp;gt;`- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context { if (object == _tableView &amp;amp;amp;&amp;amp;amp; [keyPath isEqualToString:@&amp;quot;contentOffset&amp;quot;]) { [self doSomethingWhenContentOffsetChanges]; } else { [super observeValueForKeyPath:keyPath ofObject:object change:change context:context]; } }  这样就结束了吗？答案仍旧是否定的。潜在的问题有可能出现在dealloc中对KVO的注销上。KVO的一种缺陷(其实不能称为缺陷，应该称为特性)是，当对同一个keypath进行两次removeObserver时会导致程序crash，这种情况常常出现在父类有一个kvo，父类在dealloc中remove了一次，子类又remove了一次的情况下。不要以为这种情况很少出现！当你封装framework开源给别人用或者多人协作开发时是有可能出现的，而且这种crash很难发现。不知道你发现没，目前的代码中context字段都是nil，那能否利用该字段来标识出到底kvo是superClass注册的，还是self注册的？</description>
    </item>
    
    <item>
      <title>AFNetworking3.0/NSURLSession的优势</title>
      <link>https://blog.v5u.win/post/ios-afnetworking3.0-nsurlsession/</link>
      <pubDate>Tue, 15 Mar 2016 10:53:52 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/ios-afnetworking3.0-nsurlsession/</guid>
      <description>很多时候，AFNetworking都是目前iOS开发者网络库中的不二选择。Github上2W+的star数足见其流行程度。而从iOS7.0开始，苹果推出了新的网络库继承者NSURLSession后，AFNetworking也毫不犹豫地加入了对其的支持。3.0+更加只是提供了NSURLSession的支持。 我们使用AFNetworking的时候，可能会有很多的朋友都会采用以下的写法：
AFHTTPSessionManager *sessionManager = [AFHTTPSessionManager manager]; sessionManager.requestSerializer = [AFHTTPRequestSerializer serializer]; sessionManager.responseSerializer = [AFHTTPResponseSerializer serializer]; [sessionManager GET:urlString parameters:parameters progress:progressBlock success:successHandler failure:failureHandler];
大概可以描述一下这个过程，每次开启一个网络请求时，首先新建一个AFHTTPSessionManager，然后将相关的requestSerializer和reponseSerializer赋值；最后发起相应的GET/POST等请求。 而如果是直接采用NSURLSession来请求网络呢，我们则经常会采用以下的写法：
NSURLSession *session = [NSURLSession sessionWithConfiguration: [NSURLSessionConfiguration defaultSessionConfiguration] delegate:nil delegateQueue:[NSOperationQueue mainQueue]];
NSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request completionHandler:completionHandler];
[dataTask resume];
这个过程其实和上面的基本一致。新建一个Session，然后新建task，激活task，完成网络请求。 那么现在问题来了。为什么每次都需要新建一个SessionManager/Session？如果在多个Task请求的情况下，如果采取一个共享的SessionManager/Session是否可行？如果可行，与之前每次新建SessionManager/Session相比，孰优孰劣？
本篇文章会告诉您： 1. 为什么要使用NSURLSession而不是NSURLConnection 2. 为什么要用共享的SessionManager/Session，而不是每次都启动一个新的
为什么要选择NSURLSession NSURLSession在iOS7.0时被Apple提出后，虽然Apple一直对其良好的API设计大力推广，然而其能够达到的效果，似乎一直都和NSURLConnection不相伯仲。 特别是在网络的Dependecy依赖处理上，由于AFNetworking优秀的架构设计，NSURLSession甚至还不如NSURLConnection好用。那么，有什么理由切换到NSURLSession？ 2015年的WWDC似乎告诉了我们答案。 HTTP /2, 2015年5月RFC 7540正式发表的下一代HTTP协议，是1999年来HTTP 1.1发布后的首个更新。相对于前一个版本，HTTP /2以快著称。如下图，对相同图片、相同服务器的下载，在不同协议下所需的时间：
http2 这里我们并不打算展开HTTP /2的原理，有兴趣的同学可以Google之。根据2015的WWDC Session711，我们知道iOS9+，NSURLSession开始正式支持HTTP /2，也就意味着你的网络连接速度也可以有如上图那样的提升。 更人性化更优秀的API设计，HTTP /2的支持，这是否能成为你使用NSURLSession的理由？至少它们成为了说服我的理由。
为什么要尽量共享Session，而不是每次新建Session 在回答这个问题以前，我们先来聊聊网络的通讯协议。我们也都知道，HTTP协议是基于TCP协议的。所以在每次的HTTP请求之前，客户端和服务器端，都先需要经过TCP连接的三次握手，即每次请求之前，网络的数据都已经在客户端和服务器端之间来回了三次。如下图：
TCP三次握手（图片来源于网络) 事实上在HTTP 0.9, HTTP 1.</description>
    </item>
    
    <item>
      <title>简单实用UIImagePickerViewController</title>
      <link>https://blog.v5u.win/post/ios-uiimagepickerviewcontroller/</link>
      <pubDate>Wed, 09 Mar 2016 13:31:36 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/ios-uiimagepickerviewcontroller/</guid>
      <description>创建createVC
 UIImagePickerController* ipc = [[UIImagePickerController alloc] init]; ipc.sourceType = UIImagePickerControllerSourceTypePhotoLibrary; //图像来源 ipc.delegate = self; [self presentModalViewController:ipc animated:YES]; ```` 完善代理delegate方法 ```` //选择图片 //- (void)imagePickerController:(UIImagePickerController *)picker didFinishPickingImage:(UIImage *)image editingInfo:(NSDictionary *)editingInfo - (void)imagePickerController:(UIImagePickerController *)picker didFinishPickingMediaWithInfo:(NSDictionary *)info{ headView.image = [info objectForKey:@&amp;quot;UIImagePickerControllerOriginalImage&amp;quot;]; [picker dismissModalViewControllerAnimated:YES]; } //取消 - (void)imagePickerControllerDidCancel:(UIImagePickerController *)picker{ [picker dismissModalViewControllerAnimated:YES]; }  </description>
    </item>
    
    <item>
      <title>Xcode7 如何设置访问某些权限时的alert内容</title>
      <link>https://blog.v5u.win/post/xcode-xcode7-rightalert/</link>
      <pubDate>Mon, 07 Mar 2016 18:28:25 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/xcode-xcode7-rightalert/</guid>
      <description>举个栗子: 我想访问用户的照片，第一次时会弹出alert框询问用户是否将该权限开放给APP 这时为了增加用户友好度，我们有必要在询问的时候加一些解释和说明。 那么，如何添加呢？ 我们在info.plist文件里面设置 info.plist文件&amp;ndash;&amp;gt;添加字段Privacy - Photo Library Usage Description&amp;ndash;&amp;gt;填写说明文字</description>
    </item>
    
    <item>
      <title>UIView何时创建加载subview比较合适？</title>
      <link>https://blog.v5u.win/post/ios-uiview-subview/</link>
      <pubDate>Mon, 07 Mar 2016 15:38:43 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/ios-uiview-subview/</guid>
      <description>当我们使用ViewController的时候有ViewDidLoad方法保证数据或UI只加载一次 但是在UIView中 没有这样的生命周期函数 如果你的subview的创建是这样写的
- (instancetype)initWithFrame:(CGRect)frame { self = [super initWithFrame:frame]; if (self) { [self makeView]; } return self; }  那么恭喜你 你的代码很可能会出问题 因为我发现 initWithFrame会调用两次，不要问我为什么，我也不知道 所以应该在哪里创建呢？ 这时我想起来了tableView的delegate方法，是一组按顺序执行的接口方法，啊哈，这是个很好的解决方案。 我们可以对外暴露一个方法， 当View初始化完成之后 在调用创建subview的方法 想在那里执行就在那里执行，想什么时候创建就什么时候创建</description>
    </item>
    
    <item>
      <title>Xcode7如何给新建的类名自动添加前缀</title>
      <link>https://blog.v5u.win/post/xcode-xcode7-prefix/</link>
      <pubDate>Thu, 03 Mar 2016 15:03:01 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/xcode-xcode7-prefix/</guid>
      <description>Xcode7如何给新建的类名自动添加前缀 一直想给新创建类的时候自动添加前缀比如这样:FFObject Xcode5之前是可以在项目刚创建的时候填写的 Class Prefix Xcode6之后默认没有了，那么在哪里能找到去添加呢，在这里： - Project&amp;ndash;&amp;gt;Target&amp;ndash;&amp;gt;Class Prefix -</description>
    </item>
    
    <item>
      <title>Xcode注释</title>
      <link>https://blog.v5u.win/post/xcode-notes/</link>
      <pubDate>Wed, 02 Mar 2016 15:49:43 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/xcode-notes/</guid>
      <description>Xcode注释 在所有的编程环境中 有几种通用的注释方式我们默认遵守他们的规则 它们是：TODO, FIXME, XXX, ??? , !!!
 它们分别代表什么意思？   TODO: + 说明： 说明在标识处有功能代码待编写，待实现的功能在说明中会简略说明。 对那些临时的, 短期的解决方案, 或已经够好但仍不完美的代码使用 TODO 注释.
FIXME: + 说明： 说明标识处代码需要修正，甚至代码是错误的，不能工作，需要修复，如何修正会在说明中简略说明。
XXX: + 说明： 说明标识处代码虽然实现了功能，但是实现的方法有待商榷，希望将来能改进，要改进的地方会在说明中简略说明。
  关于用法 TODO 注释要使用全大写的字符串 TODO, 在随后的圆括号里写上你的大名, 邮件地址, 或其它身份标识. 冒号是可选的. 主要目的是让添加注释的人 (也是可以请求提供更多细节的人) 可根据规范的 TODO 格式进行查找. 添加 TODO 注释并不意味着你要自己来修正.  // TODO(kl@gmail.com): Use a &amp;ldquo;*&amp;rdquo; here for concatenation operator. // TODO(Zeke) change this to use relations. 如果加 TODO 是为了在 “将来某一天做某事”, 可以附上一个非常明确的时间 “Fix by November 2005”), 或者一个明确的事项 (“Remove this code when all clients can handle XML responses.</description>
    </item>
    
    <item>
      <title>braced block of statements is an unused closure</title>
      <link>https://blog.v5u.win/post/swift-braced-block-of-statements-is-an-unused-closure/</link>
      <pubDate>Tue, 01 Mar 2016 15:31:45 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/swift-braced-block-of-statements-is-an-unused-closure/</guid>
      <description>使用swift写dome时xcode报一下错误： braced block of statements is an unused closure
原因及收获： for循环的条件语句不能有空格，如：for i=0; i&amp;lt;3; i++ {} 其他控制语句也一样不能有空格</description>
    </item>
    
    <item>
      <title>swift中的打印</title>
      <link>https://blog.v5u.win/post/swift-print/</link>
      <pubDate>Fri, 26 Feb 2016 14:57:35 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/swift-print/</guid>
      <description> 自从swift2.0后 println 合并到了print，默认print()方法换行 如果不想换行可以使用，print(&amp;ldquo;print line&amp;rdquo;,terminator:&amp;ldquo;n&amp;rdquo;)
 </description>
    </item>
    
    <item>
      <title>SSH</title>
      <link>https://blog.v5u.win/post/mac-ssh/</link>
      <pubDate>Wed, 24 Feb 2016 16:02:58 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/mac-ssh/</guid>
      <description>[TOC]
解释 Secure Shell（安全外壳协议，简称SSH）是一种加密的网络传输协议，可在不安全的网络中为网络服务提供安全的传输环境[1]。 SSH通过在网络中创建安全隧道来实现SSH客户端与服务器之间的连接[2]。 虽然任何网络服务都可以通过SSH实现安全传输，SSH最常见的用途是远程登录系统，人们通常利用SSH来传输命令行界面和远程执行命令。 使用频率最高的场合类Unix系统，但是Windows操作系统也能有限度地使用SSH。2015年，微软宣布将在未来的操作系统中提供原生SSH协议支持(摘自wikipedia)  生成 下面是Mac生成方法：
1 ：打开终端 输入 ssh-keygen
然后系统提示输入文件保存位置等信息，连续敲三次回车即可，生成的SSH key文件保存在中～/.ssh/id_rsa.pub
2 然后用文本编辑工具打开该文件，我用的是vim,所以命令是： vim ~/.ssh/id_rsa.pub`
禁忌 同一个网站，多个账户之间 不能共用同一个ssh公钥，这会造成服务器无法判断提交者的身份，所以如果有多个账户在同一个网站的话，还是创建多个ssh证书分别管理比较好。
多证书管理 生成 指定文件名
`ssh-keygen -t rsa -f ~/.ssh/id_rsa.name -C &amp;ldquo;ssh_name&amp;rdquo;
创建配置文件
vi ~/.ssh/config
Host aaa.github.com HostName git@github.com:aaa IdentityFile ~/.ssh/id_rsa.aaa User git HostName bbb@github.com IdentityFile ~/.ssh/id_rsa User git  检测是否配置成功
//查看当前rsa list ssh-add -l //如果列表中没有新增的rsa， 添加identifile 把专用密钥添加到 ssh-agent 的高速缓存中： ssh-add ~/.ssh/test_id_rsa  注： ssh-add 命令是把专用密钥添加到ssh-agent的高速缓存中。是把指定的私钥添加到 ssh-agent 所管理的一个 session 当中。而 ssh-agent 是一个用于存储私钥的临时性的 session 服务，重启之后，ssh-agent 服务也就重置了，session 会话也就失效了。</description>
    </item>
    
    <item>
      <title>资深程序员是如何用五年时间攒够100万的--阅后总结</title>
      <link>https://blog.v5u.win/post/life-%E8%B5%84%E6%B7%B1%E7%A8%8B%E5%BA%8F%E5%91%98%E6%98%AF%E5%A6%82%E4%BD%95%E7%94%A8%E4%BA%94%E5%B9%B4%E6%97%B6%E9%97%B4%E6%94%92%E5%A4%9F100%E4%B8%87%E7%9A%84-%E9%98%85%E5%90%8E%E6%80%BB%E7%BB%93/</link>
      <pubDate>Wed, 24 Feb 2016 15:37:17 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/life-%E8%B5%84%E6%B7%B1%E7%A8%8B%E5%BA%8F%E5%91%98%E6%98%AF%E5%A6%82%E4%BD%95%E7%94%A8%E4%BA%94%E5%B9%B4%E6%97%B6%E9%97%B4%E6%94%92%E5%A4%9F100%E4%B8%87%E7%9A%84-%E9%98%85%E5%90%8E%E6%80%BB%E7%BB%93/</guid>
      <description> 资深程序员是如何用五年时间攒够100万的&amp;ndash;阅后总结  做好职业规划，先选职位，再选行业，最后是公司   内省：职业已选 iOS开发，行业未选 目标：金融或医疗，公司看机遇
注意：聚焦 坚定 不被周围的人影响
  |积累人脉|寻找机会|发掘其他赚钱途径| &amp;gt; |待加强 |在寻找 |兼职 | 理财可出风险资本数：1-年龄28/100 = 72%; &amp;gt; 理财方向：一线城市房产抵押标的，互联网金融， 保险理财业务，货币基金 养成记账习惯 APP推荐：随手记， 财智 &amp;gt; 目的：知晓每天/月 开销 重点是——分析，找出不必要的开销，合理配比资金 合理用钱，消费分为：投资性消费和一般性消费 &amp;gt; 投资性消费包括：教育消费，健康消费，理财消费，衣物消费（投资自己） &amp;gt; 一般性消费要注意性价比，通常情况下，昂贵优质的商品是最好的选择 找一个好老婆，价值不可估量。  </description>
    </item>
    
    <item>
      <title>OC Quartz2D 绘图</title>
      <link>https://blog.v5u.win/post/ios-oc-quartz2d/</link>
      <pubDate>Tue, 23 Feb 2016 12:07:20 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/ios-oc-quartz2d/</guid>
      <description>如何利用Quartz2D绘制东西到view上?
首先,得有图形上下文,因为它能保存绘图信息,并且决定着绘制到什么地方去
其次,那个图形上下⽂必须跟view相关联,才能将内容绘制到view上面
⾃定义view的步骤:
(1)新建⼀个类,继承自UIView
(2)实现-(void)drawRect:(CGRect)rect⽅法.然后在这个⽅方法中 :
1)取得跟当前view相关联的图形上下文;
2)绘制相应的图形内容
3)利用图形上下文将绘制的所有内容渲染显示到view上面
1.drawRect:
（1）为什么要实现drawRect:⽅法才能绘图到view上?
因为在drawRect:⽅法中才能取得跟view相关联的图形上下文
（2）drawRect:⽅法在什么时候被调用?
当view第一次显示到屏幕上时(被加到UIWindow上显示出来)
调用view的setNeedsDisplay或者setNeedsDisplayInRect:时</description>
    </item>
    
    <item>
      <title>iOS创建.a静态库文件</title>
      <link>https://blog.v5u.win/post/ios-a-library/</link>
      <pubDate>Mon, 22 Feb 2016 16:01:04 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/ios-a-library/</guid>
      <description>步骤：
1.创建项目（选择Framework&amp;amp;Library）
2.删除无用文件，加入希望编译的文件
3.edit scheme &amp;ndash;&amp;gt;release
4.编译真机平台文件：选择ios device
5.编译模拟器平台文件：选择一个模拟器，run运行程序
6.找到编译后的.a文件：选中项目中的.a文件，show in finder
7.将两个文件合并成一个文件：lipo -create 文件路径1 文件路径2 -output 路径3</description>
    </item>
    
    <item>
      <title>iOS 各类作用</title>
      <link>https://blog.v5u.win/post/ios-classes/</link>
      <pubDate>Tue, 16 Feb 2016 16:23:17 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/ios-classes/</guid>
      <description>UIMenuController &amp;mdash;&amp;ndash;定制剪切，复制，粘贴组件。
UILabel &amp;mdash;&amp;mdash;&amp;ndash;文本显示
UIButton &amp;mdash;&amp;mdash;&amp;mdash;按钮
&amp;nbsp;</description>
    </item>
    
    <item>
      <title>国内三大免费空间提供商各自的特点</title>
      <link>https://blog.v5u.win/post/business-%E5%9B%BD%E5%86%85%E4%B8%89%E5%A4%A7%E5%85%8D%E8%B4%B9%E7%A9%BA%E9%97%B4%E6%8F%90%E4%BE%9B%E5%95%86%E5%90%84%E8%87%AA%E7%9A%84%E7%89%B9%E7%82%B9/</link>
      <pubDate>Mon, 15 Feb 2016 11:51:02 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/business-%E5%9B%BD%E5%86%85%E4%B8%89%E5%A4%A7%E5%85%8D%E8%B4%B9%E7%A9%BA%E9%97%B4%E6%8F%90%E4%BE%9B%E5%95%86%E5%90%84%E8%87%AA%E7%9A%84%E7%89%B9%E7%82%B9/</guid>
      <description> 主机屋：
特点：主要面向国内市场
 主机屋是北京爱迪通联科技有限公司旗下网络服务品牌，是中国领先的互联网服务提供 商。公司致力于为大众提供最优质的互联网基础服务，包括：域名注册、虚拟主机、云服务 器、企业邮箱、主机租用、主机托管、CDN网站加速、智能建站等服务。 以帮助客户轻松、 高速、高效的应用互联网，提高企业竞争能力。 主机屋一直秉承&amp;rdquo;以人为本、客户为尊、永续创新&amp;rdquo;的价值观，坚持&amp;rdquo;以微笑收获友善， 以尊重收获理解，以责任收获支持，以谦卑收获成长&amp;rdquo;的行为观向客户提供全面优质的互联网应用服务。 主机屋是国内最大的免费虚拟主机提供商，已经为数以百万计的网民提供了优质的免费服务，并且服务质量持续提升。凭借雄厚的研发实力和坚实的行业经验积累，自主研发了数据中心云计算综合管理平台。其中包括“虚拟主机管理系统、云服务器管理系统、域名动态解析系统、CDN分布式转发系统、光纤架构分布式存储系统、工信部备案管理系统、黑洞封堵清洗系统等”。 主机屋为了给客户提供更高级别的稳定服务，在北京建立了完全自主产权的数据中心，采用多线BGP接入中国电信、中国联通、中国移动等服务商，为客户提供优质稳定的网络资源与机房服务，完美解决南北互联互通问题。 主机屋自创立以来，累计超过5，000，000个网站通过主机屋的数据中心平台上运行； 星空云：  特点：主要提供免费美国空间
星空云是由国人创立的主机供应商。主要提供免费美国空间，其用户增长迅速。
&amp;nbsp;
Hostinger：
Hostinger是一家国外公司。一个独特的工作方式,因为所有人都可以在家里舒适地工作。他们位于许多不同国家和时区,所以可以确保你的网站可以每天24小时得到支持与帮助
Hostinger是不同的，提供可靠和功能丰富的主机与热心的用户支持!基于云计算技术的服务在线时间超过99.9%。
免费空间：   2000MB的网站存储空间  100GB（100000MB）的流量  绑定无限个域名  基于cPanel的主机面板  无强制广告  简单易用的建站助手  自动安装器(Joomla, Wordpress, etc.)  E-mail服务(IMAP/POP3/在线邮局)  支持PHP和MySQL数据库  即时帐号激活    </description>
    </item>
    
    <item>
      <title>日课 丙申年庚寅月丙寅日20160214</title>
      <link>https://blog.v5u.win/post/system-%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E5%8E%9F%E5%88%99/</link>
      <pubDate>Sun, 14 Feb 2016 12:03:13 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/system-%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E5%8E%9F%E5%88%99/</guid>
      <description>软件开发过程当中，需要传递数据作为参数，很多时候我们需要的数据是要经过处理的，这时作为参数传递的部分尽量传递源数据，数据处理放在数据接收之后，因为有时可能我们需要的数据现在不用，以后又用了，所以不要过早的对数据进行处理，数据应该是在用的时候再进行处理。</description>
    </item>
    
    <item>
      <title>ios copy 和 mutableCopy</title>
      <link>https://blog.v5u.win/post/ios-copymutablecopy/</link>
      <pubDate>Mon, 18 Jan 2016 19:39:17 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/ios-copymutablecopy/</guid>
      <description>通过copy方法可以创建可变对象或不可变对象的不可变副本，对于不可变副本，其对象的值不可以改变。
通过mutableCopy方法可以创建可变对象或不可变对象的可变副本，对于可变副本其对象是可变的。
当我们要给一个copy一个对象的时候，经常需要使用copy方法，可是copy有两种方法：</description>
    </item>
    
    <item>
      <title>NSString 位数不足补0</title>
      <link>https://blog.v5u.win/post/ios-nsstring-add-0/</link>
      <pubDate>Fri, 15 Jan 2016 16:22:44 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/ios-nsstring-add-0/</guid>
      <description>%0nd ，n是多少位。0表示补0
如果是%nd，就是不满n位，自动补充空格。 NSString* testStr;
intf = 12;
testStr = [NSString stringWithFormat:@&amp;ldquo;%03d&amp;rdquo;,f];
NSLog(@&amp;ldquo;%@&amp;rdquo;,testStr);</description>
    </item>
    
    <item>
      <title>如何改变xcode 源文件的目录位置</title>
      <link>https://blog.v5u.win/post/xcode-%E5%A6%82%E4%BD%95%E6%94%B9%E5%8F%98xcode-%E6%BA%90%E6%96%87%E4%BB%B6%E7%9A%84%E7%9B%AE%E5%BD%95%E4%BD%8D%E7%BD%AE/</link>
      <pubDate>Mon, 11 Jan 2016 11:10:16 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/xcode-%E5%A6%82%E4%BD%95%E6%94%B9%E5%8F%98xcode-%E6%BA%90%E6%96%87%E4%BB%B6%E7%9A%84%E7%9B%AE%E5%BD%95%E4%BD%8D%E7%BD%AE/</guid>
      <description>很多时候会遇到这样的问题，项目中的文件，需要改变目录路径，但是呢，如果仅仅是将本地的文件移到目标目录下，重新编译项目会发现有很多的warnning警告，看着极不舒服，本着优雅的原则，怎么移动文件才是正确的移动方式，不会产生警告呢，那么我(fans)总结的方法如下:
xcode 源文件移动方式:
1.复制源文件
2.从Xcode删除文件，到垃圾桶
3.将文件重新添加到项目当中</description>
    </item>
    
    <item>
      <title>孔曰成仁，孟曰取义出处</title>
      <link>https://blog.v5u.win/post/life-%E5%AD%94%E6%9B%B0%E6%88%90%E4%BB%81%E5%AD%9F%E6%9B%B0%E5%8F%96%E4%B9%89%E5%87%BA%E5%A4%84/</link>
      <pubDate>Wed, 23 Dec 2015 12:15:29 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/life-%E5%AD%94%E6%9B%B0%E6%88%90%E4%BB%81%E5%AD%9F%E6%9B%B0%E5%8F%96%E4%B9%89%E5%87%BA%E5%A4%84/</guid>
      <description>文天祥就义前的绝笔中写道：
“孔曰成仁，孟曰取义，唯其义尽，所以仁至。读圣贤书，所学何事？而今而后，庶几无愧。”</description>
    </item>
    
    <item>
      <title>儒道至圣</title>
      <link>https://blog.v5u.win/post/read-%E5%84%92%E9%81%93%E8%87%B3%E5%9C%A3/</link>
      <pubDate>Mon, 21 Dec 2015 15:19:40 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/read-%E5%84%92%E9%81%93%E8%87%B3%E5%9C%A3/</guid>
      <description>该书文笔很好，构思巧妙，值得一读。
以下为该书简介：
这是一个读书人掌握天地之力的世界。 才气在身，诗可杀敌，词能灭军，文章安天下。 秀才提笔，纸上谈兵；举人杀敌，出口成章；进士一怒，唇枪舌剑。 圣人驾临，口诛笔伐，可诛人，可判天子无道，以一敌国。 此时，圣院把持文位，国君掌官位，十国相争，蛮族虎视，群妖作乱。 此时，无唐诗大兴，无宋词鼎盛，无创新文章，百年无新圣。 一个默默无闻的寒门子弟，被人砸破头后，挟传世诗词，书惊圣文章，踏上至圣之路。 。。。</description>
    </item>
    
    <item>
      <title>mac 文件如何校验</title>
      <link>https://blog.v5u.win/post/mac-file-check/</link>
      <pubDate>Thu, 17 Dec 2015 11:08:37 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/mac-file-check/</guid>
      <description>mac 自带文件校验工具，已经内置在终端(Terminal)下了
输入md5 空格后面加上要校验的文件路径（将文件拖到Terminal窗口就行）回车
或
输入shasum 后面加上文件路径 回车皆可得到一串校验码</description>
    </item>
    
    <item>
      <title>计算中国农历</title>
      <link>https://blog.v5u.win/post/system-%E8%AE%A1%E7%AE%97%E5%86%9C%E5%8E%86/</link>
      <pubDate>Sun, 13 Dec 2015 15:14:46 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/system-%E8%AE%A1%E7%AE%97%E5%86%9C%E5%8E%86/</guid>
      <description>文章请查看：http://blog.csdn.net/orbit/article/details/9210413</description>
    </item>
    
    <item>
      <title>iOS键盘高度的官方获取方法</title>
      <link>https://blog.v5u.win/post/ios-keyboard-height/</link>
      <pubDate>Wed, 02 Dec 2015 14:54:36 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/ios-keyboard-height/</guid>
      <description>处理键盘事件的正确方法是这样的：（包括获取键盘的高度以及键盘弹出和消失动画的时间）
1）在要使用键盘的视图控制器中，接收键盘事件的通知：  [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(keyboardWillShow:) name:UIKeyboardWillShowNotification object:nil]; [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(keyboardWillHide:) name:UIKeyboardWillHideNotification object:nil];` ` // 键盘高度变化通知，ios5.0新增的 #ifdef __IPHONE_5_0 float version = [[[UIDevice currentDevice] systemVersion] floatValue]; if (version &amp;amp;gt;= 5.0) { [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(keyboardWillShow:) name:UIKeyboardWillChangeFrameNotification object:nil]; } #endif`&amp;lt;/pre&amp;gt; &amp;lt;div class=&amp;quot;cnblogs_code_toolbar&amp;quot;&amp;gt;&amp;lt;span class=&amp;quot;cnblogs_code_copy&amp;quot;&amp;gt;&amp;lt;a title=&amp;quot;复制代码&amp;quot;&amp;gt;　2）然后添加键盘事件的处理代码：&amp;lt;/a&amp;gt;&amp;lt;/span&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; 获取到当前keyboard的高度以及动画时间，然后对视图进行对应的操作即可。 &amp;lt;div class=&amp;quot;cnblogs_code&amp;quot;&amp;gt; &amp;lt;div class=&amp;quot;cnblogs_code_toolbar&amp;quot;&amp;gt; &amp;lt;pre&amp;gt;`#pragma mark - #pragma mark Responding to keyboard events - (void)keyboardWillShow:(NSNotification *)notification { /* Reduce the size of the text view so that it&#39;s not obscured by the keyboard.</description>
    </item>
    
    <item>
      <title>大神F1刷机失败怎么办？</title>
      <link>https://blog.v5u.win/post/life-%E5%A4%A7%E7%A5%9Ef1%E5%88%B7%E6%9C%BA%E5%A4%B1%E8%B4%A5%E6%80%8E%E4%B9%88%E5%8A%9E/</link>
      <pubDate>Sun, 29 Nov 2015 11:06:23 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/life-%E5%A4%A7%E7%A5%9Ef1%E5%88%B7%E6%9C%BA%E5%A4%B1%E8%B4%A5%E6%80%8E%E4%B9%88%E5%8A%9E/</guid>
      <description>刷机失败，需要进入Recovery模式才可以再次刷机
那么如何如何进入Recovery模式呢？
大神手机：
关机，同时按住音量+键和电源键
进入Recovery模式，
此时界面显示命令行，音量键上下选择，需要使用的模式，（此时可以连接刷机软件，如刷机精灵等）
此时可以再次刷入其他rom包</description>
    </item>
    
    <item>
      <title>Xcode7.1.1更新内容</title>
      <link>https://blog.v5u.win/post/xcode-xcode7.1.1-update-content/</link>
      <pubDate>Mon, 23 Nov 2015 11:25:15 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/xcode-xcode7.1.1-update-content/</guid>
      <description>Xcode 7.1.1 improves stability and fixes critical issues in interface Builder,debugging,and UI testing. Xcode 7.1 includes Swift2.1 and SDKs for iOS 9.1,watchOS 2,tvOS,and OS X 10.11 EI Capitan.
Now you can go beyond the simulator to test your app on an iPad, iPhone, Apple TV, or Apple Watch - for free. Simply enter your Apple ID into the Accounts preference pane,then attach a device to your Mac using a Lightning cable.</description>
    </item>
    
    <item>
      <title>2015年，mac OS 10.11上cocoapods 加载失败</title>
      <link>https://blog.v5u.win/post/ios-2cocoapods_load_error/</link>
      <pubDate>Thu, 12 Nov 2015 15:33:43 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/ios-2cocoapods_load_error/</guid>
      <description>原来http淘宝源已经弃用更换成https了：
https://ruby.taobao.org/
修改gem的链接地址
mac OS 10.11 cocoapods安装请使用此命令sudo gem install -n /usr/local/bin cocoapods</description>
    </item>
    
    <item>
      <title>SEL如何保存到NSArray数组中</title>
      <link>https://blog.v5u.win/post/ios-selnsarray/</link>
      <pubDate>Wed, 04 Nov 2015 11:09:43 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/ios-selnsarray/</guid>
      <description>首先，SEL是不可以保存到array数组中去的。
其次，SEL有两种创建方法： SEL&amp;nbsp;s1&amp;nbsp;=&amp;nbsp;&amp;nbsp;@selector&amp;nbsp;(test1);&amp;nbsp;&amp;nbsp;&amp;nbsp;//&amp;nbsp;将test1方法转换为NSString对象 SEL&amp;nbsp;s2&amp;nbsp;=&amp;nbsp;NSSelectorFromString&amp;nbsp;(&amp;nbsp;@&amp;quot;test1&amp;quot;&amp;nbsp;);&amp;nbsp;&amp;nbsp;&amp;nbsp;//&amp;nbsp;将一个字符串&amp;nbsp;&amp;nbsp;方法&amp;nbsp;转换成为SEL对象
NSArray无法保存SEL，但是可以保存NSString。
所以我们利用第二种创建方法，讲SEL的方法名以字符串的方式保存到NSArray数组中即可。
举个栗子： NSArray&amp;nbsp;&amp;nbsp;selArr&amp;nbsp;=&amp;nbsp;@[@&amp;quot;gotoSelectCity&amp;quot;,&amp;nbsp;@&amp;quot;gotoSelectTitle&amp;quot;]; UITapGestureRecognizer&amp;nbsp;&amp;nbsp;rightLabelGest&amp;nbsp;=&amp;nbsp;[[UITapGestureRecognizer&amp;nbsp;alloc]initWithTarget:self&amp;nbsp;action:NSSelectorFromString(selArr[i])];</description>
    </item>
    
    <item>
      <title>HTML&amp;CSS</title>
      <link>https://blog.v5u.win/post/web-html-css/</link>
      <pubDate>Sun, 25 Oct 2015 17:48:49 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/web-html-css/</guid>
      <description>&amp;lt;p&amp;gt; paragragh 段落
&amp;lt;em&amp;gt; emphasize 强调(显示为斜体)
&amp;lt;span&amp;gt; 样式
&amp;lt;q&amp;gt; quote [kwot] 引用，引号(显示默认添加双引号，故不用再次添加“ ”)
&amp;lt;blockquote&amp;gt; 引用块 ，长文本引用(显示默认为缩进，左右都缩进)
&amp;lt;br /&amp;gt; break 换行 &amp;amp;nbsp; 空格占位符
&amp;lt;hr /&amp;gt; horizontal rule 水平分割线
&amp;lt;address&amp;gt; 地址标签(默认显示为斜体)
&amp;lt;code&amp;gt; 一行代码
&amp;lt;pre&amp;gt; predefined 预定义，多行代码,预格式化的文本。被包围在 pre 元素中的文本通常会保留空格和换行符。而文本也会呈现为等宽字体.
&amp;lt;ul&amp;gt; unordered list 定义无序列表 (前方显示一个小圆点)
&amp;lt;li&amp;gt; list 列表
&amp;lt;ol&amp;gt; orderly list 定义有序列表 (前方显示123等数字)
创建表格的四个元素：table、tbody、tr、th、td
&amp;lt;tbody&amp;gt; table body 表格体
&amp;lt;tr&amp;gt; table row 表格，行
&amp;lt;td&amp;gt; table data 表格数据
&amp;lt;th&amp;gt; table head 表格头
&amp;lt;caption&amp;gt; 表格标题
&amp;lt;table summary=&amp;quot;表格简介文本&amp;quot;&amp;gt;</description>
    </item>
    
    <item>
      <title>Xcode 删除 Provisioning profile 证书</title>
      <link>https://blog.v5u.win/post/xcode-provisioning-profile/</link>
      <pubDate>Sat, 24 Oct 2015 20:09:12 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/xcode-provisioning-profile/</guid>
      <description>xcode 删除 Provisioning profile
证书存放路径：/Users/fans/Library/MobileDevice/Provisioning Profiles
&amp;nbsp;</description>
    </item>
    
    <item>
      <title>ViewController 界面的推出调用时间</title>
      <link>https://blog.v5u.win/post/ios-viewcontroller-push-time/</link>
      <pubDate>Tue, 13 Oct 2015 10:22:27 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/ios-viewcontroller-push-time/</guid>
      <description>ViewController 界面的推出，是在ViewDidLoad方法运行之后才被推出的，
所以说，ViewWillAppear和ViewDidAppear 是在ViewDidLoad之后调用的。</description>
    </item>
    
    <item>
      <title>.gitignore文件使用说明</title>
      <link>https://blog.v5u.win/post/system-git-gitignore/</link>
      <pubDate>Fri, 09 Oct 2015 13:25:58 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/system-git-gitignore/</guid>
      <description>一般我们总会有些文件无需纳入 Git 的管理，也不希望它们总出现在未跟踪文件列表。通常都是些自动生成的文件，像是日志或者编译过程中创建的等等。我们可以创建一个名为&amp;nbsp;.gitignore&amp;nbsp;的文件，列出要忽略的文件模式，来看一个简单的例子： $&amp;nbsp;cat&amp;nbsp;.gitignore&amp;nbsp;.[oa]&amp;nbsp;~
第一行告诉 Git 忽略所有以 .o 或 .a 结尾的文件。一般这类对象文件和存档文件都是编译过程中出现的，我们用不着跟踪它们的版本。第二行告诉 Git 忽略所有以波浪符（~）结尾的文件，许多文本编辑软件（比如 Emacs）都用这样的文件名保存副本。此外，你可能还需要忽略 log，tmp 或者 pid 目录，以及自动生成的文档等等。要养成一开始就设置好&amp;nbsp;.gitignore&amp;nbsp;文件的习惯，以免将来误提交这类无用的文件。
文件&amp;nbsp;.gitignore&amp;nbsp;的格式规范如下：
 所有空行或者以注释符号 ＃ 开头的行都会被 Git 忽略。
 可以使用标准的 glob 模式匹配。
 匹配模式最后跟反斜杠（/）说明要忽略的是目录。
 要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（!）取反。
  所谓的 glob 模式是指 shell 所使用的简化了的正则表达式。星号（*）匹配零个或多个任意字符；[abc] 匹配任何一个列在方括号中的字符（这个例子要么匹配一个 a，要么匹配一个 b，要么匹配一个 c）；问号（?）只匹配一个任意字符；如果在方括号中使用短划线分隔两个字符，表示所有在这两个字符范围内的都可以匹配（比如 [0-9] 表示匹配所有 0 到 9 的数字）。
我们再看一个&amp;nbsp;.gitignore&amp;nbsp;文件的例子： #&amp;nbsp;此为注释&amp;nbsp;–&amp;nbsp;将被&amp;nbsp;Git&amp;nbsp;忽略&amp;nbsp; .a&amp;nbsp;#&amp;nbsp;忽略所有&amp;nbsp;.a&amp;nbsp;结尾的文件&amp;nbsp; !lib.a&amp;nbsp;#&amp;nbsp;但&amp;nbsp;lib.a&amp;nbsp;除外&amp;nbsp; /TODO&amp;nbsp;#&amp;nbsp;仅仅忽略项目根目录下的&amp;nbsp;TODO&amp;nbsp;文件，不包括&amp;nbsp;subdir/TODO&amp;nbsp; build/&amp;nbsp;#&amp;nbsp;忽略&amp;nbsp;build/&amp;nbsp;目录下的所有文件&amp;nbsp; doc/.txt&amp;nbsp;#&amp;nbsp;会忽略&amp;nbsp;doc/notes.txt&amp;nbsp;但不包括&amp;nbsp;doc/server/arch.txt</description>
    </item>
    
    <item>
      <title>用 Xcode 编写 C/C&#43;&#43; 的 Hello World！</title>
      <link>https://blog.v5u.win/post/xcode-cc&#43;&#43;/</link>
      <pubDate>Fri, 25 Sep 2015 12:24:51 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/xcode-cc&#43;&#43;/</guid>
      <description>操作步骤：
 打开Xcode，在欢迎界面点击Create a new Xcode project。
 在左侧栏选择Mac OS X分类的Application，右侧选择Command Line Tool(命令行程序)，点击Next。
 在Product Name填写项目名称，如HelloMac，其余默认即可（type里也可以选择C或C++），点击Next后选择路径并点击Create完成项目创建。
 在Xcode主界面左侧点击main.m，把代码替换成C/C++的代码，点击左上角的Run按钮即可编译运行，界面下方会弹出控制台显示运行结果。
  </description>
    </item>
    
    <item>
      <title>Cannot find interface declaration for &#39;ClassA&#39;, superclass of &#39;ClassB&#39;</title>
      <link>https://blog.v5u.win/post/ios-cannot-find-interface-declaration-for-classa-superclass-of-classb/</link>
      <pubDate>Tue, 22 Sep 2015 11:49:57 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/ios-cannot-find-interface-declaration-for-classa-superclass-of-classb/</guid>
      <description>这个error 是由于 头文件循环引用的原因，导致的。
只要删除其中一个class的头文件中的＃import引用，就会解决这个问题</description>
    </item>
    
    <item>
      <title>宏定义</title>
      <link>https://blog.v5u.win/post/system-%E5%AE%8F%E5%AE%9A%E4%B9%89/</link>
      <pubDate>Fri, 18 Sep 2015 15:50:23 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/system-%E5%AE%8F%E5%AE%9A%E4%B9%89/</guid>
      <description>#define DLOG( s, &amp;hellip; ) NSLog(@&amp;quot;&amp;lt; %@: (%d) &amp;gt; %@&amp;quot;,[[NSString stringWithUTF8String:FILE] lastPathComponent], LINE, [NSString stringWithFormat:(s), ##VA_ARGS])
这个宏定义是用来在打印log的时候，调试使用，可以显示当前log所在的controller名字。
先写出来，原理以后查看了再来补，</description>
    </item>
    
    <item>
      <title>Objective-c NSClassFromString 使用方法</title>
      <link>https://blog.v5u.win/post/ios-oc-nsclassfromstring/</link>
      <pubDate>Mon, 14 Sep 2015 11:58:58 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/ios-oc-nsclassfromstring/</guid>
      <description>NSClassFromString 是一个很有用的东西，尤其在进行 iPhone toolchain 的开发上。
正常来说， id&amp;nbsp;myObj&amp;nbsp;=&amp;nbsp;[[NSClassFromString(@&amp;quot;MySpecialClass&amp;quot;)&amp;nbsp;alloc]&amp;nbsp;init];
和 id&amp;nbsp;myObj&amp;nbsp;=&amp;nbsp;[[MySpecialClass&amp;nbsp;alloc]&amp;nbsp;init];
是一样的。但是，如果你的程序中并不存在 MySpecialClass 这个类，下面的写法会出错，而上面的写法只是返回一个空对象而已。
因此，在某些情况下，可以使用&amp;nbsp;NSClassFromString&amp;nbsp;来进行你不确定的类的初始化。
比如在 iPhone 中，NSTask 可能就会出现这种情况，所以在你需要使用 NSTask 时，最好使用： [[NSClassFromString(@&amp;quot;NSTask&amp;quot;)&amp;nbsp;&amp;hellip;..]]
而不要直接使用&amp;nbsp;[NSTask ...]&amp;nbsp;这种写法。
NSClassFromString 的好处是：
 弱化连接，因此并不会把没有的 Framework 也 link 到程序中。
 不需要使用 import，因为类是动态加载的，只要存在就可以加载。因此如果你的 toolchain 中没有某个类的头文件定义，而你确信这个类是可以用的，那么也可以用这种方法
  Posted by&amp;nbsp;陈斌彬&amp;nbsp;Jul&amp;nbsp;2nd,&amp;nbsp;2015&amp;nbsp;9:30 am&amp;nbsp;&amp;nbsp;[objective-c](http://cnbin.github.io/blog/categories/objective-c/)  </description>
    </item>
    
    <item>
      <title>app 上架前的打包准备</title>
      <link>https://blog.v5u.win/post/ios-appstore_public_archive/</link>
      <pubDate>Thu, 10 Sep 2015 15:22:12 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/ios-appstore_public_archive/</guid>
      <description>app 上架前的打包准备
1.检查是否是外网环境
2.更新info.plist文件版本号
3.product&amp;mdash;&amp;gt;scheme&amp;mdash;-&amp;gt;eidt scheme&amp;mdash;&amp;gt;
&amp;nbsp;&amp;nbsp; build configuration 改为 release
4.build setting&amp;mdash;&amp;gt;architectures &amp;ndash;&amp;gt;&amp;nbsp;
&amp;nbsp;&amp;nbsp; build active architecture only 设置为NO
5.build setting&amp;mdash;&amp;gt; code signing &amp;ndash;&amp;gt;
&amp;nbsp;&amp;nbsp; Provisioning&amp;nbsp; Profile 设置发布证书
6. product clean</description>
    </item>
    
    <item>
      <title>UITableView,UICollectionView,UIScrollView快速返回顶部</title>
      <link>https://blog.v5u.win/post/ios-uitableview-uicollectionview-uiscrollview-back-top/</link>
      <pubDate>Tue, 01 Sep 2015 18:53:57 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/ios-uitableview-uicollectionview-uiscrollview-back-top/</guid>
      <description>UITableView， UICollectionView都继承自UIScrollView，所以可以使用UIScrollView的方法，设置显示内容的偏移量&amp;nbsp;
[self.tableView setContentOffset:CGPointMake(0, 0) animated:YES];</description>
    </item>
    
    <item>
      <title>NSDate和时间戳互转</title>
      <link>https://blog.v5u.win/post/ios-nsdate2timenumber/</link>
      <pubDate>Fri, 28 Aug 2015 16:53:17 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/ios-nsdate2timenumber/</guid>
      <description>iOS 将时间NSDate转化为毫秒时间戳 对于将NSDate类型转换为时间戳，相信大家肯定都会，这样的示例代码，在百度等搜索引擎上面一搜索就是一大篇的东西，但是，大家有没有注意到的是 通过那些方法转换得到的时间戳是 10位的数值，这个数值在转化为 NSDate类型的时候，就会出点儿错，你会发现，每一个时间的 毫秒都是为000的；&amp;nbsp;
而正确的应该是下面这样的输出：&amp;nbsp;
&amp;nbsp;&amp;nbsp;&amp;nbsp; 好了，接下来就是问题所在了：其实呢，并不是我们代码出错了，而是因为 [[NSDate date] timeIntervalSince1970] 虽然可以获取到后面的毫秒、微秒 ，但是在保存的时候省略掉了。如一个时间戳不省略的情况下为 1395399556.862046 ，省略掉后为一般所见 1395399556 。所以想取得毫秒时用获取到的时间戳 *1000 ，想取得微秒时 用取到的时间戳 * 1000 * 1000 。这样就解释了上面的10位数值的问题，当你取毫秒的时候，就会变成13位数值了。我想这样大家应该明白了吧！&amp;nbsp; &amp;nbsp;&amp;nbsp;&amp;nbsp; 当然，说了 这么多理论性的东西，为的就是我们接下来会附上的代码的：&amp;nbsp; 将这段代码写在 你需要获取时间戳和转换的地方，而我因为是简单示范，就放在-viewDidload里面的。&amp;nbsp;
long long time = [self getDateTimeTOMilliSeconds:[NSDate date]]; NSLog(@&amp;quot;%llu&amp;quot;,time);
NSDate *dat = [self getDateTimeFromMilliSeconds:time]; NSDateFormatter * formatter = [[NSDateFormatter alloc ] init]; [formatter setDateFormat:@&amp;quot;YYYY-MM-dd hh:mm:ss.SSS&amp;quot;]; NSString *date = [formatter stringFromDate:dat]; NSString *timeLocal = [[NSString alloc] initWithFormat:@&amp;quot;%@&amp;quot;, date]; NSLog(@&amp;quot;n%@&amp;quot;, timeLocal);</description>
    </item>
    
    <item>
      <title>Unknown Class **** in Interface Builder file</title>
      <link>https://blog.v5u.win/post/ios-unknown-class-in-interface-builder-file/</link>
      <pubDate>Mon, 24 Aug 2015 10:44:12 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/ios-unknown-class-in-interface-builder-file/</guid>
      <description>I added a UIView xib file using the root class of&amp;nbsp;MyView.
I created it in the wrong place and so moved it in the project. Same project just a different folder/group.
I then had a problem when running saying&amp;hellip;
Unknown Class MyView in Interface Builder file
I couldn&amp;#39;t work out what was wrong so I have now deleted the files both from the project and from the directory.
I&amp;#39;ve done a search using SublimeText2 for the string &amp;quot;MyView&amp;quot; and it doesn&amp;#39;t exist anywhere in the project.</description>
    </item>
    
    <item>
      <title>文字上添加删除线</title>
      <link>https://blog.v5u.win/post/ios-%E6%96%87%E5%AD%97%E4%B8%8A%E6%B7%BB%E5%8A%A0%E5%88%A0%E9%99%A4%E7%BA%BF/</link>
      <pubDate>Fri, 21 Aug 2015 17:10:49 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/ios-%E6%96%87%E5%AD%97%E4%B8%8A%E6%B7%BB%E5%8A%A0%E5%88%A0%E9%99%A4%E7%BA%BF/</guid>
      <description>&amp;nbsp; &amp;nbsp;&amp;nbsp;NSString * str = @&amp;quot;ABCDEFG HIJKLMN&amp;quot;;
&amp;nbsp; &amp;nbsp; UILabel * aLab = [[UILabel alloc]initWithFrame:CGRectMake(10, 100, 300, 300)];
&amp;nbsp; &amp;nbsp; aLab.text = str;
&amp;nbsp; &amp;nbsp; NSMutableAttributedString * testAttriString = [[NSMutableAttributedString alloc] initWithString:str];
&amp;nbsp;&amp;nbsp; [testAttriString addAttribute:NSStrikethroughStyleAttributeName value:[NSNumber numberWithInt:NSUnderlineStyleSingle] range:NSMakeRange(0, testAttriString.length)];
&amp;nbsp; &amp;nbsp; aLab.attributedText = testAttriString;
&amp;nbsp; &amp;nbsp; [self.view addSubview:aLab];</description>
    </item>
    
    <item>
      <title>App Store上架前的准备</title>
      <link>https://blog.v5u.win/post/ios-appstore_public_before/</link>
      <pubDate>Fri, 21 Aug 2015 17:10:11 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/ios-appstore_public_before/</guid>
      <description>一、制作ipa发布包
1、所需装备
1）一个distribution发布版证书
2）Xcode，iTunes，完成的项目，这都不用说了
开始配置Xcode
 Build Setting &amp;mdash;&amp;gt; code signing &amp;mdash;&amp;gt; Provisioning profile 设为发布证书
 Build Setting &amp;mdash;&amp;gt;&amp;nbsp;Architectures &amp;mdash;&amp;gt; build active Architectures Only 设为NO&amp;nbsp;
  &amp;nbsp; 3. &amp;nbsp;Product&amp;mdash;&amp;gt;scheme&amp;mdash;-&amp;gt; edit scheme&amp;mdash;&amp;gt;build configration 改为release
然后：shift+command+k clean项目 &amp;mdash;&amp;gt;command+B build新项目
将Xcode里面的项目app拖到iTunes的应用里面，再将项目拖出 ，到文件里面，至此成功，可以准备提交到iTunes connection了。</description>
    </item>
    
    <item>
      <title>mac系统使用内置的 PHP</title>
      <link>https://blog.v5u.win/post/mac-php-local/</link>
      <pubDate>Tue, 18 Aug 2015 11:19:22 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/mac-php-local/</guid>
      <description>从 OS X 10.0.0 版本开始，PHP 作为 Mac 机的标准配置被提供。在默认的 web 服务器中启用 PHP，只需将 Apache 配置文件 httpd.conf 中的几行配置指令最前面的注释符号去掉，而 CGI 或 CLI 默认都可使用（可以很容易的被终端程序使用）。
按照以下的使用说明，可以快速的建立一个本地 PHP 开发环境。_强烈建议_将 PHP 升级到最新的版本。在大多数活跃的软件中， 新的版本会修复错误和添加新的功能，PHP 也是如此。请参见相应的 Mac OS X 安装文档，以进一步了解详细的信息。以下的说明以初学者的角度来详细描述如何操作来得到一个缺省的运行环境。建议所有的用户都编译或者安装一个新的打包版本。
标准的安装类型为 mod_php，在 Mac OS X 的 Apache web 服务器（默认 web 服务器，可以从系统设置中访问）中启用 PHP 包含以下的步骤：
&amp;nbsp;
 找到并打开Apache的配置文件。默认情况下，这个配置文件的位置是： _/private/etc/apache2/httpd.conf_。 使用 Finder 或者 Spotlight 来找到这个文件可能不是很容易的事情，因为在默认情况下它一般是 root 用户拥有所有权的私有文件。 Note: 要打开这个文件，可以在命令行下面使用基于 Unix 的文本编辑器，例如 _nano_，因为他的属主是 _root_，所以我们需要使用 sudo 来打开（以 root 用户权限）。例如我们在 Terminal 程序中敲入下面的指令（操作后，会提示输入密码）：sudo nano /private/etc/apache2/httpd.conf 注意 nano 中的命令：_^w（搜索），^o_（保存），以及 _^x（退出）。^_ 表示 Ctrl 键。 Note: 在Mac OS X 10.</description>
    </item>
    
    <item>
      <title>Wordpress中各个全局函数的含义和应用</title>
      <link>https://blog.v5u.win/post/blog-wordpress-global-funtion/</link>
      <pubDate>Tue, 18 Aug 2015 10:10:38 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/blog-wordpress-global-funtion/</guid>
      <description>在wordpress插件和主题开发中经常需要获取各种URL路径，wordpress提供了以下集中方法获得URL路径：
plugins_url() — 插件目录的 URL (例如：http://www.hujuntao.com/wp-content/plugins)
includes_url() — includes 目录的 URL (例如：http://www.hujuntao.com/wp-includes)
content_url() — content 目录的 URL (例如：http://www.hujuntao.com/wp-content)
admin_url() — admin 目录的 URL (例如：http://www.hujuntao.com/wp-admin/)
site_url() — 当前网站的 URL (例如：http://www.hujuntao.com)
home_url() — 当前网站首页的 URL (例如：http://www.hujuntao.com)) 
总结就是：
获得首页地址 ==&amp;gt; home_url()、bloginfo(‘url’)、get_bloginfo(‘url’)、get_home_url()。home_url() 3.0加入的函数，为了兼容老版本推荐使用bloginfo();
获得安装路径 ==&amp;gt; site_url()、bloginfo(‘wpurl’)、get_bloginfo(‘wpurl’)、get_site_url()。
如果你需要返回值 ==&amp;gt; get_bloginfo(‘url’)、get_home_url()/get_bloginfo(‘wpurl’)、get_site_url() 如果你想直接输出值 ==&amp;gt;</description>
    </item>
    
    <item>
      <title>iOS自动布局解决警告Automatic Preferred Max Layout Width is not available on iOS versions prior to 8.0</title>
      <link>https://blog.v5u.win/post/ios-automatic-preferred-max-layout-width-is-not-available-on-ios-versions-prior-to-8-0/</link>
      <pubDate>Sun, 16 Aug 2015 12:33:07 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/ios-automatic-preferred-max-layout-width-is-not-available-on-ios-versions-prior-to-8-0/</guid>
      <description>部署环境为iOS7.0可能会遇到
设置Label的 Preferred Width(自动换行最大宽度) &amp;nbsp;explicit &amp;nbsp;(明确的) &amp;nbsp; &amp;nbsp;即可</description>
    </item>
    
    <item>
      <title>主动退出iOS程序</title>
      <link>https://blog.v5u.win/post/ios-force-exit/</link>
      <pubDate>Mon, 10 Aug 2015 12:05:51 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/ios-force-exit/</guid>
      <description>exit(0);
只有这个API可以通过AppStore。</description>
    </item>
    
    <item>
      <title>iOS7之后如何获得APP唯一的身份标识</title>
      <link>https://blog.v5u.win/post/ios-uuid/</link>
      <pubDate>Sun, 09 Aug 2015 11:24:34 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/ios-uuid/</guid>
      <description>历史：
1) iOS 5.0以前，iOS 2.0版本以后UIDevice提供一个获取设备唯一标识符的方法uniqueIdentifier，因为该唯一标识符与手机一一对应，苹果觉得可能会泄露用户隐私，所以在 iOS 5.0之后该方法就被废弃掉了。
2）iOS 6.0系统新增了两个用于替换uniqueIdentifier的接口，分别是：identifierForVendor，advertisingIdentifier。
但是APP删除重装后会变化，所以使用WiFi的mac地址来取代已经废弃了的uniqueIdentifier方法。具体的方法晚上有很多，大家感兴趣的可以自己找找，这儿提供一个网址: http://stackoverflow.com/questions/677530/how-can-i-programmatically-get-the-mac-address-of-an-iphone
3）iOS 7中苹果再一次无情的封杀mac地址，使用之前的方法获取到的mac地址全部都变成了02:00:00:00:00:00。有问题总的解决啊，于是四处查资料，终于有了思路是否可以使用KeyChain来保存获取到的唯一标示符呢，这样以后即使APP删了再装回来，也可以从KeyChain中读取回来。
OK 正题来了。。。
KeyChain介绍
　我们搞iOS开发，一定都知道OS X里面的KeyChain(钥匙串)，通常要乡镇及调试的话，都得安装证书之类的，这些证书就是保存在KeyChain中，还有我们平时浏览网页记录的账号密码也都是记录在KeyChain中。iOS中的KeyChain相比OS X比较简单，整个系统只有一个KeyChain，每个程序都可以往KeyChain中记录数据，而且只能读取到自己程序记录在KeyChain中的数据。iOS中Security.framework框架提供了四个主要的方法来操作KeyChain:
[]()
// 查询 OSStatus SecItemCopyMatching(CFDictionaryRef query, CFTypeRef *result); // 添加 OSStatus SecItemAdd(CFDictionaryRef attributes, CFTypeRef *result); // 更新KeyChain中的Item OSStatus SecItemUpdate(CFDictionaryRef query, CFDictionaryRef attributesToUpdate); // 删除KeyChain中的Item OSStatus SecItemDelete(CFDictionaryRef query)  []()
　这四个方法参数比较复杂，一旦传错就会导致操作KeyChain失败，这块儿文档中介绍的比较详细，大家可以查查官方文档Keychain Services Reference。
　前面提到了每个APP只允许访问自己在KeyChain中记录的数据，那么是不是就没有别的办法访问其他APP存在KeyChain的数据了？
　苹果提供了一个方法允许同一个发商的多个APP访问各APP之间的途径，即在调SecItemAdd添加数据的时候指定AccessGroup，即访问组。一个APP可以属于同事属于多个分组，添加KeyChain数据访问组需要做一下两件事情:
　a、在APP target的bulibSetting里面设置Code Signing Entitlements，指向包含AceessGroup的分组信息的plist文件。该文件必须和工程文件在同一个目录下，我在添加访问分组的时候就因为plist文件位置问题，操作KeyChain失败，查找这个问题还花了好久的时间。
　b、在工程目录下新建一个KeychainAccessGroups.plist文件，该文件的结构中最顶层的节点必须是一个名为“keychain-access-groups”的Array，并且该Array中每一项都是一个描述分组的NSString。对于String的格式也有相应要求，格式为:&amp;ldquo;AppIdentifier.com.*&amp;ldquo;，其中APPIdentifier就是你的开发者帐号对应的ID。**
　c、在代码中往KeyChain中Add数据的时候，设置kSecAttrAccessGroup，代码如下:
[]()
　NSString *accessGroup = [NSString stringWithUTF8String:&amp;quot;APPIdentifier.</description>
    </item>
    
    <item>
      <title>MAC系统XAMPP 中 MySQL命令行客户端配置使用</title>
      <link>https://blog.v5u.win/post/mac-xampp/</link>
      <pubDate>Fri, 07 Aug 2015 23:42:00 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/mac-xampp/</guid>
      <description>MySQL客户端
&amp;nbsp; &amp;nbsp; &amp;nbsp;MySQL安装包里面，在一个名为bin的文件夹，放置了很多工具包，但是使用他们的方式是命令行（ps：最近上瘾了）。
&amp;nbsp; &amp;nbsp; &amp;nbsp; 在MAC系统，使用命令行的工具可以使用系统自带的Terminal:
&amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;
&amp;nbsp; &amp;nbsp; &amp;nbsp; 顺便在这提一下，笔者使用的php＋mysql环境是MAC版的XAMPP，MySQL的客户端工具就放置在XAMPP里面的bin文件夹。
&amp;nbsp; &amp;nbsp; &amp;nbsp; 但是如何才能使用这客户端？
&amp;nbsp; &amp;nbsp; &amp;nbsp; 在Terminal进入到XAMPP的bin文件夹，输入命令： mysql&amp;nbsp;-u&amp;nbsp;root&amp;nbsp;-p&amp;nbsp;&amp;nbsp;  &amp;nbsp; &amp;nbsp; &amp;nbsp; 并没有笔者想要的结果，应该是提示输入密码的呀？？？？？？
&amp;nbsp; &amp;nbsp; &amp;nbsp; 在Terminal反馈给我的确是 : command not found
what ? 明明就在面前，如何not found，这下苦逼了！好吧，看来需要花点时间找找问题所在了。
经过很长很长很长&amp;hellip;&amp;hellip;&amp;hellip;&amp;hellip;&amp;hellip;的时间里，终于&amp;hellip;.
原来当你输入命令的时间，系统会在/usr/bin这个位置里寻找你输入的命令，如果你没有把命令引入到这个位置，无论你直接cd到工具具体的位置调用，也是白费
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; 功夫的。只要把这个工具的绝对位置引入到/usr/bin，所有的问题就迎刃而解了，只要我们把这条命令执行：
 ln&amp;nbsp;-s&amp;nbsp;/applications/xampp/bin/mysql&amp;nbsp;/usr/bin&amp;nbsp;&amp;nbsp;  
这个时候，我们再输入链接数据库命令，然后：
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;</description>
    </item>
    
    <item>
      <title>sqlite3的使用</title>
      <link>https://blog.v5u.win/post/system-sqlite3/</link>
      <pubDate>Fri, 07 Aug 2015 23:38:47 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/system-sqlite3/</guid>
      <description>新建数据库
sqlite3 databasefilename
检查databasefilename是否存在，如果不存在就创建并进入数据库（如果直接退出，数据库文件不会创建）&amp;nbsp;&amp;nbsp;如果已经存在直接进入数据库 对数据库进行操作

创建表：
create table if not exists UserList(id integer primary key autoincrement,firstName[not null],lastName[not null],sex,birthday,remark[not null],resumeNum[not null])

该表已经创建了主键，可以自增ID

terminal命令行使用sqlite3
打开或创建：进入到文件所在目录下，输入sqlite3 filename
1、显示数据库中所有的表：.tables

2、显示表头：.head on 然后执行 select * from tableName
sqlite中命令: 以.开头,大小写敏感（数据库对象名称是大小写不敏感的） .exit .help 查看帮助 针对命令 .database 显示数据库信息；包含当前数据库的位置 .tables 或者 .table 显示表名称 &amp;nbsp;没有表则不显示 .schema 命令可以查看创建数据对象时的SQL命令； .schema databaseobjectname查看创建该数据库对象时的SQL的命令；如果没有这个数据库对象就不显示内容，不会有错误提示
.read FILENAME 执行指定文件中的SQL语句 .headers on/off &amp;nbsp;显示表头 默认off
.mode list|column|insert|line|tabs|tcl|csv &amp;nbsp; 改变输出格式，具体如下
sqlite&amp;gt; .mode list sqlite&amp;gt; select * from emp; 7369|SMITH|CLERK|7902|17-12-1980|800||20 7499|ALLEN|SALESMAN|7698|20-02-1981|1600|300|30 如果字段值为NULL 默认不显示 也就是显示空字符串</description>
    </item>
    
    <item>
      <title>获取tableviewCell在当前屏幕中的坐标值</title>
      <link>https://blog.v5u.win/post/ios-tableviewcell-frame/</link>
      <pubDate>Fri, 07 Aug 2015 13:28:36 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/ios-tableviewcell-frame/</guid>
      <description>获得当前cell对于当前屏幕的位置
CGRect&amp;nbsp;rectInTableView&amp;nbsp;=&amp;nbsp;[tableView&amp;nbsp;rectForRowAtIndexPath:indexPath]; &amp;nbsp;&amp;nbsp;
CGRect&amp;nbsp;rect&amp;nbsp;=&amp;nbsp;[tableView&amp;nbsp;convertRect:rectInTableView&amp;nbsp;toView:[tableView&amp;nbsp;superview]];</description>
    </item>
    
    <item>
      <title>自定义back按钮无法使用系统pop interactive gesture 问题</title>
      <link>https://blog.v5u.win/post/ios-backbutton-pop-interactive-gesture/</link>
      <pubDate>Thu, 06 Aug 2015 18:50:01 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/ios-backbutton-pop-interactive-gesture/</guid>
      <description>两种解决办法：
方法一：
A，我的应用是自定义的返回按钮图标(默认返回按钮样式不会出现问题3)，为了保险，写了这句代码[self.navigationItem setHidesBackButton:YES]。 由于自定义返回按钮，所以iOS7自带返回手势无效。在需要的页面加上navigationController.interactivePopGestureRecognizer.delegate = self 返回手势好用了。
B，于是出现了第二个问题。 在一级视图中，iOS样式返回的手势滑动一下，然后进入二级视图，发现，画面卡住了，按Home键转入后台，再返回应用，发现并没有Crash掉，而是直 接跳到了二级视图里，运行正常了，大家知道push和pop的原理是用进栈出栈完成的，可能因为在一级视图中滑动那一下，影响了视图在栈中的位置。 好，先解决一下这个问题，一级视图中一定要加入self.navigationController.interactivePopGestureRecognizer.enabled = NO;，先把iOS7手势返回屏蔽掉，到二级视图再用self.navigationController.interactivePopGestureRecognizer.enabled = YES打开。就Ok了。
C，好，第三个问题相继出现（其实是跟第二个一起出来的）。 手势返回拖动一半，放手，navigationBar上会出现三个小蓝点，而且位置不规律，可以肯定这个不是项目代码或者图片搞出来的东西，一定是SDK自己蹦出來的。 后台尝试发现UIBarButtonItem的title如果是nil的话，就会有这个问题。 解决方案：把[self.navigationItem setHidesBackButton:YES];去掉，然後把假装成返回按钮的UIBarButtonItem的title设置成@&amp;quot;&amp;quot;。
方法二： &amp;nbsp;&amp;nbsp;&amp;lt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;gt;&amp;nbsp;-&amp;nbsp;(&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;self.interactivePopGestureRecognizer.&amp;nbsp;=&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;self.&amp;nbsp;=&amp;nbsp; &amp;nbsp;[super dealloc]; &amp;nbsp; &amp;nbsp;  }
&amp;nbsp;&amp;nbsp;&amp;nbsp;mark&amp;nbsp;-&amp;nbsp;View&amp;nbsp;lifecycle&amp;nbsp;&amp;nbsp;-&amp;nbsp;(&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;self.interactivePopGestureRecognizer.&amp;nbsp;=&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;self.&amp;nbsp;=&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;(&amp;nbsp;&amp;nbsp;mark&amp;nbsp;-&amp;nbsp;Override&amp;nbsp;-&amp;nbsp;()pushViewController:(UIViewController&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;self.interactivePopGestureRecognizer.enabled&amp;nbsp;=&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;mark&amp;nbsp;-&amp;nbsp;UINavigationControllerDelegate&amp;nbsp;&amp;nbsp;-&amp;nbsp;()navigationController:(UINavigationController&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;didShowViewController:(UIViewController&amp;nbsp;*&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;navigationController.interactivePopGestureRecognizer.enabled&amp;nbsp;= @end
&amp;nbsp;
3、Pop interactive gesture冲突，造成页面假死问题
我遇到的情况是，Push/Pop页面时，没有立即得到想要的效果，页面没有显出出来，NavigationController的didShowViewController:回调方法也没有调用。
页面布局情况是这样的：视图A，有一个Pan手势；视图B是TabBarController，其ViewControllers都是NavigationController。视图B是视图A的子视图。
后来找到原因是：navigationController的interactive pop手势与视图A的pan手势冲突。
具体原因是：rootViewController加载时，调用了didShowViewController:，设置interactivePopGestureRecognizer可用，其实我们并不需要在root的时候也触发这个手势。所以稍加优化如下：
&amp;nbsp;-&amp;nbsp;()navigationController:(UINavigationController&amp;nbsp;*&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;didShowViewController:(UIViewController&amp;nbsp;*&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;([navigationController.viewControllers&amp;nbsp;count]&amp;nbsp;==&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;navigationController.interactivePopGestureRecognizer.enabled&amp;nbsp;=&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;navigationController.interactivePopGestureRecognizer.enabled&amp;nbsp;=&amp;nbsp;&amp;nbsp;&amp;nbsp;} </description>
    </item>
    
    <item>
      <title>XCode上设备或证书不能自动建和修改的问题解决</title>
      <link>https://blog.v5u.win/post/xcode-profile-file/</link>
      <pubDate>Tue, 04 Aug 2015 20:59:44 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/xcode-profile-file/</guid>
      <description>自从XCode支持自动维护证书之后，省去了我们手动添加设备再更新完证书之后下载的麻烦，但一直都没有搞明白自动维护的机制，导致经常出现XCode报错却不自动添加设备，同时由于证书是XCode创建的，又无法手动修改的问题。经过一段时间的测试，终于找到了解决办法，在这里分享给大家。正常的情况应该是：view sourceprint?1.no provisioning profile was found for this executable然后可以选择Fix Issue，这样XCode就会自动为我们将新的设备添加到证书里，再自动更新证书。可能遇到的错误如下：view sourceprint?1.A valid provisioning profile for this executable was not found解决方法是1. 在Target的General界面中将Team改为所对应的开发者账号团队2. 在Target的Build Settings中的Code Signing Identity都改为iOS Developer（这里不能选择自己的），Provisioning Profile改为Automatic3. 此时Clean之后再运行，就可以出现Fix Issue的对话框，选择Fix Issue即可。</description>
    </item>
    
    <item>
      <title>text/html &amp; text/plain的区别</title>
      <link>https://blog.v5u.win/post/web-texthtml-vs-textplain/</link>
      <pubDate>Fri, 24 Jul 2015 16:55:05 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/web-texthtml-vs-textplain/</guid>
      <description>需要了解的概念 　Content-Type：用于定义用户的浏览器或相关设备如何显示将要加载的数据，或者如何处理将要加载的数据
　MIME：MIME类型就是设定某种扩展名的文件用一种应用程序来打开的方式类型，当该扩展名文件被访问的时候，浏览器会自动使用指定应用程序来打开。多用于指定一些客户端自定义的文件名，以及一些媒体文件打开方式。
&amp;nbsp;
text/html的意思是将文件的content-type设置为text/html的形式，浏览器在获取到这种文件时会自动调用html的解析器对文件进行相应的处理。
text/plain的意思是将文件设置为纯文本的形式，浏览器在获取到这种文件时并不会对其进行处理。</description>
    </item>
    
    <item>
      <title>如何使用Xcode--切换tap栏</title>
      <link>https://blog.v5u.win/post/xcode-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8xcode-%E5%88%87%E6%8D%A2tap%E6%A0%8F/</link>
      <pubDate>Thu, 16 Jul 2015 11:10:27 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/xcode-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8xcode-%E5%88%87%E6%8D%A2tap%E6%A0%8F/</guid>
      <description>切换tap栏快捷键：commend+Shift+[,] ，此方法通用于其他APP上的tap栏切换
以下为转载
转自http://m.blog.csdn.net/blog/okmyang/38734063#
这次我来说说怎么设置Tab来提高在xCode的工作效率。
我是如何使用Tab来提高效率的 xCode的Tab是什么 诺，就是这一个东西。
使用过各种浏览器的你一定不会陌生。对在xCode里面我们也可以开出多个页面。而且每一个页面的状态是单独保存的。

如何提高效率 因为在实际的代码编写过程中，我们可能需要来回的查找和阅读代码。会很自然的在多个文件中跳转编辑。这时候单个编辑页面明显拖累了速度。所以我们需要多个页面来回切换就会很爽。
如上图所示。我习惯性长开着这几个Tab。
UI 如图所示，我们可以在圈起来的地方设置关键词过滤显示的文件 这样我的名为UI的Tab就只会显示storyboard。这样改UI点击起来会很方便
Data 同理可得这个表情用来显示data model的。
VC 显示ViewController的
Debug Debug这个Tab有些特殊。并不是我手动创建的。而且我配置了编译行为出来的。 这样每次Run的时候都会跳到这个名为Debug的Tab里面。这样做的原因是，我改了一个地方的代码。运行以后可能在其他地方挂掉了（或者在其他地方打了断点）。然后跟着进去看了看。然后想回到之前改代码的地方就会很麻烦。
这样设置了以后，就没有上述烦恼了。
顺便说一句 希望这些对你有所帮助。
顺便说一句：Tab直接的切换可以使用快捷键 Command + Shift + ([, ]) 其实这个快捷键适用于绝大部分有Tab的App。 都可以完成切换功能
再顺便说一句： xCode本身内存消耗很大，开Tab。感觉很是消耗内存。如果内存吃紧的话。应该去升级内存了。不然开多个Tab只会降低工作效率并不会提高。</description>
    </item>
    
    <item>
      <title>NSTimer</title>
      <link>https://blog.v5u.win/post/ios-nstimer/</link>
      <pubDate>Thu, 16 Jul 2015 11:03:51 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/ios-nstimer/</guid>
      <description>转载自
NSTimer的使用方法
1、初始化
+ (NSTimer *)timerWithTimeInterval:(NSTimeInterval)ti target:(id)aTarget selector:(SEL)aSelector userInfo:(id)userInfo repeats:(BOOL)yesOrNo;

+ (NSTimer *)scheduledTimerWithTimeInterval:(NSTimeInterval)ti target:(id)aTarget selector:(SEL)aSelector userInfo:(id)userInfo repeats:(BOOL)yesOrNo;

注：不用scheduled方式初始化的，需要手动addTimer:forMode: 将timer添加到一个runloop中。
而scheduled的初始化方法将以默认mode直接添加到当前的runloop中.
&amp;nbsp;

scheduledTimerWithTimeInterval:(NSTimeInterval)seconds &amp;nbsp;
预订一个Timer,设置一个时间间隔。
表示输入一个时间间隔对象，以秒为单位，一个&amp;gt;0的浮点类型的值，如果该值&amp;lt;0,系统会默认为0.1
&amp;nbsp;target:(id)aTarget
表示发送的对象，如self
&amp;nbsp;selector:(SEL)aSelector
方法选择器，在时间间隔内，选择调用一个实例方法
userInfo:(id)userInfo
此参数可以为nil，当定时器失效时，由你指定的对象保留和释放该定时器。
repeats:(BOOL)yesOrNo
当YES时，定时器会不断循环直至失效或被释放，当NO时，定时器会循环发送一次就失效。
invocation:(NSInvocation *)invocation
&amp;nbsp;
举例：(不可控)
NSTimer *timer&amp;nbsp;= [NSTimer&amp;nbsp;scheduledTimerWithTimeInterval:10.0&amp;nbsp;target:self&amp;nbsp;selector:@selector(timerFired:)&amp;nbsp;userInfo:nil&amp;nbsp;repeats:NO];
或(可控制)
NSTimer *myTimer&amp;nbsp;= [NSTimer&amp;nbsp;timerWithTimeInterval:3.0&amp;nbsp;target:selfselector:@selector(timerFired:)userInfo:nilrepeats:NO];
[[NSRunLoop &amp;nbsp;currentRunLoop]addTimer:myTimerforMode:NSDefaultRunLoopMode];
&amp;nbsp;
2、触发（启动）
当定时器创建完（不用scheduled的，添加到runloop中后，该定时器将在初始化时指定的timeInterval秒后自动触发。

可以使用-(void)fire;方法来立即触发该定时器；
注：You can use this method to fire a repeating timer without interrupting its regular firing schedule. If the timer is non-repeating, it is automatically invalidated after firing, even if its scheduled fire date has not arrived.</description>
    </item>
    
    <item>
      <title>iOS 开发error/debug</title>
      <link>https://blog.v5u.win/post/ios-errordebug/</link>
      <pubDate>Tue, 14 Jul 2015 21:36:20 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/ios-errordebug/</guid>
      <description>error:property with ‘retain(strong)’ attribute must be of object type&amp;nbsp;
cause: 没有包含相应地头文件，造成变量引用错误，指针指向未知</description>
    </item>
    
    <item>
      <title>iOS端App的icon和Launch Image规格实时更新</title>
      <link>https://blog.v5u.win/post/ios-launch-image/</link>
      <pubDate>Tue, 14 Jul 2015 17:45:49 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/ios-launch-image/</guid>
      <description>启动影像 ：&amp;nbsp;iPhone&amp;nbsp;：320 x 480&amp;nbsp;640 x 960 640*1136&amp;nbsp;750*1334 1242*2208&amp;nbsp;&amp;nbsp;iPad&amp;nbsp;：768 x 1004&amp;nbsp;1536 x 2008
 APP图标：&amp;nbsp;iPhone：120 x 120&amp;nbsp;180 x 180iPad：76 x 76&amp;nbsp;152 x 152
 App Store商店：1024 x 1024
 Spotlight搜索小图标：&amp;nbsp;iPhone：80 x 80&amp;nbsp;120 x 120iPad：50 x 50、29 x 29 &amp;nbsp;100 x 100、58 x 58
 文档图标：&amp;nbsp;iPhone：22 x 29&amp;nbsp;44 x 58&amp;nbsp;iPad：64 x 64、320 x 320 &amp;nbsp;128 x 128、640 x 640
 Web Clip图标 ：iPhone：&amp;nbsp;57 x 57&amp;nbsp;114 x 114&amp;nbsp;iPad：72 x 72&amp;nbsp;144 x 144</description>
    </item>
    
    <item>
      <title>Xcode如何添加pch文件</title>
      <link>https://blog.v5u.win/post/xcode-pch/</link>
      <pubDate>Tue, 14 Jul 2015 11:31:06 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/xcode-pch/</guid>
      <description>Xcode6.0之后去掉了Precompile Prefix Header 文件，主要原因可能在于Prefix Header大大的增加了Build的时间。没有了Prefix Header之后就要通过手动@import来手动导入头文件了，在失去了编程便利性的同时也降低了Build的时间。具体原因
StackOverFlow上讨论的已经比较清晰了
StackOverFlow:为什么xcode6没有自动创建pch文件呢？
那么如何在Xcode6中添加pch（Precompile Prefix Header）？ 1，Command+N，打开新建文件窗口：ios-&amp;gt;other-&amp;gt;PCH file，创建一个pch文件：“工程名-Prefix.pch”
2，将building setting中的precompile header选项的路径添加“$(SRCROOT)/项目名称/pch文件名”（例如：$(SRCROOT)/LotteryFive/LotteryFive-Prefix.pch）,编译一下程序，如果有错误检查一下添加的路径是否正确。
&amp;lt;
p style=&amp;ldquo;margin-top: 0px; margin-bottom: 0.75em; line-height: 27.200000762939453px; text-indent: 1em; color: rgb(51, 51, 51); font-family: &amp;lsquo;Helvetica Neue&amp;rsquo;, Helvetica, Tahoma, Arial, STXihei, &amp;lsquo;Microsoft YaHei&amp;rsquo;, 微软雅黑, sans-serif; white-space: normal;&amp;rdquo;&amp;gt;3，将Precompile Prefix Header为YES，预编译后的pch文件会被缓存起来，可以提高编译速度
&amp;nbsp;
[caption id=&amp;ldquo;attachment_403&amp;rdquo; align=&amp;ldquo;alignleft&amp;rdquo; width=&amp;ldquo;600&amp;rdquo;] pch文件build settings[/caption]</description>
    </item>
    
    <item>
      <title>iOS如何判断应用是否开启摄像头权限</title>
      <link>https://blog.v5u.win/post/ios-camera-right/</link>
      <pubDate>Fri, 19 Jun 2015 11:25:28 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/ios-camera-right/</guid>
      <description>NSString * mediaType = AVMediaTypeVideo;
&amp;nbsp; &amp;nbsp; AVAuthorizationStatus&amp;nbsp; authorizationStatus = [AVCaptureDevice authorizationStatusForMediaType:mediaType];
&amp;nbsp; &amp;nbsp; if (authorizationStatus == AVAuthorizationStatusRestricted || authorizationStatus == AVAuthorizationStatusDenied) {
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; UIAlertController* alertC = [UIAlertControlleralertControllerWithTitle:@&amp;quot;摄像头访问受限&amp;quot;message:nilpreferredStyle:UIAlertControllerStyleAlert];
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; [selfpresentViewController:alertC animated:YEScompletion:nil];
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; UIAlertAction* action = [UIAlertActionactionWithTitle:@&amp;quot;取消&amp;quot;style:UIAlertActionStyleCancelhandler:^(UIAlertAction*action) {
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; [selfdismissViewControllerAnimated:YEScompletion:nil];
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }];
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; [alertC addAction:action];
&amp;nbsp; &amp;nbsp; }else{
}</description>
    </item>
    
    <item>
      <title>iOS NSString 字符串处理：截取字符串、匹配字符串、分隔字符串</title>
      <link>https://blog.v5u.win/post/ios-string/</link>
      <pubDate>Thu, 04 Jun 2015 17:33:36 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/ios-string/</guid>
      <description>1.截取字符串
NSString*string =@&amp;quot;sdfsfsfsAdfsdf&amp;quot;; string = [string&amp;nbsp;substringToIndex:7];//截取下标7之后的字符串 NSLog(@&amp;quot;截取的值为：%@&amp;quot;,string); [string&amp;nbsp;substringFromIndex:2];//截取下标2之前的字符串 NSLog(@&amp;quot;截取的值为：%@&amp;quot;,string);
2.匹配字符串 NSString*string =@&amp;quot;sdfsfsfsAdfsdf&amp;quot;; NSRangerange = [stringrangeOfString:@&amp;quot;f&amp;quot;];//匹配得到的下标 NSLog(@&amp;quot;rang:%@&amp;quot;,NSStringFromRange(range)); string = [string&amp;nbsp;substringWithRange:range];//截取范围类的字符串 NSLog(@&amp;quot;截取的值为：%@&amp;quot;,string);
3.分隔字符串 NSString*string =@&amp;quot;sdfsfsfsAdfsdf&amp;quot;;
NSArray&amp;nbsp;*array = [string&amp;nbsp;componentsSeparatedByString:@&amp;quot;A&amp;quot;]; //从字符A中分隔成2个元素的数组 NSLog(@&amp;quot;array:%@&amp;quot;,array); //结果是adfsfsfs和dfsdf</description>
    </item>
    
    <item>
      <title>使用Autolayout xib实现动态高度的TableViewCell</title>
      <link>https://blog.v5u.win/post/ios-autolayouttableviewcell/</link>
      <pubDate>Wed, 03 Jun 2015 15:27:18 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/ios-autolayouttableviewcell/</guid>
      <description>文章来源于http://itony.me/381.html
创建Xib文件 首先将Cell做好布局，调整到满意的位置和宽度，然后开始做Autolayout设定。
Autolayout操作方式有两种，一种是选择目标后，使用右下角的工具栏；另一种是直接使用右键拖拽目标，在弹出的菜单中选择限制项。当选择的目标比较小的时候，可以打开左侧的菜单，在这里做拖拽操作一样是可以的。个人感觉后者更方便一些。
开始之前，先来介绍下使用的基本工具吧。

第一个按钮是和对齐有关的，就是控制多个元素（Lable, Button等）的统一约束。例如我们需要让标题和内容按照左，就选择标题和内容元素，选择Leading Edges设置为5即可。

第二个按钮是和元素位置固定有关的限制条件，直接看图吧：

右侧能够看到当前选择元素限制条件的列表：
 这里有两个参数，“Content Hugging Priority”和“Content Compression Resistance Priority”，感觉不太好理解，栈爆上找到一篇解释，讲的挺好的：Cocoa Autolayout: content hugging vs content compression resistance priority
有时候想要一个元素的间距是一个动态值，例如距离右侧至少10pt（即&amp;gt;=10pt），那么可以在上图中点击右侧按钮(齿轮)进入详细设置：

第三个按钮是有关清除限制条件、根据限制更新视图大小的工具。个人比较常用的是清除限制条件，有时候设置错了很麻烦，直接清除掉重新来就行了。

上面这些就是常用到的一些限制条件了。个人觉得使用右键拖拽弹出的菜单选择更方便和直观一些，因为菜单中会根据拖拽内容动态显示可用项供我们选择，菜单如图

大致就是这些了吧……
我来谈谈自己的用法。总体上是从上到下，从左到右做约束限制。在这个例子中，就是设置标题-&amp;gt;内容-&amp;gt;发帖人这样的顺序。

 设置标题的顶部和左侧距离，以及宽度（防止超出边界）。
 设置内容的顶部（距离标题）和左侧距离，以及宽度。设置最大行数。
 设置发帖人的顶部和左侧距离，以及高度。
 设置发帖时间的顶部和左侧距离，距离右侧间距（防止内容过长）。
 关键步骤，设置发帖人距离底部距离，如果不设置这个参数，那么下面代码计算的Cell高度会永远是0。
  多试一试，如果有错误或者缺少限制，XCode会有提示。它报出的错误一般都是必须修正的，但它给的自动修正建议有时并不是我们想要的（正确的），想清楚再添加。
代码部分 使用了xib制作的Cell，那么在原来的项目代码中如何使用呢？看代码：
 1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16</description>
    </item>
    
    <item>
      <title>微信联通公众号如何解绑</title>
      <link>https://blog.v5u.win/post/life-%E5%BE%AE%E4%BF%A1%E8%81%94%E9%80%9A%E5%85%AC%E4%BC%97%E5%8F%B7%E5%A6%82%E4%BD%95%E8%A7%A3%E7%BB%91/</link>
      <pubDate>Tue, 26 May 2015 14:20:19 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/life-%E5%BE%AE%E4%BF%A1%E8%81%94%E9%80%9A%E5%85%AC%E4%BC%97%E5%8F%B7%E5%A6%82%E4%BD%95%E8%A7%A3%E7%BB%91/</guid>
      <description> 切换到输入框，输入“解绑&amp;quot;
 然后根据提示，回复Y即可。
  </description>
    </item>
    
    <item>
      <title>如何避免在Block里用self造成循环引用</title>
      <link>https://blog.v5u.win/post/ios-%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E5%9C%A8block%E9%87%8C%E7%94%A8self%E9%80%A0%E6%88%90%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8/</link>
      <pubDate>Fri, 15 May 2015 16:00:00 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/ios-%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E5%9C%A8block%E9%87%8C%E7%94%A8self%E9%80%A0%E6%88%90%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8/</guid>
      <description>本文原引于Bannings的专栏博客
一般来说我们总会在设置Block之后，在合适的时间回调Block，而不希望回调Block的时候Block已经被释放了，所以我们需要对Block进行copy，copy到堆中，以便后用。
当一个Block被Copy的时候，如果你在Block里进行了一些调用，那么将会有一个强引用指向这些调用方法的调用者，有两个规则：
 如果你是通过引用来访问一个实例变量，那么将强引用至self
 如果你是通过值来访问一个实例变量，那么将直接强引用至这个“值”变量
  苹果官方文档里有两个例子来说明这两种情况：
上面第一种情况相当于用self.xxx来访问实例变量，所以强引用指向了self；第二种情况把实例变量变成了本地临时变量，强引用将直接指向这个本地的临时变量。大多数情况下，我们只用处理第一种情况就行了，因为第二种情况虽然会造成循环引用，但是临时变量很快就被释放了，不会造成真正的循环引用。要避免强引用到self的话，用__weak把self重新引用一下就行了，像这样：
 __weak&amp;nbsp;ViewController&amp;nbsp;*weakSelf&amp;nbsp;=&amp;nbsp;self; &amp;nbsp;  </description>
    </item>
    
    <item>
      <title>UISegmentedControl简单使用</title>
      <link>https://blog.v5u.win/post/ios-uisegmentedcontrol/</link>
      <pubDate>Thu, 14 May 2015 16:53:26 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/ios-uisegmentedcontrol/</guid>
      <description>NSArray* segMArr = [NSArray arrayWithObjects:@&amp;quot;0&amp;quot;,@&amp;quot;1&amp;quot;, nil];
UISegmentedControl* segmentC = [[UISegmentedControlalloc]initWithItems:segMArr];
&amp;nbsp; &amp;nbsp; segmentC.frame = CGRectMake(0, 178, 320, 30);
&amp;nbsp; &amp;nbsp; segmentC.segmentedControlStyle= UISegmentedControlStylePlain;
&amp;nbsp; &amp;nbsp; segmentC.tintColor = [UIColor BlueColor];
&amp;nbsp; &amp;nbsp; segmentC.selectedSegmentIndex= 0;
&amp;nbsp; &amp;nbsp; [segmentC addTarget:selfaction:@selector(segmentedControlSelected:) forControlEvents:UIControlEventValueChanged];
&amp;nbsp; &amp;nbsp; [bgView addSubview:segmentC];
 (void)segmentedControlSelected:(UISegmentedControl*)seg{  &amp;nbsp; &amp;nbsp; if(seg.selectedSegmentIndex== 0) {
&amp;nbsp;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;
&amp;nbsp; &amp;nbsp; }elseif(seg.selectedSegmentIndex== 1){
&amp;nbsp;&amp;nbsp; &amp;nbsp;
&amp;nbsp; &amp;nbsp; }
}</description>
    </item>
    
    <item>
      <title>NSData转int</title>
      <link>https://blog.v5u.win/post/ios-nsdata2int/</link>
      <pubDate>Wed, 29 Apr 2015 14:03:07 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/ios-nsdata2int/</guid>
      <description>有一种借助string的方法，经验证不对，找了半天终于找到了一个合适的，可是没有看的太明白，特补充记录在此。 1.int&amp;nbsp;-&amp;gt;&amp;nbsp;data int&amp;nbsp;i&amp;nbsp;=&amp;nbsp;1; NSData&amp;nbsp;*data&amp;nbsp;=&amp;nbsp;[NSData&amp;nbsp;dataWithBytes:&amp;nbsp;&amp;amp;i&amp;nbsp;length:&amp;nbsp;sizeof(i)];//不多解释，不明白请留言 2.data&amp;nbsp;-&amp;gt;&amp;nbsp;int int&amp;nbsp;i; [data&amp;nbsp;getBytes:&amp;nbsp;&amp;amp;i&amp;nbsp;length:&amp;nbsp;sizeof(i)];//必须要事先声明&amp;nbsp;int&amp;nbsp;变量，此处是将data里的数据赋值到&amp;nbsp;int变量&amp;nbsp;i&amp;nbsp;的地址里。 </description>
    </item>
    
    <item>
      <title>SEOer的优化思路</title>
      <link>https://blog.v5u.win/post/system-seo/</link>
      <pubDate>Sun, 26 Apr 2015 17:56:07 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/system-seo/</guid>
      <description>&amp;nbsp;
SEO是一门复杂的学问，手法很多，提高权重可以从很多角度着手，但是，什么样的网站需要用到什么样的手法，网站的不同阶段，又需要怎么样提高排名？这就是SEO排名思路了。
网站上线一段时间，有了很多关键词的排名，每天的流量也有一些，但是怎么也提高不上去，怎么办呢？
我们如果注意观察会发现，百度最近的算法又调整了，很多的大站的排名也出现了波动，最简单的，站长们比较关心的seo这个词的前三页排名可以说大调整。北京seo鱼非子，最近通过观察很多seo的老站，大站的排名出现了较大的波动，甚至焦大的博客都被黑掉了，这是怎么搞的呢？seo到底要怎么搞呢？
百度算法最近已经调整，这个是毋庸置疑的，如果你比较关注百度官方的话，百度官方最近更新了一些文章，暗示百度的算法的调整方向，下面我就说一下我的感悟。
无疑，参与内页的排名的页面越来越多，内容能不能解决用户的问题，以前研究过google的都晓得，如果百度它是指当一个用户进行搜索时点击了一个结果然后立即点击浏览器的后退按钮，然后点击了另一个站点的结果并在那里停留。这对于搜索引擎来说是一个信号——你没有提供用户想找的内容或者提供了一个差劲的体验。这种情况如果多次发生会让你在搜索引擎的排名迅速下降。
很多站长，或者行业外的人，招人做优化，一般都是给出关键词，给出网站。我想说的是，拍上去，并不难，难的是，稳定住，我们不研究任何的算法，试着想一下。如果你运用了一些手段，让自己百度排名上升了，但是如果你的网页是不安全的，或者不能够解决客户问题的，也就是不能够留住客户的，跳出率必然会很高，长久的下去，百度会检测到你的跳出率的，你的网站不能够帮助到使用百度搜索引擎的人，那百度怎么会给你一个高分呢？
之前，我在文章（什么样的原创才是SEO）里提高过怎么量化评价一个网站的高低，当百度认为你是一个高质量的网页的时候，百度会给你一个还算不错的排名，这时候就需要内容的优化了，也就是seo的根源，客户体验，这个时候才是需要客户体验，才需要做内容优化，写好的内容，做好的图片。
于此同时，我们要做的是配合好权重的导入工作，利用上自己的各种资源，因为一旦你网站百度认识了，认可了，这时候，你把跳出率降下来，让更多的网页给你加分（导入链接）这样权重提高是非常快的。
于此同时在布局文章内容的时候，一定要做好长尾词的建设，我们都知道长尾词虽然没有指数，但是排名是很容易的，尤其当你网站有了一定的权重之后，长尾词的排名是非常容易的，这时候要做的就是多多布局长尾词，让你的网站有更多入口，无论搜索人群输入什么样的长尾关键词都可以看到你的页面，内容还不错的话，就是良性的循环了。
所以SEOer在做网站排名的时候，一定要有一套完整的SEOer优化思路，不要今天听大神讲外链有用就去疯狂发外链，明天听另一个大神说原创内容好，又去大量的伪原创，我们SEOer不仅仅要学习，更重要的是要有独立思考的能力，只有这样，慢慢我们自己才能靠近大神。
北京SEO官网 www.aiyw.net‍</description>
    </item>
    
    <item>
      <title>svn上传.a文件</title>
      <link>https://blog.v5u.win/post/system-svn-.a-upload/</link>
      <pubDate>Thu, 23 Apr 2015 09:46:53 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/system-svn-.a-upload/</guid>
      <description>在mac下很多svn管理工具默认都不能上传.a文件，这让人很苦恼。从网上扒了下，找到了两个方法。 方法一： 打开终端，cd 进入到需要上传的.a文件所在的文件夹。&amp;nbsp;确保 ls能看到.a文件 然后使用命令，如：svn add libzbar.a 使用完成后出现 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;A &amp;nbsp;(bin) &amp;nbsp;libzbar.a 
表示添加成功，用svn图形管理工具就可以看到，刚才添加的.a文件，此时就可以手动上传了。
再次update后commit后 .a 文件就传成功了

方法二：
通过终端打开配置文件: open ~/.subversion/config

把下面两行(也可能是一行)中的注释和*.a去掉,&amp;nbsp;默认为注释掉了的，这表示SVN已经将它们作为默认值了。
（取消注释估计是把#去掉，个人猜测未验证）好吧，其实我没有看明白如何取消注释global-ignores = *.o *.lo *.la *.al .libs *.so .so.[0-9] *.pyc *.pyo &amp;nbsp; *.rej ~ ## .#* .*.swp .DS_Store 注意：去掉#号后要顶行
然后保存.
说明：本文获得佘小兔的日志（方法一）和&amp;nbsp;如何往svn上传原本被忽略的*.a文件（方法二）的帮助
在此感谢所有分享知识的朋友们。</description>
    </item>
    
    <item>
      <title>关于iOS</title>
      <link>https://blog.v5u.win/ios-about/</link>
      <pubDate>Thu, 16 Apr 2015 14:51:21 +0000</pubDate>
      
      <guid>https://blog.v5u.win/ios-about/</guid>
      <description>iOS是苹果apple公司移动端设备的运行平台，该平台包括iPhone，iPad，iTouch，Apple Watch等多款设备终端。
范子就是一名为该平台开发应用的iOS工程师。
除此之外，开发者还分为游戏开发工程师，还有Android安卓平台开发者，windows平台开发者，后台数据库开发者。
一个iOS应用，包括前端iOS平台代码的编写，同时也包括后台的开发，前期的原型和UI设计准备。
所以大部分时候，一个iOS开发人员是不能独立完成一个APP的实现工作的，当一个工程师可以独立完成所有的工作的时候，我们称之为全栈工程师，他们都是牛逼的人，范子很尊敬他们，范子也希望成为这种人。
iOS平台有非常多的优点，相对于Android来说，为iOS开发应用是一种享受。当然Android现在的进步也很大。范子希望两个平台都能很好的发展下去。
iOS平台是一个，安全，高效，相对人性化的平台，它基于UNIX内核的衍生版本FreeBSD发展起来的操作系统。
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;————很幸运踏入了iOS开发领域，
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;————并由此进入了软件开发的世界。</description>
    </item>
    
    <item>
      <title>iOS8.3发布了Swift 1.2带来哪些新变化</title>
      <link>https://blog.v5u.win/post/ios-ios8.3-swift-changed/</link>
      <pubDate>Tue, 14 Apr 2015 14:59:50 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/ios-ios8.3-swift-changed/</guid>
      <description>原文&amp;nbsp;&amp;nbsp;http://www.cnblogs.com/yuyongjian/p/4371400.html
苹果前几日在面向开发者推送iOS 8.3 Beta的同时，还发布了版本号为6D520o的Xcode 6.3 Beta，其中便包含了iOS 8.3 Beta和OS X v10.10 SDK，并进一步提升了Swift与Objective-C代码的交互性，而Swift业已更新至1.2版本。@未来眼之老码团队第一时间翻译了完整的Release Note。共计50多处改动，同时修改了Objective-c的语法，足见苹果对Swift语言的重视。
从&amp;nbsp;Xcode 6.3 Beta Release Notes&amp;nbsp;看出，Xcode 6.3 Beta包含了很多颇为值得开发者期待的改变，共计50多处改动，同时修改了Objective-C的语法，足见苹果对Swift语言的重视。而其代码迁移工具可以帮助开发者将其代码从Swift 1.1（Xcode 6.1）升级至Swift 1.2（Xcode 6.3），具体执行编辑菜单（Edit）-&amp;gt;转换（Convert）-至（To）Swift1.2即可。 具体更新如下：
Swift语言的增强
 Swift现在支持目标增量编译，例如当一个文件改变时不会重新编译Target中的每一个文件。这个基于固有依赖分析。所以你依然会看到有很多文件在必要情况下被重编。如果你发现需要重编但没有重编的情况，请报一个Bug出来。清理Target后再编，会按照往常的流程进行。
 增加了一个新的Set数据类型，它提供了元素唯一化，且有完整语义的通用数据类型集合。它和NSSet类型桥接，提供和Array和Dictionary相类似的功能。
 if let语句现在被扩展为可以支持多条条件判断：if&amp;nbsp;let&amp;nbsp;a&amp;nbsp;=&amp;nbsp;foo(),&amp;nbsp;b&amp;nbsp;=&amp;nbsp;bar()&amp;nbsp;where&amp;nbsp;a&amp;nbsp;&amp;lt;&amp;nbsp;b,&amp;nbsp;&amp;nbsp; let&amp;nbsp;c&amp;nbsp;=&amp;nbsp;baz()&amp;nbsp;{&amp;nbsp;&amp;nbsp; &amp;nbsp;}
  它允许你测试多种选择，并且包含一个bool判断。当然这种情况不包含嵌套判断。
let常量现在生成时不需要立即初始化，新的规则是let常量必须在被首次使用前初始化即可（和var一样）。或者说它只能被初始化，也就是说在初始化后它不能再被改变或者重新赋值，可用的模式如下： let&amp;nbsp;x:&amp;nbsp;SomeThing&amp;nbsp;&amp;nbsp; &amp;nbsp;if&amp;nbsp;condition&amp;nbsp;{&amp;nbsp;&amp;nbsp; &amp;nbsp;x&amp;nbsp;=&amp;nbsp;foo()&amp;nbsp;&amp;nbsp; &amp;nbsp;}&amp;nbsp;else&amp;nbsp;{&amp;nbsp;&amp;nbsp; &amp;nbsp;x&amp;nbsp;=&amp;nbsp;bar()&amp;nbsp;&amp;nbsp; &amp;nbsp;}&amp;nbsp;&amp;nbsp; &amp;nbsp;use(x)
这个正常的来说需要var变量用法，尽管这里没有任何修改的操作。
 “Static”静态方法和属性现在允许在class中使用(作为“class final”的别名)。你现在可以在类中声明一个静态存储属性，它享有全局存储空间和首次使用再初始化的惰性构造功能。协议Protocal现在会声明一个static的类型要求而不是声明一个class的要求。
 对于表达式闭包的类型引用有了几点改进：
   含有单返回语句的闭包现在类型检查时以单表达式闭包处理。
 匿名的且含有非空返回类型的单表达式现在可以用在Void上下文中。
 多表达式的闭包类型的情况可能无法被类型推断出来，这归功于缺乏返回类型的情况能被正确的推断出来。
   Swift中的枚举类型现在可以通过@objc关键字导出到Objective-C中。@objc的枚举类型必须定义一个整型的原始类型，并且该枚举不能泛型化或者不能使用关联值。由于Objective-C中的枚举类型没有命名空间，所以导出到Objective-C中的枚举类型以枚举名字和case项目名字的组合的方式使用。 比如在Swift中的声明：@objc&amp;nbsp;&amp;nbsp; &amp;nbsp;enum&amp;nbsp;Bear:&amp;nbsp;Int&amp;nbsp;{&amp;nbsp;&amp;nbsp; &amp;nbsp;case&amp;nbsp;Black,&amp;nbsp;Grizzly,&amp;nbsp;Polar&amp;nbsp;&amp;nbsp; &amp;nbsp;}  导出到Objective-C： typedef&amp;nbsp;NS_ENUM(NSInteger,&amp;nbsp;Bear)&amp;nbsp;{&amp;nbsp;&amp;nbsp; BearBlack,&amp;nbsp;BearGrizzly,&amp;nbsp;BearPolar&amp;nbsp;&amp;nbsp; };</description>
    </item>
    
    <item>
      <title>入定法门</title>
      <link>https://blog.v5u.win/post/life-%E5%85%A5%E5%AE%9A%E6%B3%95%E9%97%A8/</link>
      <pubDate>Thu, 09 Apr 2015 09:41:15 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/life-%E5%85%A5%E5%AE%9A%E6%B3%95%E9%97%A8/</guid>
      <description>心如止水无波，太虚无云，一寂然不动之境，然玄开一窍之中。存定真息真气，使气不离息，息不离气，合为一处，内者不出，外者不入，上下往来于一窍之内。绵绵若存，存于先天祖气，浑融磅礴，温然如春，酣然如醉，美在其中，醉然见于面，盎于背，施于四肢，四肢不言而喻。见之无象；求之无形，无一刻不在于玄关，至引则药归于鼎炉，而火候可行矣。如是则元神妙用自然，运用真火，周流运转于玄关之内</description>
    </item>
    
    <item>
      <title></title>
      <link>https://blog.v5u.win/post/ios-scoket/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/ios-scoket/</guid>
      <description>title: Socket date: 2018-08-16 tags: socket, HTTP categories: HTTP  iOS socket能做什么?
socket是TCP UDP IP HTTP 协议簇，封装为socket API
可以用来写 客户端，服务端模型，在两者之间进行数据交流
换句话说，socket API是用来进行数据交换的一簇协议，它包括TCP, UDP, IP, HTTP等协议。
那么socket在iOS中的应用场景有哪些呢？
蓝牙交互，WiFi传输，一般是将移动设备作为一个服务器来使用。
如果作为客户端使用，那就没什么可说的了，因为本来移动设备就是作为客户端的。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://blog.v5u.win/post/ios-interview/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/ios-interview/</guid>
      <description>title: 面试 date: 2018-08-16 tags: 面试 categories: iOS  当面试，问对象深拷贝，浅拷贝的时候，面试官实际上是想问什么？
拷贝方法的实现原理
指针拷贝和值拷贝
各种数据结构的 选择倾向</description>
    </item>
    
    <item>
      <title></title>
      <link>https://blog.v5u.win/post/life-%E5%89%8D%E7%BC%80-30%E4%B8%AA/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/life-%E5%89%8D%E7%BC%80-30%E4%B8%AA/</guid>
      <description>前缀 30个
e-向外 col-在一起，强度
un-否定 se-分
self-自己 neg-否定
anti-反对 de-加强
com-共同
后缀 40个
-or 名词或形容词 -ic 形容词或名词后缀
-ion 名词后缀 -ism 名词后缀，表&amp;mdash;主义
-ive 形容词或名词后缀 -ity ty 名词后缀
-ed 形容词，过去分词，过去式 -ly副词后缀
-al 形容词或名词后缀 -ful 形容词后缀
-ist 形容词或名词后缀</description>
    </item>
    
    <item>
      <title>App Store 上架流程</title>
      <link>https://blog.v5u.win/post/ios-app-store-public/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/ios-app-store-public/</guid>
      <description>App Store上架流程
 申请开发者账号 登录开发者网站，注册cer APP ID， profile (xcode 只能解决测试证书配置) 登录iTunes connection网站，注册APP xcode选择distribution profile 证书，设置build id，打包 上传到App Store。 设置APP story 发布信息，提交等待审核  </description>
    </item>
    
    <item>
      <title>Go JSON</title>
      <link>https://blog.v5u.win/post/go-json/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/go-json/</guid>
      <description>标准库
encoding/json、encoding/xml、encoding/asn1  Model
type Movie struct { Title string Year int `json:&amp;quot;released&amp;quot;` Color bool `json:&amp;quot;color,omitempty&amp;quot;` Actors []string } // 赋值 var movies = []Movie{ {Title: &amp;quot;Casablanca&amp;quot;, Year: 1942, Color: false, Actors: []string{&amp;quot;Humphrey Bogart&amp;quot;, &amp;quot;Ingrid Bergman&amp;quot;}}, {Title: &amp;quot;Cool Hand Luke&amp;quot;, Year: 1967, Color: true, Actors: []string{&amp;quot;Paul Newman&amp;quot;}}, {Title: &amp;quot;Bullitt&amp;quot;, Year: 1968, Color: true, Actors: []string{&amp;quot;Steve McQueen&amp;quot;, &amp;quot;Jacqueline Bisset&amp;quot;}}, }  在编码时，默认使用Go语言结构体的成员名字作为JSON的对象（通过reflect反射技术，我们将在12.6节讨论）。只有导出的结构体成员才会被编码，这也就是我们为什么选择用大写字母开头的成员名称。
即使对应的JSON对象名是小写字母，每个结构体的成员名也是声明为大写字母开头的。因为有些JSON成员名字和Go结构体成员名字并不相同，因此需要Go语言结构体成员Tag来指定对应的JSON名字。同样，在解码的时候也需要做同样的处理，</description>
    </item>
    
    <item>
      <title>docker 使用规则</title>
      <link>https://blog.v5u.win/post/system-docker/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/system-docker/</guid>
      <description>硬件/操作系统 要求 Docker支持以下的CentOS版本：
 CentOS 7 (64-bit) CentOS 6.5 (64-bit) 或更高的版本  前提条件 目前，CentOS 仅发行版本中的内核支持 Docker。
Docker 运行在 CentOS 7 上，要求系统为64位、系统内核版本为 3.10 以上。
Docker 运行在 CentOS-6.5 或更高的版本的 CentOS 上，要求系统为64位、系统内核版本为 2.6.32-431 或者更高版本。
### docker 的组件结构
Docker 由镜像(Image)、容器(Container)、仓库(Repository) 三部分组成。
docker-machine, docker, docker-compose (docker环境)
docker container 容器(运行实例)
docker image 镜像(安装实例)
Dockerfile(用于生成image)
### docker配置+使用
预先安装docker的相关库
 brew install docker docker-compose docker-machine  #### 启动docker-machine
To have launchd start docker-machine now and restart at login: brew services start docker-machine</description>
    </item>
    
    <item>
      <title>docker 安装并使用Redis</title>
      <link>https://blog.v5u.win/post/docker-%E5%AE%89%E8%A3%85%E5%B9%B6%E4%BD%BF%E7%94%A8redis/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/docker-%E5%AE%89%E8%A3%85%E5%B9%B6%E4%BD%BF%E7%94%A8redis/</guid>
      <description>docker 安装并使用Redis
 docker search redis
 docker pull redis #获得的是lasted版本 redis:3.2
 配置redis
  mkdir -p ./docker/redis/data mkdir -p ./docker/redis/conf vi redis.conf   # redis.conf bind 127.0.0.1 protected-mode yes appendonly no//持久化 # requirepass foobared  ps protected-mode 是在没有显示定义 bind 地址（即监听全网断），又没有设置密码 requirepass 时，只允许本地回环 127.0.0.1 访问。 也就是说当开启了 protected-mode 时，如果你既没有显示的定义了 bind 监听的地址，同时又没有设置 auth 密码。那你只能通过 127.0.0.1 来访问 redis 服务
  </description>
    </item>
    
    <item>
      <title>go Mac环境配置</title>
      <link>https://blog.v5u.win/post/go-mac%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/go-mac%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</guid>
      <description>在官网下载pkg安装包,点击安装，安装完成后，资源被写入/usr/local/go 目录下
 设置profile文件，我用的zsh，修改~/.zshrc。用bash的同理，修改~/.bash_profile
# go export GOROOT=/usr/local/go export GOPATH=~/dev/go/golib:~/dev/go/project #工作区，存放go源码文件的目录 export GOBIN=~/dev/go/gobin #存放编译后可执行文件的目录 export PATH=$PATH:$GOROOT/bin/:$GOBIN   3.验证，命令行执行go version返回go version go1.11.5 darwin/amd64。go语言环境配置完毕。</description>
    </item>
    
    <item>
      <title>jekyll using standards 使用规范</title>
      <link>https://blog.v5u.win/post/blog-jekyll/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/blog-jekyll/</guid>
      <description>jekyll using standards 使用规范  文章就是普通的文本文件，文件名假定为2012-08-25-hello-world.html。 (注意，文件名必须为&amp;rdquo;年-月-日-文章标题.后缀名&amp;rdquo;的格式。如果网页代码采用html格式，后缀名为html；如果采用markdown格式，后缀名为md。）
 在该文件中，填入以下内容：（注意，行首不能有空格）
--- layout: default title: 你好，世界 --- &amp;lt;h2&amp;gt;{{ page.title }}&amp;lt;/h2&amp;gt; &amp;lt;p&amp;gt;我的第一篇文章&amp;lt;/p&amp;gt; &amp;lt;p&amp;gt;{{ page.date | date_to_string }}&amp;lt;/p&amp;gt;  每篇文章的头部，必须有一个yaml文件头，用来设置一些元数据。 它用三根短划线&amp;rdquo;&amp;mdash;&amp;ldquo;，标记开始和结束，里面每一行设置一种元数据。&amp;rdquo;layout:default&amp;rdquo;，表示该文章的模板使用_layouts目录下的default.html文件；&amp;rdquo;title: 你好，世界&amp;rdquo;，表示该文章的标题是&amp;rdquo;你好，世界&amp;rdquo;， 如果不设置这个值，默认使用嵌入文件名的标题，即&amp;rdquo;hello world&amp;rdquo;。
  每个页面都可以有自己的头信息，可以覆盖Jekyll和_config.yml里面的值
 --- layout: post title: 一步一步创建Jekyll主题 categories: [jekyll github markdown rouge] date: 2016-9-3 15:47:05 excerpt: &amp;quot;&amp;quot; # 覆盖清掉文章的摘要 pid: &amp;quot;&amp;quot; # 新建一个pid的字符串变量 ---   使用模板变量
	在yaml文件头后面，就是文章的正式内容，里面可以使用模板变量。	{{ page.title }}就是文件头中设置的&amp;quot;你好，世界&amp;quot;，	{{ page.date }}则是嵌入文件名的日期（也可以在文件头重新定义date变量），&amp;quot;| date_to_string&amp;quot;表示将page.date变量转化成人类可读的格式。  发布</description>
    </item>
    
    <item>
      <title>navigationbar status bug</title>
      <link>https://blog.v5u.win/post/ios-navigationbar-status-bug/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/ios-navigationbar-status-bug/</guid>
      <description>源起：
遇到一个问题，当A-&amp;gt;B, A隐藏navigationBar，设置了statusBar的颜色; B反之。
当navigationcontroller短促滑动返回 pop失败的时候，有大概率会出现navigationbar隐藏的bug
原因：这个方法引起的 - (UIStatusBarStyle)preferredStatusBarStyle,不改变状态栏颜色的话，这个bug是不会出现的.
解决：导航控制器中重写childViewControllerForStatusBarStyle方法：
-(UIViewController *)childViewControllerForStatusBarStyle{ return self.visibleViewController; }  </description>
    </item>
    
    <item>
      <title>php session 不能跨页面传递</title>
      <link>https://blog.v5u.win/post/php-session-error/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/php-session-error/</guid>
      <description>session错误
 确认当前页面session有没有添加成功 debug可不可以讲session值跨页面传递 设置php.ini文件session.auto_start=1,此时use_cookies=0，use_only_cookies=0  验证：
php -i 查看PHP配置
php.ini phpinfo()对比配置文件和实际环境配置</description>
    </item>
    
    <item>
      <title>vscode配置go开发环境</title>
      <link>https://blog.v5u.win/post/vscode-%E9%85%8D%E7%BD%AEgo%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.v5u.win/post/vscode-%E9%85%8D%E7%BD%AEgo%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</guid>
      <description>下载安装 vscode，安装Go插件。在商店中搜索安装。
配置 settings.json cmd+, ——&amp;gt; 用户设置/扩展 ——&amp;gt; Go configuration / 在 setting.json 中编辑。
参考 Sublime Text 中的 preferences.sublime-setting 很像。
在 .vscode 目录下 新建 settings.json 文件
{ //setting.json &amp;quot;files.autoSave&amp;quot;: &amp;quot;onWindowChange&amp;quot;, &amp;quot;[go]&amp;quot;: { &amp;quot;editor.insertSpaces&amp;quot;: false, &amp;quot;editor.formatOnSave&amp;quot;: true, }, &amp;quot;go.goroot&amp;quot;: &amp;quot;/usr/local/go&amp;quot;, &amp;quot;go.gopath&amp;quot;: &amp;quot;/User/xxx/&amp;quot;, &amp;quot;go.buildOnSave&amp;quot;:&amp;quot;package&amp;quot;, &amp;quot;go.lintOnSave&amp;quot;: &amp;quot;file&amp;quot;, &amp;quot;go.vetOnSave&amp;quot;: &amp;quot;off&amp;quot;, &amp;quot;go.buildTags&amp;quot;: &amp;quot;&amp;quot;, &amp;quot;go.buildFlags&amp;quot;: [], &amp;quot;go.lintFlags&amp;quot;: [], &amp;quot;go.vetFlags&amp;quot;: [], &amp;quot;go.coverOnSave&amp;quot;: false, &amp;quot;go.useCodeSnippetsOnFunctionSuggest&amp;quot;: false, &amp;quot;go.formatTool&amp;quot;: &amp;quot;goreturns&amp;quot;, &amp;quot;go.gocodeAutoBuild&amp;quot;: true }  配置 tesks.json 支持 go run 命令 在 .</description>
    </item>
    
  </channel>
</rss>