<!doctype html>
<html lang="zh-CN">
  <head>
    <title>Go的数据结构 // 为吾优</title>
    <meta charset="utf-8" />
    <meta name="generator" content="Hugo 0.55.5" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="author" content="John Doe" />
    <meta name="description" content="" />
    <link rel="stylesheet" href="http://blog.v5u.win/css/main.min.59023e5fd38d6ecb0e1dfbb295077c3c67e00e3b9eb3feaf34b5a5e6b332897a.css" />

    
    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Go的数据结构"/>
<meta name="twitter:description" content="注意：在Go语言中，我们对程序实体的访问权限控制只能通过它们的名字来实现。名字首字母为大写的程序实体可以被任何代码包中的代码访问到。而名字首字母为小写的程序实体则只能被同一个代码包中的代码所访问。
变量声明 变量 var num int = 1 常量 const channle = &quot;go&quot;  数据类型 整型，
浮点型，
复数 complex64(3.7E&#43;1&#43;5.98E-2i),由两个浮点型组成分别表示实部和虚部
byte 是 uint8 的别名
rune 是 int32 的别名，用来表示Unicode。&rsquo;A&rsquo;: U&#43;0041
字符串
​ 从表象上来说是字符序列，但是在底层，一个字符串值却是由若干个字节来表现和存储的。一个字符串（也可以说字符序列）会被Go语言用Unicode编码规范中的UTF-8编码格式编码为字节数组。
​ 注意，我们在一个字符串值或者一个字符串类型的变量之上应用Go语言的内置函数len将会得到代表它的那个字节数组的长度。这可能与我们看到的表象是不同的。字符串的表示法有两种，即：原生表示法和解释型表示法。若用原生表示法，需用反引号“`”把字符序列包裹起来。若用解释型表示法，则需用双引号“&rdquo;”包裹字符序列。
​ 二者的区别是，前者表示的值是所见即所得的（除了回车符）。在那对反引号之间的内容就是该字符串值本身。而后者所表示的值中的转义符会起作用并在程序编译期间被转义。所以，如此表示的字符串值的实际值可能会与我们看到的表象不相同。
​ 最后要注意，字符串值是不可变的。也就是说，我们一旦创建了一个此类型的值，就不可能再对它本身做任何修改。
数组
声明：type MyNumbers [3]int
表示数组长度为 3 存储元素类型为 int 的容器，MyNumbers 为 [3]int 的别名类型
声明并赋值：
// 两种声明方式 var numbers = [3]int{1, 2, 3} var numbers = [...]int{1, 2, 3} numbers[1] = 4  最后，要注意，如果我们只声明一个数组类型的变量而不为它赋值，那么该变量的值将会是指定长度的、其中各元素均为元素类型的零值（或称默认值）的数组值。例如，若有这样一个变量："/>

    <meta property="og:title" content="Go的数据结构" />
<meta property="og:description" content="注意：在Go语言中，我们对程序实体的访问权限控制只能通过它们的名字来实现。名字首字母为大写的程序实体可以被任何代码包中的代码访问到。而名字首字母为小写的程序实体则只能被同一个代码包中的代码所访问。
变量声明 变量 var num int = 1 常量 const channle = &quot;go&quot;  数据类型 整型，
浮点型，
复数 complex64(3.7E&#43;1&#43;5.98E-2i),由两个浮点型组成分别表示实部和虚部
byte 是 uint8 的别名
rune 是 int32 的别名，用来表示Unicode。&rsquo;A&rsquo;: U&#43;0041
字符串
​ 从表象上来说是字符序列，但是在底层，一个字符串值却是由若干个字节来表现和存储的。一个字符串（也可以说字符序列）会被Go语言用Unicode编码规范中的UTF-8编码格式编码为字节数组。
​ 注意，我们在一个字符串值或者一个字符串类型的变量之上应用Go语言的内置函数len将会得到代表它的那个字节数组的长度。这可能与我们看到的表象是不同的。字符串的表示法有两种，即：原生表示法和解释型表示法。若用原生表示法，需用反引号“`”把字符序列包裹起来。若用解释型表示法，则需用双引号“&rdquo;”包裹字符序列。
​ 二者的区别是，前者表示的值是所见即所得的（除了回车符）。在那对反引号之间的内容就是该字符串值本身。而后者所表示的值中的转义符会起作用并在程序编译期间被转义。所以，如此表示的字符串值的实际值可能会与我们看到的表象不相同。
​ 最后要注意，字符串值是不可变的。也就是说，我们一旦创建了一个此类型的值，就不可能再对它本身做任何修改。
数组
声明：type MyNumbers [3]int
表示数组长度为 3 存储元素类型为 int 的容器，MyNumbers 为 [3]int 的别名类型
声明并赋值：
// 两种声明方式 var numbers = [3]int{1, 2, 3} var numbers = [...]int{1, 2, 3} numbers[1] = 4  最后，要注意，如果我们只声明一个数组类型的变量而不为它赋值，那么该变量的值将会是指定长度的、其中各元素均为元素类型的零值（或称默认值）的数组值。例如，若有这样一个变量：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://blog.v5u.win/fanyiqing/_posts/go-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" />
<meta property="article:published_time" content="2019-02-17T00:00:00&#43;00:00"/>
<meta property="article:modified_time" content="2019-02-17T00:00:00&#43;00:00"/>


  </head>
  <body>
    <header class="app-header">
      <a href="http://blog.v5u.win/"><img class="app-header-avatar" src="/avatar.jpg" alt="John Doe" /></a>
      <h1>为吾优</h1>
      <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nunc vehicula turpis sit amet elit pretium.</p>
      <div class="app-header-social">
        
      </div>
    </header>
    <main class="app-container">
      
  <article class="post">
    <header class="post-header">
      <h1 class ="post-title">Go的数据结构</h1>
      <div class="post-meta">
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar">
  <title>calendar</title>
  <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line>
</svg>
          Feb 17, 2019
        </div>
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock">
  <title>clock</title>
  <circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline>
</svg>
          2 min read
        </div></div>
    </header>
    <div class="post-content">
      

<p><strong>注意：</strong>在Go语言中，我们对程序实体的访问权限控制只能通过它们的名字来实现。名字首字母为大写的程序实体可以被任何代码包中的代码访问到。而名字首字母为小写的程序实体则只能被同一个代码包中的代码所访问。</p>

<h4 id="变量声明">变量声明</h4>

<pre><code class="language-go">变量 var num int = 1

常量 const channle = &quot;go&quot;

</code></pre>

<h4 id="数据类型">数据类型</h4>

<p>整型，</p>

<p>浮点型，</p>

<p>复数 complex64(3.7E+1+5.98E-2i),由两个浮点型组成分别表示实部和虚部</p>

<p>byte 是 uint8 的别名</p>

<p>rune 是 int32 的别名，用来表示Unicode。&rsquo;A&rsquo;: U+0041</p>

<p>字符串</p>

<p>​    从表象上来说是字符序列，但是在底层，一个字符串值却是由若干个字节来表现和存储的。一个字符串（也可以说字符序列）会被Go语言用Unicode编码规范中的UTF-8编码格式编码为字节数组。</p>

<p>​    <strong>注意</strong>，我们在一个字符串值或者一个字符串类型的变量之上应用Go语言的内置函数len将会得到代表它的那个字节数组的长度。这可能与我们看到的表象是不同的。字符串的表示法有两种，即：原生表示法和解释型表示法。若用原生表示法，需用反引号“`”把字符序列包裹起来。若用解释型表示法，则需用双引号“&rdquo;”包裹字符序列。</p>

<p>​    二者的区别是，前者表示的值是所见即所得的（除了回车符）。在那对反引号之间的内容就是该字符串值本身。而后者所表示的值中的转义符会起作用并在程序编译期间被转义。所以，如此表示的字符串值的实际值可能会与我们看到的表象不相同。</p>

<p>​    最后要注意，字符串值是不可变的。也就是说，我们一旦创建了一个此类型的值，就不可能再对它本身做任何修改。</p>

<hr />

<p>数组</p>

<p>声明：type MyNumbers [3]int</p>

<p>表示数组长度为 3 存储元素类型为 int 的容器，MyNumbers 为 [3]int 的别名类型</p>

<p>声明并赋值：</p>

<pre><code class="language-go">// 两种声明方式
var numbers = [3]int{1, 2, 3}
var numbers = [...]int{1, 2, 3}
numbers[1] = 4
</code></pre>

<p>最后，要注意，如果我们只声明一个数组类型的变量而不为它赋值，那么该变量的值将会是指定长度的、其中各元素均为元素类型的零值（或称默认值）的数组值。例如，若有这样一个变量：</p>

<pre><code>var numbers2 [5]int
</code></pre>

<p>则它的值会是</p>

<pre><code class="language-go">[5]int{0, 0, 0, 0, 0}
</code></pre>

<p>切片类型 Slice</p>

<p>字面量表示：[]int 或 []string</p>

<pre><code class="language-go">var numbers3 = [5]int{1, 2, 3, 4, 5}
var slice1 = numbers3[1:4]//切片表达式 []int{2, 3, 4} 取值范围为 (1:4]
var slice1 = numbers3[1:4:4]// 第三个索引表示容量上界索引，这样切片数组不可越界访问到后边的数组元素
</code></pre>

<p>注意，被“切下”的部分<strong>不包含</strong>元素上界索引指向的元素。</p>

<p>如图所示，一个切片值的容量即为它的第一个元素值在其底层数组中的索引值与该数组长度的差值的绝对值。为了获取数组、切片或通道类型的值的容量，我们可以使用内建函数<code>cap</code>，如：</p>

<pre><code>var capacity2 int = cap(slice2)
</code></pre>

<p>​    最后，要注意，切片类型属于引用类型。它的零值即为<code>nil</code>，即空值。如果我们只声明一个切片类型的变量而不为它赋值，那么该变量的值将会是<code>nil</code>。例如，若有这样一个变量：</p>

<pre><code>var slice3 []int
</code></pre>

<p>则它的值会是 <code>nil</code></p>

<hr />

<p>字典</p>

<pre><code>字典类型：map[int]string  map[keyType]valueType
</code></pre>

<pre><code>mm := map[int]string{1: &quot;a&quot;, 2: &quot;b&quot;, 3: &quot;c&quot;}    
</code></pre>

<p>​    然后运用索引表达式取出字典中的值，就像这样：</p>

<pre><code>b := mm[2]
e, ok := mm[3]// 因为无键和空值均返回 空值，所以，ok用来获取是否有键。return c ture
</code></pre>

<p>在Go语言中有这样一项规定，即：对于字典值来说，如果其中不存在索引表达式欲取出的键值对，那么就以它的值类型的空值（或称默认值）作为该索引表达式的求值结果。</p>

<p>引用类型，零值是nil</p>

<hr />

<p>通道类型</p>

<p>通道（Channel）是Go语言中一种非常独特的数据结构。它可用于在不同Goroutine之间传递类型化的数据，并且是并发安全的。相比之下，我们之前介绍的那些数据类型都不是并发安全的。这一点需要特别注意。</p>

<p>Goroutine（也称为Go程序）可以被看做是承载可被并发执行的代码块的载体。它们由Go语言的运行时系统调度，并依托操作系统线程（又称内核线程）来并发地执行其中的代码块。</p>

<pre><code class="language-go">声明：chan T 
使用：make(chan int, 5)
// 第一个参数是代表了将被初始化的值的类型的字面量（比如chan int）
//而第二个参数则是值的长度。例,我们想要初始化一个长度为5且元素类型为int的通道值.
</code></pre>

<pre><code class="language-go">ch1 = make(chan string, 5)
ch1 &lt;- &quot;value1&quot; //为通道变量赋值
value := &lt;- ch1 //接收到的 string 赋给变量
value, ok := &lt;- ch1 // 有两个返回值，ok 代表通道的 bool 状态，开启(有效)还是关闭(无效)
close(ch1) //关闭通道
</code></pre>

<p>请注意，对通道值的重复关闭会引发运行时恐慌。这会使程序崩溃。所以一定要避免这种情况的发生。另外，在通道值有效的前提下，针对它的发送操作会在通道值已满（其中缓存的数据的个数已等于它的长度）时被阻塞。而向一个已被关闭的通道值发送数据会引发运行时恐慌。另一方面，针对有效通道值的接收操作会在它已空（其中没有缓存任何数据）时被阻塞。除此之外，还有几条与通道的发送和接收操作有关的规则。不过在这里我们记住上面这三条就可以了。</p>

<pre><code class="language-go">make(chan int, 0)// 非缓冲通道，立即阻塞知道值被接收
type Receiver &lt;-chan int // 单向接收通道类型 &lt;-chan
//类型Receiver代表了一个只可从中接收数据的单向通道类型。这样的通道也被称为接收通道。
type Sender chan&lt;- int  // 单向发送通道类型 chan&lt;-
//单向通道的主要作用是约束程序对通道值的使用方式.

var myChannel = make(chan int, 3)
var sender Sender = myChannel
var receiver Receiver = myChannel  
//编译通过

var myChannel1 chan int = sender    //编译不通过
</code></pre>

    </div>
    <div class="post-footer">
      
    </div>
  </article>

    </main>
  </body>
</html>
